/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports) {

	eval("/*** IMPORTS FROM imports-loader ***/\nvar define = false;\n\n/*==================================================\n Copyright (c) 2013-2015 司徒正美 and other contributors\n http://www.cnblogs.com/rubylouvre/\n https://github.com/RubyLouvre\n http://weibo.com/jslouvre/\n\n Released under the MIT license\n avalon.shim.js(无加载器版本) 1.4.7.1 built in 2015.11.19\n support IE6+ and other browsers\n ==================================================*/\n(function(global, factory) {\n\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        // For CommonJS and CommonJS-like environments where a proper `window`\n        // is present, execute the factory and get avalon.\n        // For environments that do not have a `window` with a `document`\n        // (such as Node.js), expose a factory as module.exports.\n        // This accentuates the need for the creation of a real `window`.\n        // e.g. var avalon = require(\"avalon\")(window);\n        module.exports = global.document ? factory(global, true) : function(w) {\n            if (!w.document) {\n                throw new Error(\"Avalon requires a window with a document\")\n            }\n            return factory(w)\n        }\n    } else {\n        factory(global)\n    }\n\n// Pass this if window is not defined yet\n}(typeof window !== \"undefined\" ? window : this, function(window, noGlobal){\n\n    /*********************************************************************\n     *                    全局变量及方法                                  *\n     **********************************************************************/\n    var expose = new Date() - 0\n//http://stackoverflow.com/questions/7290086/javascript-use-strict-and-nicks-find-global-function\n    var DOC = window.document\n    var head = DOC.getElementsByTagName(\"head\")[0] //HEAD元素\n    var ifGroup = head.insertBefore(document.createElement(\"avalon\"), head.firstChild) //避免IE6 base标签BUG\n    ifGroup.innerHTML = \"X<style id='avalonStyle'>.avalonHide{ display: none!important }</style>\"\n    ifGroup.setAttribute(\"ms-skip\", \"1\")\n    ifGroup.className = \"avalonHide\"\n    var rnative = /\\[native code\\]/ //判定是否原生函数\n    function log() {\n        if (window.console && avalon.config.debug) {\n            // http://stackoverflow.com/questions/8785624/how-to-safely-wrap-console-log\n            Function.apply.call(console.log, console, arguments)\n        }\n    }\n\n\n    var subscribers = \"$\" + expose\n    var stopRepeatAssign = false\n    var rword = /[^, ]+/g //切割字符串为一个个小块，以空格或豆号分开它们，结合replace实现字符串的forEach\n    var rcomplexType = /^(?:object|array)$/\n    var rsvg = /^\\[object SVG\\w*Element\\]$/\n    var rwindow = /^\\[object (?:Window|DOMWindow|global)\\]$/\n    var oproto = Object.prototype\n    var ohasOwn = oproto.hasOwnProperty\n    var serialize = oproto.toString\n    var ap = Array.prototype\n    var aslice = ap.slice\n    var W3C = window.dispatchEvent\n    var root = DOC.documentElement\n    var avalonFragment = DOC.createDocumentFragment()\n    var cinerator = DOC.createElement(\"div\")\n    var class2type = {}\n    \"Boolean Number String Function Array Date RegExp Object Error\".replace(rword, function (name) {\n        class2type[\"[object \" + name + \"]\"] = name.toLowerCase()\n    })\n\n\n    function noop() {\n    }\n\n\n    function oneObject(array, val) {\n        if (typeof array === \"string\") {\n            array = array.match(rword) || []\n        }\n        var result = {},\n            value = val !== void 0 ? val : 1\n        for (var i = 0, n = array.length; i < n; i++) {\n            result[array[i]] = value\n        }\n        return result\n    }\n\n//生成UUID http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript\n    var generateID = function (prefix) {\n        prefix = prefix || \"avalon\"\n        return String(Math.random() + Math.random()).replace(/\\d\\.\\d{4}/, prefix)\n    }\n    function IE() {\n        if (window.VBArray) {\n            var mode = document.documentMode\n            return mode ? mode : window.XMLHttpRequest ? 7 : 6\n        } else {\n            return NaN\n        }\n    }\n    var IEVersion = IE()\n\n    avalon = function (el) { //创建jQuery式的无new 实例化结构\n        return new avalon.init(el)\n    }\n\n    avalon.profile = function () {\n        if (window.console && avalon.config.profile) {\n            Function.apply.call(console.log, console, arguments)\n        }\n    }\n\n    /*视浏览器情况采用最快的异步回调*/\n    avalon.nextTick = new function () {// jshint ignore:line\n        var tickImmediate = window.setImmediate\n        var tickObserver = window.MutationObserver\n        if (tickImmediate) {//IE10 \\11 edage\n            return tickImmediate.bind(window)\n        }\n\n        var queue = []\n        function callback() {\n            var n = queue.length\n            for (var i = 0; i < n; i++) {\n                queue[i]()\n            }\n            queue = queue.slice(n)\n        }\n\n        if (tickObserver) {// 支持MutationObserver\n            var node = document.createTextNode(\"avalon\")\n            new tickObserver(callback).observe(node, {characterData: true})// jshint ignore:line\n            return function (fn) {\n                queue.push(fn)\n                node.data = Math.random()\n            }\n        }\n\n        if (window.VBArray) {\n            return function (fn) {\n                queue.push(fn)\n                var node = DOC.createElement(\"script\")\n                node.onreadystatechange = function () {\n                    callback() //在interactive阶段就触发\n                    node.onreadystatechange = null\n                    head.removeChild(node)\n                    node = null\n                }\n                head.appendChild(node)\n            }\n        }\n\n\n        return function (fn) {\n            setTimeout(fn, 4)\n        }\n    }// jshint ignore:line\n    /*********************************************************************\n     *                 avalon的静态方法定义区                              *\n     **********************************************************************/\n    avalon.init = function (el) {\n        this[0] = this.element = el\n    }\n    avalon.fn = avalon.prototype = avalon.init.prototype\n\n    avalon.type = function (obj) { //取得目标的类型\n        if (obj == null) {\n            return String(obj)\n        }\n        // 早期的webkit内核浏览器实现了已废弃的ecma262v4标准，可以将正则字面量当作函数使用，因此typeof在判定正则时会返回function\n        return typeof obj === \"object\" || typeof obj === \"function\" ?\n        class2type[serialize.call(obj)] || \"object\" :\n            typeof obj\n    }\n\n    var isFunction = typeof alert === \"object\" ? function (fn) {\n        try {\n            return /^\\s*\\bfunction\\b/.test(fn + \"\")\n        } catch (e) {\n            return false\n        }\n    } : function (fn) {\n        return serialize.call(fn) === \"[object Function]\"\n    }\n    avalon.isFunction = isFunction\n\n    avalon.isWindow = function (obj) {\n        if (!obj)\n            return false\n        // 利用IE678 window == document为true,document == window竟然为false的神奇特性\n        // 标准浏览器及IE9，IE10等使用 正则检测\n        return obj == obj.document && obj.document != obj //jshint ignore:line\n    }\n\n    function isWindow(obj) {\n        return rwindow.test(serialize.call(obj))\n    }\n    if (isWindow(window)) {\n        avalon.isWindow = isWindow\n    }\n    var enu\n    for (enu in avalon({})) {\n        break\n    }\n    var enumerateBUG = enu !== \"0\" //IE6下为true, 其他为false\n    /*判定是否是一个朴素的javascript对象（Object），不是DOM对象，不是BOM对象，不是自定义类的实例*/\n    avalon.isPlainObject = function (obj, key) {\n        if (!obj || avalon.type(obj) !== \"object\" || obj.nodeType || avalon.isWindow(obj)) {\n            return false;\n        }\n        try { //IE内置对象没有constructor\n            if (obj.constructor && !ohasOwn.call(obj, \"constructor\") && !ohasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n                return false;\n            }\n        } catch (e) { //IE8 9会在这里抛错\n            return false;\n        }\n        if (enumerateBUG) {\n            for (key in obj) {\n                return ohasOwn.call(obj, key)\n            }\n        }\n        for (key in obj) {\n        }\n        return key === void 0 || ohasOwn.call(obj, key)\n    }\n    if (rnative.test(Object.getPrototypeOf)) {\n        avalon.isPlainObject = function (obj) {\n            // 简单的 typeof obj === \"object\"检测，会致使用isPlainObject(window)在opera下通不过\n            return serialize.call(obj) === \"[object Object]\" && Object.getPrototypeOf(obj) === oproto\n        }\n    }\n//与jQuery.extend方法，可用于浅拷贝，深拷贝\n    avalon.mix = avalon.fn.mix = function () {\n        var options, name, src, copy, copyIsArray, clone,\n            target = arguments[0] || {},\n            i = 1,\n            length = arguments.length,\n            deep = false\n\n        // 如果第一个参数为布尔,判定是否深拷贝\n        if (typeof target === \"boolean\") {\n            deep = target\n            target = arguments[1] || {}\n            i++\n        }\n\n        //确保接受方为一个复杂的数据类型\n        if (typeof target !== \"object\" && !isFunction(target)) {\n            target = {}\n        }\n\n        //如果只有一个参数，那么新成员添加于mix所在的对象上\n        if (i === length) {\n            target = this\n            i--\n        }\n\n        for (; i < length; i++) {\n            //只处理非空参数\n            if ((options = arguments[i]) != null) {\n                for (name in options) {\n                    src = target[name]\n                    try {\n                        copy = options[name] //当options为VBS对象时报错\n                    } catch (e) {\n                        continue\n                    }\n\n                    // 防止环引用\n                    if (target === copy) {\n                        continue\n                    }\n                    if (deep && copy && (avalon.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {\n\n                        if (copyIsArray) {\n                            copyIsArray = false\n                            clone = src && Array.isArray(src) ? src : []\n\n                        } else {\n                            clone = src && avalon.isPlainObject(src) ? src : {}\n                        }\n\n                        target[name] = avalon.mix(deep, clone, copy)\n                    } else if (copy !== void 0) {\n                        target[name] = copy\n                    }\n                }\n            }\n        }\n        return target\n    }\n\n    function _number(a, len) { //用于模拟slice, splice的效果\n        a = Math.floor(a) || 0\n        return a < 0 ? Math.max(len + a, 0) : Math.min(a, len);\n    }\n\n    avalon.mix({\n        rword: rword,\n        subscribers: subscribers,\n        version: 1.471,\n        ui: {},\n        log: log,\n        slice: W3C ? function (nodes, start, end) {\n            return aslice.call(nodes, start, end)\n        } : function (nodes, start, end) {\n            var ret = []\n            var len = nodes.length\n            if (end === void 0)\n                end = len\n            if (typeof end === \"number\" && isFinite(end)) {\n                start = _number(start, len)\n                end = _number(end, len)\n                for (var i = start; i < end; ++i) {\n                    ret[i - start] = nodes[i]\n                }\n            }\n            return ret\n        },\n        noop: noop,\n        /*如果不用Error对象封装一下，str在控制台下可能会乱码*/\n        error: function (str, e) {\n            throw  (e || Error)(str)\n        },\n        /*将一个以空格或逗号隔开的字符串或数组,转换成一个键值都为1的对象*/\n        oneObject: oneObject,\n        /* avalon.range(10)\n         => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n         avalon.range(1, 11)\n         => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n         avalon.range(0, 30, 5)\n         => [0, 5, 10, 15, 20, 25]\n         avalon.range(0, -10, -1)\n         => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]\n         avalon.range(0)\n         => []*/\n        range: function (start, end, step) { // 用于生成整数数组\n            step || (step = 1)\n            if (end == null) {\n                end = start || 0\n                start = 0\n            }\n            var index = -1,\n                length = Math.max(0, Math.ceil((end - start) / step)),\n                result = new Array(length)\n            while (++index < length) {\n                result[index] = start\n                start += step\n            }\n            return result\n        },\n        eventHooks: [],\n        /*绑定事件*/\n        bind: function (el, type, fn, phase) {\n            var hooks = avalon.eventHooks\n            var hook = hooks[type]\n            if (typeof hook === \"object\") {\n                type = hook.type || type\n                phase = hook.phase || !!phase\n                fn = hook.fn ? hook.fn(el,fn): fn\n            }\n            var callback = W3C ? fn : function (e) {\n                fn.call(el, fixEvent(e));\n            }\n            if (W3C) {\n                el.addEventListener(type, callback, phase)\n            } else {\n                el.attachEvent(\"on\" + type, callback)\n            }\n            return callback\n        },\n        /*卸载事件*/\n        unbind: function (el, type, fn, phase) {\n            var hooks = avalon.eventHooks\n            var hook = hooks[type]\n            var callback = fn || noop\n            if (typeof hook === \"object\") {\n                type = hook.type || type\n                phase = hook.phase || !!phase\n            }\n            if (W3C) {\n                el.removeEventListener(type, callback, phase)\n            } else {\n                el.detachEvent(\"on\" + type, callback)\n            }\n        },\n        /*读写删除元素节点的样式*/\n        css: function (node, name, value) {\n            if (node instanceof avalon) {\n                node = node[0]\n            }\n            var prop = /[_-]/.test(name) ? camelize(name) : name, fn\n            name = avalon.cssName(prop) || prop\n            if (value === void 0 || typeof value === \"boolean\") { //获取样式\n                fn = cssHooks[prop + \":get\"] || cssHooks[\"@:get\"]\n                if (name === \"background\") {\n                    name = \"backgroundColor\"\n                }\n                var val = fn(node, name)\n                return value === true ? parseFloat(val) || 0 : val\n            } else if (value === \"\") { //请除样式\n                node.style[name] = \"\"\n            } else { //设置样式\n                if (value == null || value !== value) {\n                    return\n                }\n                if (isFinite(value) && !avalon.cssNumber[prop]) {\n                    value += \"px\"\n                }\n                fn = cssHooks[prop + \":set\"] || cssHooks[\"@:set\"]\n                fn(node, name, value)\n            }\n        },\n        /*遍历数组与对象,回调的第一个参数为索引或键名,第二个或元素或键值*/\n        each: function (obj, fn) {\n            if (obj) { //排除null, undefined\n                var i = 0\n                if (isArrayLike(obj)) {\n                    for (var n = obj.length; i < n; i++) {\n                        if (fn(i, obj[i]) === false)\n                            break\n                    }\n                } else {\n                    for (i in obj) {\n                        if (obj.hasOwnProperty(i) && fn(i, obj[i]) === false) {\n                            break\n                        }\n                    }\n                }\n            }\n        },\n        //收集元素的data-{{prefix}}-*属性，并转换为对象\n        getWidgetData: function (elem, prefix) {\n            var raw = avalon(elem).data()\n            var result = {}\n            for (var i in raw) {\n                if (i.indexOf(prefix) === 0) {\n                    result[i.replace(prefix, \"\").replace(/\\w/, function (a) {\n                        return a.toLowerCase()\n                    })] = raw[i]\n                }\n            }\n            return result\n        },\n        Array: {\n            /*只有当前数组不存在此元素时只添加它*/\n            ensure: function (target, item) {\n                if (target.indexOf(item) === -1) {\n                    return target.push(item)\n                }\n            },\n            /*移除数组中指定位置的元素，返回布尔表示成功与否*/\n            removeAt: function (target, index) {\n                return !!target.splice(index, 1).length\n            },\n            /*移除数组中第一个匹配传参的那个元素，返回布尔表示成功与否*/\n            remove: function (target, item) {\n                var index = target.indexOf(item)\n                if (~index)\n                    return avalon.Array.removeAt(target, index)\n                return false\n            }\n        }\n    })\n\n    var bindingHandlers = avalon.bindingHandlers = {}\n    var bindingExecutors = avalon.bindingExecutors = {}\n\n    /*判定是否类数组，如节点集合，纯数组，arguments与拥有非负整数的length属性的纯JS对象*/\n    function isArrayLike(obj) {\n        if (!obj)\n            return false\n        var n = obj.length\n        if (n === (n >>> 0)) { //检测length属性是否为非负整数\n            var type = serialize.call(obj).slice(8, -1)\n            if (/(?:regexp|string|function|window|global)$/i.test(type))\n                return false\n            if (type === \"Array\")\n                return true\n            try {\n                if ({}.propertyIsEnumerable.call(obj, \"length\") === false) { //如果是原生对象\n                    return  /^\\s?function/.test(obj.item || obj.callee)\n                }\n                return true\n            } catch (e) { //IE的NodeList直接抛错\n                return !obj.window //IE6-8 window\n            }\n        }\n        return false\n    }\n\n\n// https://github.com/rsms/js-lru\n    var Cache = new function() {// jshint ignore:line\n        function LRU(maxLength) {\n            this.size = 0\n            this.limit = maxLength\n            this.head = this.tail = void 0\n            this._keymap = {}\n        }\n\n        var p = LRU.prototype\n\n        p.put = function(key, value) {\n            var entry = {\n                key: key,\n                value: value\n            }\n            this._keymap[key] = entry\n            if (this.tail) {\n                this.tail.newer = entry\n                entry.older = this.tail\n            } else {\n                this.head = entry\n            }\n            this.tail = entry\n            if (this.size === this.limit) {\n                this.shift()\n            } else {\n                this.size++\n            }\n            return value\n        }\n\n        p.shift = function() {\n            var entry = this.head\n            if (entry) {\n                this.head = this.head.newer\n                this.head.older =\n                    entry.newer =\n                        entry.older =\n                            this._keymap[entry.key] = void 0\n                delete this._keymap[entry.key] //#1029\n            }\n        }\n        p.get = function(key) {\n            var entry = this._keymap[key]\n            if (entry === void 0)\n                return\n            if (entry === this.tail) {\n                return  entry.value\n            }\n            // HEAD--------------TAIL\n            //   <.older   .newer>\n            //  <--- add direction --\n            //   A  B  C  <D>  E\n            if (entry.newer) {\n                if (entry === this.head) {\n                    this.head = entry.newer\n                }\n                entry.newer.older = entry.older // C <-- E.\n            }\n            if (entry.older) {\n                entry.older.newer = entry.newer // C. --> E\n            }\n            entry.newer = void 0 // D --x\n            entry.older = this.tail // D. --> E\n            if (this.tail) {\n                this.tail.newer = entry // E. <-- D\n            }\n            this.tail = entry\n            return entry.value\n        }\n        return LRU\n    }// jshint ignore:line\n\n    /*********************************************************************\n     *                         javascript 底层补丁                       *\n     **********************************************************************/\n    if (!\"司徒正美\".trim) {\n        var rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\n        String.prototype.trim = function () {\n            return this.replace(rtrim, \"\")\n        }\n    }\n    var hasDontEnumBug = !({\n            'toString': null\n        }).propertyIsEnumerable('toString'),\n        hasProtoEnumBug = (function () {\n        }).propertyIsEnumerable('prototype'),\n        dontEnums = [\n            \"toString\",\n            \"toLocaleString\",\n            \"valueOf\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"constructor\"\n        ],\n        dontEnumsLength = dontEnums.length;\n    if (!Object.keys) {\n        Object.keys = function (object) { //ecma262v5 15.2.3.14\n            var theKeys = []\n            var skipProto = hasProtoEnumBug && typeof object === \"function\"\n            if (typeof object === \"string\" || (object && object.callee)) {\n                for (var i = 0; i < object.length; ++i) {\n                    theKeys.push(String(i))\n                }\n            } else {\n                for (var name in object) {\n                    if (!(skipProto && name === \"prototype\") && ohasOwn.call(object, name)) {\n                        theKeys.push(String(name))\n                    }\n                }\n            }\n\n            if (hasDontEnumBug) {\n                var ctor = object.constructor,\n                    skipConstructor = ctor && ctor.prototype === object\n                for (var j = 0; j < dontEnumsLength; j++) {\n                    var dontEnum = dontEnums[j]\n                    if (!(skipConstructor && dontEnum === \"constructor\") && ohasOwn.call(object, dontEnum)) {\n                        theKeys.push(dontEnum)\n                    }\n                }\n            }\n            return theKeys\n        }\n    }\n    if (!Array.isArray) {\n        Array.isArray = function (a) {\n            return serialize.call(a) === \"[object Array]\"\n        }\n    }\n\n    if (!noop.bind) {\n        Function.prototype.bind = function (scope) {\n            if (arguments.length < 2 && scope === void 0)\n                return this\n            var fn = this,\n                argv = arguments\n            return function () {\n                var args = [],\n                    i\n                for (i = 1; i < argv.length; i++)\n                    args.push(argv[i])\n                for (i = 0; i < arguments.length; i++)\n                    args.push(arguments[i])\n                return fn.apply(scope, args)\n            }\n        }\n    }\n\n    function iterator(vars, body, ret) {\n        var fun = 'for(var ' + vars + 'i=0,n = this.length; i < n; i++){' + body.replace('_', '((i in this) && fn.call(scope,this[i],i,this))') + '}' + ret\n        /* jshint ignore:start */\n        return Function(\"fn,scope\", fun)\n        /* jshint ignore:end */\n    }\n    if (!rnative.test([].map)) {\n        avalon.mix(ap, {\n            //定位操作，返回数组中第一个等于给定参数的元素的索引值。\n            indexOf: function (item, index) {\n                var n = this.length,\n                    i = ~~index\n                if (i < 0)\n                    i += n\n                for (; i < n; i++)\n                    if (this[i] === item)\n                        return i\n                return -1\n            },\n            //定位操作，同上，不过是从后遍历。\n            lastIndexOf: function (item, index) {\n                var n = this.length,\n                    i = index == null ? n - 1 : index\n                if (i < 0)\n                    i = Math.max(0, n + i)\n                for (; i >= 0; i--)\n                    if (this[i] === item)\n                        return i\n                return -1\n            },\n            //迭代操作，将数组的元素挨个儿传入一个函数中执行。Prototype.js的对应名字为each。\n            forEach: iterator(\"\", '_', \"\"),\n            //迭代类 在数组中的每个项上运行一个函数，如果此函数的值为真，则此元素作为新数组的元素收集起来，并返回新数组\n            filter: iterator('r=[],j=0,', 'if(_)r[j++]=this[i]', 'return r'),\n            //收集操作，将数组的元素挨个儿传入一个函数中执行，然后把它们的返回值组成一个新数组返回。Prototype.js的对应名字为collect。\n            map: iterator('r=[],', 'r[i]=_', 'return r'),\n            //只要数组中有一个元素满足条件（放进给定函数返回true），那么它就返回true。Prototype.js的对应名字为any。\n            some: iterator(\"\", 'if(_)return true', 'return false'),\n            //只有数组中的元素都满足条件（放进给定函数返回true），它才返回true。Prototype.js的对应名字为all。\n            every: iterator(\"\", 'if(!_)return false', 'return true')\n        })\n    }\n    /*********************************************************************\n     *                           DOM 底层补丁                             *\n     **********************************************************************/\n\n    function fixContains(root, el) {\n        try { //IE6-8,游离于DOM树外的文本节点，访问parentNode有时会抛错\n            while ((el = el.parentNode))\n                if (el === root)\n                    return true\n            return false\n        } catch (e) {\n            return false\n        }\n    }\n    avalon.contains = fixContains\n//IE6-11的文档对象没有contains\n    if (!DOC.contains) {\n        DOC.contains = function (b) {\n            return fixContains(DOC, b)\n        }\n    }\n\n    function outerHTML() {\n        return new XMLSerializer().serializeToString(this)\n    }\n\n    if (window.SVGElement) {\n        //safari5+是把contains方法放在Element.prototype上而不是Node.prototype\n        if (!DOC.createTextNode(\"x\").contains) {\n            Node.prototype.contains = function (arg) {//IE6-8没有Node对象\n                return !!(this.compareDocumentPosition(arg) & 16)\n            }\n        }\n        var svgns = \"http://www.w3.org/2000/svg\"\n        var svg = DOC.createElementNS(svgns, \"svg\")\n        svg.innerHTML = '<circle cx=\"50\" cy=\"50\" r=\"40\" fill=\"red\" />'\n        if (!rsvg.test(svg.firstChild)) { // #409\n            function enumerateNode(node, targetNode) {// jshint ignore:line\n                if (node && node.childNodes) {\n                    var nodes = node.childNodes\n                    for (var i = 0, el; el = nodes[i++]; ) {\n                        if (el.tagName) {\n                            var svg = DOC.createElementNS(svgns,\n                                el.tagName.toLowerCase())\n                            ap.forEach.call(el.attributes, function (attr) {\n                                svg.setAttribute(attr.name, attr.value) //复制属性\n                            })// jshint ignore:line\n                            // 递归处理子节点\n                            enumerateNode(el, svg)\n                            targetNode.appendChild(svg)\n                        }\n                    }\n                }\n            }\n            Object.defineProperties(SVGElement.prototype, {\n                \"outerHTML\": {//IE9-11,firefox不支持SVG元素的innerHTML,outerHTML属性\n                    enumerable: true,\n                    configurable: true,\n                    get: outerHTML,\n                    set: function (html) {\n                        var tagName = this.tagName.toLowerCase(),\n                            par = this.parentNode,\n                            frag = avalon.parseHTML(html)\n                        // 操作的svg，直接插入\n                        if (tagName === \"svg\") {\n                            par.insertBefore(frag, this)\n                            // svg节点的子节点类似\n                        } else {\n                            var newFrag = DOC.createDocumentFragment()\n                            enumerateNode(frag, newFrag)\n                            par.insertBefore(newFrag, this)\n                        }\n                        par.removeChild(this)\n                    }\n                },\n                \"innerHTML\": {\n                    enumerable: true,\n                    configurable: true,\n                    get: function () {\n                        var s = this.outerHTML\n                        var ropen = new RegExp(\"<\" + this.nodeName + '\\\\b(?:([\"\\'])[^\"]*?(\\\\1)|[^>])*>', \"i\")\n                        var rclose = new RegExp(\"<\\/\" + this.nodeName + \">$\", \"i\")\n                        return s.replace(ropen, \"\").replace(rclose, \"\")\n                    },\n                    set: function (html) {\n                        if (avalon.clearHTML) {\n                            avalon.clearHTML(this)\n                            var frag = avalon.parseHTML(html)\n                            enumerateNode(frag, this)\n                        }\n                    }\n                }\n            })\n        }\n    }\n    if (!root.outerHTML && window.HTMLElement) { //firefox 到11时才有outerHTML\n        HTMLElement.prototype.__defineGetter__(\"outerHTML\", outerHTML);\n    }\n\n\n//============================= event binding =======================\n    var rmouseEvent = /^(?:mouse|contextmenu|drag)|click/\n    function fixEvent(event) {\n        var ret = {}\n        for (var i in event) {\n            ret[i] = event[i]\n        }\n        var target = ret.target = event.srcElement\n        if (event.type.indexOf(\"key\") === 0) {\n            ret.which = event.charCode != null ? event.charCode : event.keyCode\n        } else if (rmouseEvent.test(event.type)) {\n            var doc = target.ownerDocument || DOC\n            var box = doc.compatMode === \"BackCompat\" ? doc.body : doc.documentElement\n            ret.pageX = event.clientX + (box.scrollLeft >> 0) - (box.clientLeft >> 0)\n            ret.pageY = event.clientY + (box.scrollTop >> 0) - (box.clientTop >> 0)\n            ret.wheelDeltaY = ret.wheelDelta\n            ret.wheelDeltaX = 0\n        }\n        ret.timeStamp = new Date() - 0\n        ret.originalEvent = event\n        ret.preventDefault = function () { //阻止默认行为\n            event.returnValue = false\n        }\n        ret.stopPropagation = function () { //阻止事件在DOM树中的传播\n            event.cancelBubble = true\n        }\n        return ret\n    }\n\n    var eventHooks = avalon.eventHooks\n//针对firefox, chrome修正mouseenter, mouseleave\n    if (!(\"onmouseenter\" in root)) {\n        avalon.each({\n            mouseenter: \"mouseover\",\n            mouseleave: \"mouseout\"\n        }, function (origType, fixType) {\n            eventHooks[origType] = {\n                type: fixType,\n                fn: function (elem, fn) {\n                    return function (e) {\n                        var t = e.relatedTarget\n                        if (!t || (t !== elem && !(elem.compareDocumentPosition(t) & 16))) {\n                            delete e.type\n                            e.type = origType\n                            return fn.call(elem, e)\n                        }\n                    }\n                }\n            }\n        })\n    }\n//针对IE9+, w3c修正animationend\n    avalon.each({\n        AnimationEvent: \"animationend\",\n        WebKitAnimationEvent: \"webkitAnimationEnd\"\n    }, function (construct, fixType) {\n        if (window[construct] && !eventHooks.animationend) {\n            eventHooks.animationend = {\n                type: fixType\n            }\n        }\n    })\n//针对IE6-8修正input\n    if (!(\"oninput\" in DOC.createElement(\"input\"))) {\n        eventHooks.input = {\n            type: \"propertychange\",\n            fn: function (elem, fn) {\n                return function (e) {\n                    if (e.propertyName === \"value\") {\n                        e.type = \"input\"\n                        return fn.call(elem, e)\n                    }\n                }\n            }\n        }\n    }\n    if (DOC.onmousewheel === void 0) {\n        /* IE6-11 chrome mousewheel wheelDetla 下 -120 上 120\n         firefox DOMMouseScroll detail 下3 上-3\n         firefox wheel detlaY 下3 上-3\n         IE9-11 wheel deltaY 下40 上-40\n         chrome wheel deltaY 下100 上-100 */\n        var fixWheelType = DOC.onwheel !== void 0 ? \"wheel\" : \"DOMMouseScroll\"\n        var fixWheelDelta = fixWheelType === \"wheel\" ? \"deltaY\" : \"detail\"\n        eventHooks.mousewheel = {\n            type: fixWheelType,\n            fn: function (elem, fn) {\n                return function (e) {\n                    e.wheelDeltaY = e.wheelDelta = e[fixWheelDelta] > 0 ? -120 : 120\n                    e.wheelDeltaX = 0\n                    if (Object.defineProperty) {\n                        Object.defineProperty(e, \"type\", {\n                            value: \"mousewheel\"\n                        })\n                    }\n                    fn.call(elem, e)\n                }\n            }\n        }\n    }\n\n\n\n    /*********************************************************************\n     *                           配置系统                                 *\n     **********************************************************************/\n\n    function kernel(settings) {\n        for (var p in settings) {\n            if (!ohasOwn.call(settings, p))\n                continue\n            var val = settings[p]\n            if (typeof kernel.plugins[p] === \"function\") {\n                kernel.plugins[p](val)\n            } else if (typeof kernel[p] === \"object\") {\n                avalon.mix(kernel[p], val)\n            } else {\n                kernel[p] = val\n            }\n        }\n        return this\n    }\n    var openTag, closeTag, rexpr, rexprg, rbind, rregexp = /[-.*+?^${}()|[\\]\\/\\\\]/g\n\n    function escapeRegExp(target) {\n        //http://stevenlevithan.com/regex/xregexp/\n        //将字符串安全格式化为正则表达式的源码\n        return (target + \"\").replace(rregexp, \"\\\\$&\")\n    }\n\n    var plugins = {\n\n        interpolate: function (array) {\n            openTag = array[0]\n            closeTag = array[1]\n            if (openTag === closeTag) {\n                throw new SyntaxError(\"openTag===closeTag\")\n            } else {\n                var test = openTag + \"test\" + closeTag\n                cinerator.innerHTML = test\n                if (cinerator.innerHTML !== test && cinerator.innerHTML.indexOf(\"&lt;\") > -1) {\n                    throw new SyntaxError(\"此定界符不合法\")\n                }\n                kernel.openTag = openTag\n                kernel.closeTag = closeTag\n                cinerator.innerHTML = \"\"\n            }\n            var o = escapeRegExp(openTag),\n                c = escapeRegExp(closeTag)\n            rexpr = new RegExp(o + \"(.*?)\" + c)\n            rexprg = new RegExp(o + \"(.*?)\" + c, \"g\")\n            rbind = new RegExp(o + \".*?\" + c + \"|\\\\sms-\")\n        }\n    }\n\n    kernel.debug = true\n    kernel.plugins = plugins\n    kernel.plugins['interpolate']([\"{{\", \"}}\"])\n    kernel.paths = {}\n    kernel.shim = {}\n    kernel.maxRepeatSize = 100\n    avalon.config = kernel\n    var ravalon = /(\\w+)\\[(avalonctrl)=\"(\\S+)\"\\]/\n    var findNodes = DOC.querySelectorAll ? function(str) {\n        return DOC.querySelectorAll(str)\n    } : function(str) {\n        var match = str.match(ravalon)\n        var all = DOC.getElementsByTagName(match[1])\n        var nodes = []\n        for (var i = 0, el; el = all[i++]; ) {\n            if (el.getAttribute(match[2]) === match[3]) {\n                nodes.push(el)\n            }\n        }\n        return nodes\n    }\n    /*********************************************************************\n     *                            事件总线                               *\n     **********************************************************************/\n    var EventBus = {\n        $watch: function (type, callback) {\n            if (typeof callback === \"function\") {\n                var callbacks = this.$events[type]\n                if (callbacks) {\n                    callbacks.push(callback)\n                } else {\n                    this.$events[type] = [callback]\n                }\n            } else { //重新开始监听此VM的第一重简单属性的变动\n                this.$events = this.$watch.backup\n            }\n            return this\n        },\n        $unwatch: function (type, callback) {\n            var n = arguments.length\n            if (n === 0) { //让此VM的所有$watch回调无效化\n                this.$watch.backup = this.$events\n                this.$events = {}\n            } else if (n === 1) {\n                this.$events[type] = []\n            } else {\n                var callbacks = this.$events[type] || []\n                var i = callbacks.length\n                while (~--i < 0) {\n                    if (callbacks[i] === callback) {\n                        return callbacks.splice(i, 1)\n                    }\n                }\n            }\n            return this\n        },\n        $fire: function (type) {\n            var special, i, v, callback\n            if (/^(\\w+)!(\\S+)$/.test(type)) {\n                special = RegExp.$1\n                type = RegExp.$2\n            }\n            var events = this.$events\n            if (!events)\n                return\n            var args = aslice.call(arguments, 1)\n            var detail = [type].concat(args)\n            if (special === \"all\") {\n                for (i in avalon.vmodels) {\n                    v = avalon.vmodels[i]\n                    if (v !== this) {\n                        v.$fire.apply(v, detail)\n                    }\n                }\n            } else if (special === \"up\" || special === \"down\") {\n                var elements = events.expr ? findNodes(events.expr) : []\n                if (elements.length === 0)\n                    return\n                for (i in avalon.vmodels) {\n                    v = avalon.vmodels[i]\n                    if (v !== this) {\n                        if (v.$events.expr) {\n                            var eventNodes = findNodes(v.$events.expr)\n                            if (eventNodes.length === 0) {\n                                continue\n                            }\n                            //循环两个vmodel中的节点，查找匹配（向上匹配或者向下匹配）的节点并设置标识\n                            /* jshint ignore:start */\n                            ap.forEach.call(eventNodes, function (node) {\n                                ap.forEach.call(elements, function (element) {\n                                    var ok = special === \"down\" ? element.contains(node) : //向下捕获\n                                        node.contains(element) //向上冒泡\n                                    if (ok) {\n                                        node._avalon = v //符合条件的加一个标识\n                                    }\n                                });\n                            })\n                            /* jshint ignore:end */\n                        }\n                    }\n                }\n                var nodes = DOC.getElementsByTagName(\"*\") //实现节点排序\n                var alls = []\n                ap.forEach.call(nodes, function (el) {\n                    if (el._avalon) {\n                        alls.push(el._avalon)\n                        el._avalon = \"\"\n                        el.removeAttribute(\"_avalon\")\n                    }\n                })\n                if (special === \"up\") {\n                    alls.reverse()\n                }\n                for (i = 0; callback = alls[i++]; ) {\n                    if (callback.$fire.apply(callback, detail) === false) {\n                        break\n                    }\n                }\n            } else {\n                var callbacks = events[type] || []\n                var all = events.$all || []\n                for (i = 0; callback = callbacks[i++]; ) {\n                    if (isFunction(callback))\n                        callback.apply(this, args)\n                }\n                for (i = 0; callback = all[i++]; ) {\n                    if (isFunction(callback))\n                        callback.apply(this, arguments)\n                }\n            }\n        }\n    }\n    /*********************************************************************\n     *                           modelFactory                             *\n     **********************************************************************/\n//avalon最核心的方法的两个方法之一（另一个是avalon.scan），返回一个ViewModel(VM)\n    var VMODELS = avalon.vmodels = {} //所有vmodel都储存在这里\n    avalon.define = function (id, factory) {\n        var $id = id.$id || id\n        if (!$id) {\n            log(\"warning: vm必须指定$id\")\n        }\n        if (VMODELS[$id]) {\n            log(\"warning: \" + $id + \" 已经存在于avalon.vmodels中\")\n        }\n        if (typeof id === \"object\") {\n            var model = modelFactory(id)\n        } else {\n            var scope = {\n                $watch: noop\n            }\n            factory(scope) //得到所有定义\n\n            model = modelFactory(scope) //偷天换日，将scope换为model\n            stopRepeatAssign = true\n            factory(model)\n            stopRepeatAssign = false\n        }\n        model.$id = $id\n        return VMODELS[$id] = model\n    }\n\n//一些不需要被监听的属性\n    var $$skipArray = String(\"$id,$watch,$unwatch,$fire,$events,$model,$skipArray,$reinitialize\").match(rword)\n    var defineProperty = Object.defineProperty\n    var canHideOwn = true\n//如果浏览器不支持ecma262v5的Object.defineProperties或者存在BUG，比如IE8\n//标准浏览器使用__defineGetter__, __defineSetter__实现\n    try {\n        defineProperty({}, \"_\", {\n            value: \"x\"\n        })\n        var defineProperties = Object.defineProperties\n    } catch (e) {\n        canHideOwn = false\n    }\n\n    function modelFactory(source, $special, $model) {\n        if (Array.isArray(source)) {\n            var arr = source.concat()\n            source.length = 0\n            var collection = arrayFactory(source)\n            collection.pushArray(arr)\n            return collection\n        }\n        //0 null undefined || Node || VModel(fix IE6-8 createWithProxy $val: val引发的BUG)\n        if (!source || (source.$id && source.$events) || (source.nodeType > 0 && source.nodeName) ) {\n            return source\n        }\n        var $skipArray = Array.isArray(source.$skipArray) ? source.$skipArray : []\n        $skipArray.$special = $special || {} //强制要监听的属性\n        var $vmodel = {} //要返回的对象, 它在IE6-8下可能被偷龙转凤\n        $model = $model || {} //vmodels.$model属性\n        var $events = {} //vmodel.$events属性\n        var accessors = {} //监控属性\n        var computed = []\n        $$skipArray.forEach(function (name) {\n            delete source[name]\n        })\n        var names = Object.keys(source)\n        /* jshint ignore:start */\n        names.forEach(function (name, accessor) {\n            var val = source[name]\n            $model[name] = val\n            if (isObservable(name, val, $skipArray)) {\n                //总共产生三种accessor\n                $events[name] = []\n                var valueType = avalon.type(val)\n                //总共产生三种accessor\n                if (valueType === \"object\" && isFunction(val.get) && Object.keys(val).length <= 2) {\n                    accessor = makeComputedAccessor(name, val)\n                    computed.push(accessor)\n                } else if (rcomplexType.test(valueType)) {\n                    // issue #940 解决$model层次依赖丢失 https://github.com/RubyLouvre/avalon/issues/940\n                    //  $model[name] = {}\n                    accessor = makeComplexAccessor(name, val, valueType, $events[name], $model)\n                } else {\n                    accessor = makeSimpleAccessor(name, val)\n                }\n                accessors[name] = accessor\n            }\n        })\n        /* jshint ignore:end */\n        $vmodel = defineProperties($vmodel, descriptorFactory(accessors), source) //生成一个空的ViewModel\n        for (var i = 0; i < names.length; i++) {\n            var name = names[i]\n            if (!accessors[name]) {\n                $vmodel[name] = source[name]\n            }\n        }\n        //添加$id, $model, $events, $watch, $unwatch, $fire\n        hideProperty($vmodel, \"$id\", generateID())\n        hideProperty($vmodel, \"$model\", $model)\n        hideProperty($vmodel, \"$events\", $events)\n        /* jshint ignore:start */\n        if (canHideOwn) {\n            hideProperty($vmodel, \"hasOwnProperty\", function (name) {\n                return name in $vmodel.$model\n            })\n        } else {\n            $vmodel.hasOwnProperty = function (name) {\n                return (name in $vmodel.$model) && (name !== \"hasOwnProperty\")\n            }\n        }\n        /* jshint ignore:end */\n        for ( i in EventBus) {\n            hideProperty($vmodel, i, EventBus[i].bind($vmodel))\n        }\n\n        $vmodel.$reinitialize = function () {\n            computed.forEach(function (accessor) {\n                delete accessor._value\n                delete accessor.oldArgs\n                accessor.digest = function () {\n                    accessor.call($vmodel)\n                }\n                dependencyDetection.begin({\n                    callback: function (vm, dependency) {//dependency为一个accessor\n                        var name = dependency._name\n                        if (dependency !== accessor) {\n                            var list = vm.$events[name]\n                            injectDependency(list, accessor.digest)\n                        }\n                    }\n                })\n                try {\n                    accessor.get.call($vmodel)\n                } finally {\n                    dependencyDetection.end()\n                }\n            })\n        }\n        $vmodel.$reinitialize()\n        return $vmodel\n    }\n\n\n    function hideProperty(host, name, value) {\n        if (canHideOwn) {\n            Object.defineProperty(host, name, {\n                value: value,\n                writable: true,\n                enumerable: false,\n                configurable: true\n            })\n        } else {\n            host[name] = value\n        }\n    }\n//创建一个简单访问器\n    function makeSimpleAccessor(name, value) {\n        function accessor(value) {\n            var oldValue = accessor._value\n            if (arguments.length > 0) {\n                if (!stopRepeatAssign && !isEqual(value, oldValue)) {\n                    accessor.updateValue(this, value)\n                    accessor.notify(this, value, oldValue)\n                }\n                return this\n            } else {\n                dependencyDetection.collectDependency(this, accessor)\n                return oldValue\n            }\n        }\n        accessorFactory(accessor, name)\n        accessor._value = value\n        return accessor;\n    }\n\n//创建一个计算访问器\n    function makeComputedAccessor(name, options) {\n        function accessor(value) {//计算属性\n            var oldValue = accessor._value\n            var init = (\"_value\" in accessor)\n            if (arguments.length > 0) {\n                if (stopRepeatAssign) {\n                    return this\n                }\n                if (typeof accessor.set === \"function\") {\n                    if (accessor.oldArgs !== value) {\n                        accessor.oldArgs = value\n                        var $events = this.$events\n                        var lock = $events[name]\n                        $events[name] = [] //清空回调，防止内部冒泡而触发多次$fire\n                        accessor.set.call(this, value)\n                        $events[name] = lock\n                        value = accessor.get.call(this)\n                        if (value !== oldValue) {\n                            accessor.updateValue(this, value)\n                            accessor.notify(this, value, oldValue) //触发$watch回调\n                        }\n                    }\n                }\n                return this\n            } else {\n                //将依赖于自己的高层访问器或视图刷新函数（以绑定对象形式）放到自己的订阅数组中\n                //将自己注入到低层访问器的订阅数组中\n                value = accessor.get.call(this)\n                accessor.updateValue(this, value)\n                if (init && oldValue !== value) {\n                    accessor.notify(this, value, oldValue) //触发$watch回调\n                }\n                return value\n            }\n        }\n        accessor.set = options.set\n        accessor.get = options.get\n        accessorFactory(accessor, name)\n        return accessor\n    }\n\n//创建一个复杂访问器\n    function makeComplexAccessor(name, initValue, valueType, list, parentModel) {\n\n        function accessor(value) {\n            var oldValue = accessor._value\n\n            var son = accessor._vmodel\n            if (arguments.length > 0) {\n                if (stopRepeatAssign) {\n                    return this\n                }\n                if (valueType === \"array\") {\n                    var a = son, b = value,\n                        an = a.length,\n                        bn = b.length\n                    a.$lock = true\n                    if (an > bn) {\n                        a.splice(bn, an - bn)\n                    } else if (bn > an) {\n                        a.push.apply(a, b.slice(an))\n                    }\n                    var n = Math.min(an, bn)\n                    for (var i = 0; i < n; i++) {\n                        a.set(i, b[i])\n                    }\n                    delete a.$lock\n                    a._fire(\"set\")\n                } else if (valueType === \"object\") {\n                    value = value.$model ? value.$model : value\n                    var observes = this.$events[name] || []\n                    var newObject = avalon.mix(true, {}, value)\n                    for(i in son ){\n                        if(son.hasOwnProperty(i) && ohasOwn.call(newObject,i)){\n                            son[i] = newObject[i]\n                        }\n                    }\n                    son = accessor._vmodel = modelFactory(value)\n                    son.$events[subscribers] = observes\n                    if (observes.length) {\n                        observes.forEach(function (data) {\n                            if (!data.type) {\n                                return //数据未准备好时忽略更新\n                            }\n                            if (data.rollback) {\n                                data.rollback() //还原 ms-with ms-on\n                            }\n                            bindingHandlers[data.type](data, data.vmodels)\n                        })\n                    }\n                }\n                accessor.updateValue(this, son.$model)\n                accessor.notify(this, this._value, oldValue)\n                return this\n            } else {\n                dependencyDetection.collectDependency(this, accessor)\n                return son\n            }\n        }\n        accessorFactory(accessor, name)\n        if (Array.isArray(initValue)) {\n            parentModel[name] = initValue\n        } else {\n            parentModel[name] = parentModel[name] || {}\n        }\n        var son = accessor._vmodel = modelFactory(initValue, 0, parentModel[name])\n        son.$events[subscribers] = list\n        return accessor\n    }\n\n    function globalUpdateValue(vmodel, value) {\n        vmodel.$model[this._name] = this._value = value\n    }\n\n    function globalNotify(vmodel, value, oldValue) {\n        var name = this._name\n        var array = vmodel.$events[name] //刷新值\n        if (array) {\n            fireDependencies(array) //同步视图\n            EventBus.$fire.call(vmodel, name, value, oldValue) //触发$watch回调\n        }\n    }\n\n    function accessorFactory(accessor, name) {\n        accessor._name = name\n        //同时更新_value与model\n        accessor.updateValue = globalUpdateValue\n        accessor.notify = globalNotify\n    }\n\n//比较两个值是否相等\n    var isEqual = Object.is || function (v1, v2) {\n            if (v1 === 0 && v2 === 0) {\n                return 1 / v1 === 1 / v2\n            } else if (v1 !== v1) {\n                return v2 !== v2\n            } else {\n                return v1 === v2\n            }\n        }\n\n    function isObservable(name, value, $skipArray) {\n        if (isFunction(value) || value && value.nodeName && (value.nodeType > 0) ) {\n            return false\n        }\n        if ($skipArray.indexOf(name) !== -1) {\n            return false\n        }\n        var $special = $skipArray.$special\n        if (name && name.charAt(0) === \"$\" && !$special[name]) {\n            return false\n        }\n        return true\n    }\n    function keysVM(obj) {\n        var arr = Object.keys(obj.$model ? obj.$model: obj)\n        for (var i = 0; i < $$skipArray.length; i++) {\n            var index = arr.indexOf($$skipArray[i])\n            if (index !== -1) {\n                arr.splice(index, 1)\n            }\n        }\n        return arr\n    }\n    var descriptorFactory = W3C ? function (obj) {\n        var descriptors = {}\n        for (var i in obj) {\n            descriptors[i] = {\n                get: obj[i],\n                set: obj[i],\n                enumerable: true,\n                configurable: true\n            }\n        }\n        return descriptors\n    } : function (a) {\n        return a\n    }\n\n//===================修复浏览器对Object.defineProperties的支持=================\n    if (!canHideOwn) {\n        if (\"__defineGetter__\" in avalon) {\n            defineProperty = function (obj, prop, desc) {\n                if ('value' in desc) {\n                    obj[prop] = desc.value\n                }\n                if (\"get\" in desc) {\n                    obj.__defineGetter__(prop, desc.get)\n                }\n                if ('set' in desc) {\n                    obj.__defineSetter__(prop, desc.set)\n                }\n                return obj\n            }\n            defineProperties = function (obj, descs) {\n                for (var prop in descs) {\n                    if (descs.hasOwnProperty(prop)) {\n                        defineProperty(obj, prop, descs[prop])\n                    }\n                }\n                return obj\n            }\n        }\n        if (IEVersion) {\n            var VBClassPool = {}\n            window.execScript([// jshint ignore:line\n                \"Function parseVB(code)\",\n                \"\\tExecuteGlobal(code)\",\n                \"End Function\" //转换一段文本为VB代码\n            ].join(\"\\n\"), \"VBScript\")\n            function VBMediator(instance, accessors, name, value) {// jshint ignore:line\n                var accessor = accessors[name]\n                if (arguments.length === 4) {\n                    accessor.call(instance, value)\n                } else {\n                    return accessor.call(instance)\n                }\n            }\n            defineProperties = function (name, accessors, properties) {\n                // jshint ignore:line\n                var buffer = []\n                buffer.push(\n                    \"\\r\\n\\tPrivate [__data__], [__proxy__]\",\n                    \"\\tPublic Default Function [__const__](d\"+expose+\", p\"+expose+\")\",\n                    \"\\t\\tSet [__data__] = d\"+expose+\": set [__proxy__] = p\"+expose,\n                    \"\\t\\tSet [__const__] = Me\", //链式调用\n                    \"\\tEnd Function\")\n                //添加普通属性,因为VBScript对象不能像JS那样随意增删属性，必须在这里预先定义好\n                for (name in properties) {\n                    if (!accessors.hasOwnProperty(name)) {\n                        buffer.push(\"\\tPublic [\" + name + \"]\")\n                    }\n                }\n                $$skipArray.forEach(function (name) {\n                    if (!accessors.hasOwnProperty(name)) {\n                        buffer.push(\"\\tPublic [\" + name + \"]\")\n                    }\n                })\n                buffer.push(\"\\tPublic [\" + 'hasOwnProperty' + \"]\")\n                //添加访问器属性\n                for (name in accessors) {\n                    buffer.push(\n                        //由于不知对方会传入什么,因此set, let都用上\n                        \"\\tPublic Property Let [\" + name + \"](val\" + expose + \")\", //setter\n                        \"\\t\\tCall [__proxy__](Me,[__data__], \\\"\" + name + \"\\\", val\" + expose + \")\",\n                        \"\\tEnd Property\",\n                        \"\\tPublic Property Set [\" + name + \"](val\" + expose + \")\", //setter\n                        \"\\t\\tCall [__proxy__](Me,[__data__], \\\"\" + name + \"\\\", val\" + expose + \")\",\n                        \"\\tEnd Property\",\n                        \"\\tPublic Property Get [\" + name + \"]\", //getter\n                        \"\\tOn Error Resume Next\", //必须优先使用set语句,否则它会误将数组当字符串返回\n                        \"\\t\\tSet[\" + name + \"] = [__proxy__](Me,[__data__],\\\"\" + name + \"\\\")\",\n                        \"\\tIf Err.Number <> 0 Then\",\n                        \"\\t\\t[\" + name + \"] = [__proxy__](Me,[__data__],\\\"\" + name + \"\\\")\",\n                        \"\\tEnd If\",\n                        \"\\tOn Error Goto 0\",\n                        \"\\tEnd Property\")\n\n                }\n\n                buffer.push(\"End Class\")\n                var body = buffer.join(\"\\r\\n\")\n                var className =VBClassPool[body]\n                if (!className) {\n                    className = generateID(\"VBClass\")\n                    window.parseVB(\"Class \" + className + body)\n                    window.parseVB([\n                        \"Function \" + className + \"Factory(a, b)\", //创建实例并传入两个关键的参数\n                        \"\\tDim o\",\n                        \"\\tSet o = (New \" + className + \")(a, b)\",\n                        \"\\tSet \" + className + \"Factory = o\",\n                        \"End Function\"\n                    ].join(\"\\r\\n\"))\n                    VBClassPool[body] = className\n                }\n                var ret = window[className + \"Factory\"](accessors, VBMediator) //得到其产品\n                return ret //得到其产品\n            }\n        }\n    }\n\n    /*********************************************************************\n     *          监控数组（与ms-each, ms-repeat配合使用）                     *\n     **********************************************************************/\n\n    function arrayFactory(model) {\n        var array = []\n        array.$id = generateID()\n        array.$model = model //数据模型\n        array.$events = {}\n        array.$events[subscribers] = []\n        array._ = modelFactory({\n            length: model.length\n        })\n        array._.$watch(\"length\", function (a, b) {\n            array.$fire(\"length\", a, b)\n        })\n        for (var i in EventBus) {\n            array[i] = EventBus[i]\n        }\n        avalon.mix(array, arrayPrototype)\n        return array\n    }\n\n    function mutateArray(method, pos, n, index, method2, pos2, n2) {\n        var oldLen = this.length, loop = 2\n        while (--loop) {\n            switch (method) {\n                case \"add\":\n                    /* jshint ignore:start */\n                    var array = this.$model.slice(pos, pos + n).map(function (el) {\n                        if (rcomplexType.test(avalon.type(el))) {\n                            return el.$id ? el : modelFactory(el, 0, el)\n                        } else {\n                            return el\n                        }\n                    })\n                    /* jshint ignore:end */\n                    _splice.apply(this, [pos, 0].concat(array))\n                    this._fire(\"add\", pos, n)\n                    break\n                case \"del\":\n                    var ret = this._splice(pos, n)\n                    this._fire(\"del\", pos, n)\n                    break\n            }\n            if (method2) {\n                method = method2\n                pos = pos2\n                n = n2\n                loop = 2\n                method2 = 0\n            }\n        }\n        this._fire(\"index\", index)\n        if (this.length !== oldLen) {\n            this._.length = this.length\n        }\n        return ret\n    }\n\n    var _splice = ap.splice\n    var arrayPrototype = {\n        _splice: _splice,\n        _fire: function (method, a, b) {\n            fireDependencies(this.$events[subscribers], method, a, b)\n        },\n        size: function () { //取得数组长度，这个函数可以同步视图，length不能\n            return this._.length\n        },\n        pushArray: function (array) {\n            var m = array.length, n = this.length\n            if (m) {\n                ap.push.apply(this.$model, array)\n                mutateArray.call(this, \"add\", n, m, Math.max(0, n - 1))\n            }\n            return  m + n\n        },\n        push: function () {\n            //http://jsperf.com/closure-with-arguments\n            var array = []\n            var i, n = arguments.length\n            for (i = 0; i < n; i++) {\n                array[i] = arguments[i]\n            }\n            return this.pushArray(array)\n        },\n        unshift: function () {\n            var m = arguments.length, n = this.length\n            if (m) {\n                ap.unshift.apply(this.$model, arguments)\n                mutateArray.call(this, \"add\", 0, m, 0)\n            }\n            return  m + n //IE67的unshift不会返回长度\n        },\n        shift: function () {\n            if (this.length) {\n                var el = this.$model.shift()\n                mutateArray.call(this, \"del\", 0, 1, 0)\n                return el //返回被移除的元素\n            }\n        },\n        pop: function () {\n            var n = this.length\n            if (n) {\n                var el = this.$model.pop()\n                mutateArray.call(this, \"del\", n - 1, 1, Math.max(0, n - 2))\n                return el //返回被移除的元素\n            }\n        },\n        splice: function (start) {\n            var m = arguments.length, args = [], change\n            var removed = _splice.apply(this.$model, arguments)\n            if (removed.length) { //如果用户删掉了元素\n                args.push(\"del\", start, removed.length, 0)\n                change = true\n            }\n            if (m > 2) {  //如果用户添加了元素\n                if (change) {\n                    args.splice(3, 1, 0, \"add\", start, m - 2)\n                } else {\n                    args.push(\"add\", start, m - 2, 0)\n                }\n                change = true\n            }\n            if (change) { //返回被移除的元素\n                return mutateArray.apply(this, args)\n            } else {\n                return []\n            }\n        },\n        contains: function (el) { //判定是否包含\n            return this.indexOf(el) !== -1\n        },\n        remove: function (el) { //移除第一个等于给定值的元素\n            return this.removeAt(this.indexOf(el))\n        },\n        removeAt: function (index) { //移除指定索引上的元素\n            if (index >= 0) {\n                this.$model.splice(index, 1)\n                return mutateArray.call(this, \"del\", index, 1, 0)\n            }\n            return  []\n        },\n        clear: function () {\n            this.$model.length = this.length = this._.length = 0 //清空数组\n            this._fire(\"clear\", 0)\n            return this\n        },\n        removeAll: function (all) { //移除N个元素\n            if (Array.isArray(all)) {\n                for (var i = this.length - 1; i >= 0; i--) {\n                    if (all.indexOf(this[i]) !== -1) {\n                        this.removeAt(i)\n                    }\n                }\n            } else if (typeof all === \"function\") {\n                for ( i = this.length - 1; i >= 0; i--) {\n                    var el = this[i]\n                    if (all(el, i)) {\n                        this.removeAt(i)\n                    }\n                }\n            } else {\n                this.clear()\n            }\n        },\n        ensure: function (el) {\n            if (!this.contains(el)) { //只有不存在才push\n                this.push(el)\n            }\n            return this\n        },\n        set: function (index, val) {\n            if (index < this.length && index > -1) {\n                var valueType = avalon.type(val)\n                if (val && val.$model) {\n                    val = val.$model\n                }\n                var target = this[index]\n                if (valueType === \"object\") {\n                    for (var i in val) {\n                        if (target.hasOwnProperty(i)) {\n                            target[i] = val[i]\n                        }\n                    }\n                } else if (valueType === \"array\") {\n                    target.clear().push.apply(target, val)\n                } else if (target !== val) {\n                    this[index] = val\n                    this.$model[index] = val\n                    this._fire(\"set\", index, val)\n                }\n            }\n            return this\n        }\n    }\n//相当于原来bindingExecutors.repeat 的index分支\n    function resetIndex(array, pos) {\n        var last = array.length - 1\n        for (var el; el = array[pos]; pos++) {\n            el.$index = pos\n            el.$first = pos === 0\n            el.$last = pos === last\n        }\n    }\n\n    function sortByIndex(array, indexes) {\n        var map = {};\n        for (var i = 0, n = indexes.length; i < n; i++) {\n            map[i] = array[i] // preserve\n            var j = indexes[i]\n            if (j in map) {\n                array[i] = map[j]\n                delete map[j]\n            } else {\n                array[i] = array[j]\n            }\n        }\n    }\n\n    \"sort,reverse\".replace(rword, function (method) {\n        arrayPrototype[method] = function () {\n            var newArray = this.$model//这是要排序的新数组\n            var oldArray = newArray.concat() //保持原来状态的旧数组\n            var mask = Math.random()\n            var indexes = []\n            var hasSort\n            ap[method].apply(newArray, arguments) //排序\n            for (var i = 0, n = oldArray.length; i < n; i++) {\n                var neo = newArray[i]\n                var old = oldArray[i]\n                if (isEqual(neo, old)) {\n                    indexes.push(i)\n                } else {\n                    var index = oldArray.indexOf(neo)\n                    indexes.push(index)//得到新数组的每个元素在旧数组对应的位置\n                    oldArray[index] = mask    //屏蔽已经找过的元素\n                    hasSort = true\n                }\n            }\n            if (hasSort) {\n                sortByIndex(this, indexes)\n                // sortByIndex(this.$proxy, indexes)\n                this._fire(\"move\", indexes)\n                this._fire(\"index\", 0)\n            }\n            return this\n        }\n    })\n\n\n    /*********************************************************************\n     *                           依赖调度系统                             *\n     **********************************************************************/\n//检测两个对象间的依赖关系\n    var dependencyDetection = (function () {\n        var outerFrames = []\n        var currentFrame\n        return {\n            begin: function (accessorObject) {\n                //accessorObject为一个拥有callback的对象\n                outerFrames.push(currentFrame)\n                currentFrame = accessorObject\n            },\n            end: function () {\n                currentFrame = outerFrames.pop()\n            },\n            collectDependency: function (vmodel, accessor) {\n                if (currentFrame) {\n                    //被dependencyDetection.begin调用\n                    currentFrame.callback(vmodel, accessor);\n                }\n            }\n        };\n    })()\n//将绑定对象注入到其依赖项的订阅数组中\n    var ronduplex = /^(duplex|on)$/\n    avalon.injectBinding = function (data) {\n        var valueFn = data.evaluator\n        if (valueFn) { //如果是求值函数\n            dependencyDetection.begin({\n                callback: function (vmodel, dependency) {\n                    injectDependency(vmodel.$events[dependency._name], data)\n                }\n            })\n            try {\n                var value = ronduplex.test(data.type) ? data : valueFn.apply(0, data.args)\n                if(value === void 0){\n                    delete data.evaluator\n                }\n                if (data.handler) {\n                    data.handler(value, data.element, data)\n                }\n            } catch (e) {\n                log(\"warning:exception throwed in [avalon.injectBinding] \" , e)\n                delete data.evaluator\n                var node = data.element\n                if (node && node.nodeType === 3) {\n                    var parent = node.parentNode\n                    if (kernel.commentInterpolate) {\n                        parent.replaceChild(DOC.createComment(data.value), node)\n                    } else {\n                        node.data = openTag + (data.oneTime ? \"::\" : \"\") + data.value + closeTag\n                    }\n                }\n            } finally {\n                dependencyDetection.end()\n            }\n        }\n    }\n\n//将依赖项(比它高层的访问器或构建视图刷新函数的绑定对象)注入到订阅者数组\n    function injectDependency(list, data) {\n        if (data.oneTime)\n            return\n        if (list && avalon.Array.ensure(list, data) && data.element) {\n            injectDisposeQueue(data, list)\n            if (new Date() - beginTime > 444 ) {\n                rejectDisposeQueue()\n            }\n        }\n    }\n\n//通知依赖于这个访问器的订阅者更新自身\n    function fireDependencies(list) {\n        if (list && list.length) {\n            if (new Date() - beginTime > 444 && typeof list[0] === \"object\") {\n                rejectDisposeQueue()\n            }\n            var args = aslice.call(arguments, 1)\n            for (var i = list.length, fn; fn = list[--i]; ) {\n                var el = fn.element\n                if (el && el.parentNode) {\n                    try {\n                        var valueFn = fn.evaluator\n                        if (fn.$repeat) {\n                            fn.handler.apply(fn, args) //处理监控数组的方法\n                        }else if(\"$repeat\" in fn || !valueFn ){//如果没有eval,先eval\n                            bindingHandlers[fn.type](fn, fn.vmodels)\n                        } else if (fn.type !== \"on\") { //事件绑定只能由用户触发,不能由程序触发\n                            var value = valueFn.apply(0, fn.args || [])\n                            fn.handler(value, el, fn)\n                        }\n                    } catch (e) {\n                        avalon.log(e)\n                    }\n                }\n            }\n        }\n    }\n    /*********************************************************************\n     *                          定时GC回收机制                             *\n     **********************************************************************/\n    var disposeCount = 0\n    var disposeQueue = avalon.$$subscribers = []\n    var beginTime = new Date()\n    var oldInfo = {}\n//var uuid2Node = {}\n    function getUid(elem, makeID) { //IE9+,标准浏览器\n        if (!elem.uuid && !makeID) {\n            elem.uuid = ++disposeCount\n        }\n        return elem.uuid\n    }\n\n//添加到回收列队中\n    function injectDisposeQueue(data, list) {\n        var elem = data.element\n        if (!data.uuid) {\n            if (elem.nodeType !== 1) {\n                data.uuid = data.type + getUid(elem.parentNode)+ \"-\"+ (++disposeCount)\n            } else {\n                data.uuid = data.name + \"-\" + getUid(elem)\n            }\n        }\n        var lists = data.lists || (data.lists = [])\n        avalon.Array.ensure(lists, list)\n        list.$uuid = list.$uuid || generateID()\n        if (!disposeQueue[data.uuid]) {\n            disposeQueue[data.uuid] = 1\n            disposeQueue.push(data)\n        }\n    }\n\n    function rejectDisposeQueue(data) {\n        if (avalon.optimize)\n            return\n        var i = disposeQueue.length\n        var n = i\n        var allTypes = []\n        var iffishTypes = {}\n        var newInfo = {}\n        //对页面上所有绑定对象进行分门别类, 只检测个数发生变化的类型\n        while (data = disposeQueue[--i]) {\n            var type = data.type\n            if (newInfo[type]) {\n                newInfo[type]++\n            } else {\n                newInfo[type] = 1\n                allTypes.push(type)\n            }\n        }\n        var diff = false\n        allTypes.forEach(function (type) {\n            if (oldInfo[type] !== newInfo[type]) {\n                iffishTypes[type] = 1\n                diff = true\n            }\n        })\n        i = n\n        if (diff) {\n            while (data = disposeQueue[--i]) {\n                if (data.element === null) {\n                    disposeQueue.splice(i, 1)\n                    continue\n                }\n                if (iffishTypes[data.type] && shouldDispose(data.element)) { //如果它没有在DOM树\n                    disposeQueue.splice(i, 1)\n                    delete disposeQueue[data.uuid]\n                    //delete uuid2Node[data.element.uuid]\n                    var lists = data.lists\n                    for (var k = 0, list; list = lists[k++]; ) {\n                        avalon.Array.remove(lists, list)\n                        avalon.Array.remove(list, data)\n                    }\n                    disposeData(data)\n                }\n            }\n        }\n        oldInfo = newInfo\n        beginTime = new Date()\n    }\n\n    function disposeData(data) {\n        delete disposeQueue[data.uuid] // 先清除，不然无法回收了\n        data.element = null\n        data.rollback && data.rollback()\n        for (var key in data) {\n            data[key] = null\n        }\n    }\n\n    function shouldDispose(el) {\n        try {//IE下，如果文本节点脱离DOM树，访问parentNode会报错\n            var fireError = el.parentNode.nodeType\n        } catch (e) {\n            return true\n        }\n        if (el.ifRemove) {\n            // 如果节点被放到ifGroup，才移除\n            if (!root.contains(el.ifRemove) && (ifGroup === el.parentNode)) {\n                el.parentNode && el.parentNode.removeChild(el)\n                return true\n            }\n        }\n        return el.msRetain ? 0 : (el.nodeType === 1 ? !root.contains(el) : !avalon.contains(root, el))\n    }\n\n    /************************************************************************\n     *            HTML处理(parseHTML, innerHTML, clearHTML)                  *\n     ************************************************************************/\n// We have to close these tags to support XHTML\n    var tagHooks = {\n        area: [1, \"<map>\", \"</map>\"],\n        param: [1, \"<object>\", \"</object>\"],\n        col: [2, \"<table><colgroup>\", \"</colgroup></table>\"],\n        legend: [1, \"<fieldset>\", \"</fieldset>\"],\n        option: [1, \"<select multiple='multiple'>\", \"</select>\"],\n        thead: [1, \"<table>\", \"</table>\"],\n        tr: [2, \"<table>\", \"</table>\"],\n        td: [3, \"<table><tr>\", \"</tr></table>\"],\n        g: [1, '<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\">', '</svg>'],\n        //IE6-8在用innerHTML生成节点时，不能直接创建no-scope元素与HTML5的新标签\n        _default: W3C ? [0, \"\", \"\"] : [1, \"X<div>\", \"</div>\"] //div可以不用闭合\n    }\n    tagHooks.th = tagHooks.td\n    tagHooks.optgroup = tagHooks.option\n    tagHooks.tbody = tagHooks.tfoot = tagHooks.colgroup = tagHooks.caption = tagHooks.thead\n    String(\"circle,defs,ellipse,image,line,path,polygon,polyline,rect,symbol,text,use\").replace(rword, function (tag) {\n        tagHooks[tag] = tagHooks.g //处理SVG\n    })\n    var rtagName = /<([\\w:]+)/  //取得其tagName\n    var rxhtml = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig\n    var rcreate = W3C ? /[^\\d\\D]/ : /(<(?:script|link|style|meta|noscript))/ig\n    var scriptTypes = oneObject([\"\", \"text/javascript\", \"text/ecmascript\", \"application/ecmascript\", \"application/javascript\"])\n    var rnest = /<(?:tb|td|tf|th|tr|col|opt|leg|cap|area)/ //需要处理套嵌关系的标签\n    var script = DOC.createElement(\"script\")\n    var rhtml = /<|&#?\\w+;/\n    avalon.parseHTML = function (html) {\n        var fragment = avalonFragment.cloneNode(false)\n        if (typeof html !== \"string\") {\n            return fragment\n        }\n        if (!rhtml.test(html)) {\n            fragment.appendChild(DOC.createTextNode(html))\n            return fragment\n        }\n        html = html.replace(rxhtml, \"<$1></$2>\").trim()\n        var tag = (rtagName.exec(html) || [\"\", \"\"])[1].toLowerCase(),\n        //取得其标签名\n            wrap = tagHooks[tag] || tagHooks._default,\n            wrapper = cinerator,\n            firstChild, neo\n        if (!W3C) { //fix IE\n            html = html.replace(rcreate, \"<br class=msNoScope>$1\") //在link style script等标签之前添加一个补丁\n        }\n        wrapper.innerHTML = wrap[1] + html + wrap[2]\n        var els = wrapper.getElementsByTagName(\"script\")\n        if (els.length) { //使用innerHTML生成的script节点不会发出请求与执行text属性\n            for (var i = 0, el; el = els[i++]; ) {\n                if (scriptTypes[el.type]) {\n                    //以偷龙转凤方式恢复执行脚本功能\n                    neo = script.cloneNode(false) //FF不能省略参数\n                    ap.forEach.call(el.attributes, function (attr) {\n                        if (attr && attr.specified) {\n                            neo[attr.name] = attr.value //复制其属性\n                            neo.setAttribute(attr.name, attr.value)\n                        }\n                    })  // jshint ignore:line\n                    neo.text = el.text\n                    el.parentNode.replaceChild(neo, el) //替换节点\n                }\n            }\n        }\n        if (!W3C) { //fix IE\n            var target = wrap[1] === \"X<div>\" ? wrapper.lastChild.firstChild : wrapper.lastChild\n            if (target && target.tagName === \"TABLE\" && tag !== \"tbody\") {\n                //IE6-7处理 <thead> --> <thead>,<tbody>\n                //<tfoot> --> <tfoot>,<tbody>\n                //<table> --> <table><tbody></table>\n                for (els = target.childNodes, i = 0; el = els[i++]; ) {\n                    if (el.tagName === \"TBODY\" && !el.innerHTML) {\n                        target.removeChild(el)\n                        break\n                    }\n                }\n            }\n            els = wrapper.getElementsByTagName(\"br\")\n            var n = els.length\n            while (el = els[--n]) {\n                if (el.className === \"msNoScope\") {\n                    el.parentNode.removeChild(el)\n                }\n            }\n            for (els = wrapper.all, i = 0; el = els[i++]; ) { //fix VML\n                if (isVML(el)) {\n                    fixVML(el)\n                }\n            }\n        }\n        //移除我们为了符合套嵌关系而添加的标签\n        for (i = wrap[0]; i--; wrapper = wrapper.lastChild) {\n        }\n        while (firstChild = wrapper.firstChild) { // 将wrapper上的节点转移到文档碎片上！\n            fragment.appendChild(firstChild)\n        }\n        return fragment\n    }\n\n    function isVML(src) {\n        var nodeName = src.nodeName\n        return nodeName.toLowerCase() === nodeName && src.scopeName && src.outerText === \"\"\n    }\n\n    function fixVML(node) {\n        if (node.currentStyle.behavior !== \"url(#default#VML)\") {\n            node.style.behavior = \"url(#default#VML)\"\n            node.style.display = \"inline-block\"\n            node.style.zoom = 1 //hasLayout\n        }\n    }\n    avalon.innerHTML = function (node, html) {\n        if (!W3C && (!rcreate.test(html) && !rnest.test(html))) {\n            try {\n                node.innerHTML = html\n                return\n            } catch (e) {\n            }\n        }\n        var a = this.parseHTML(html)\n        this.clearHTML(node).appendChild(a)\n    }\n    avalon.clearHTML = function (node) {\n        node.textContent = \"\"\n        while (node.firstChild) {\n            node.removeChild(node.firstChild)\n        }\n        return node\n    }\n\n    /*********************************************************************\n     *                  avalon的原型方法定义区                            *\n     **********************************************************************/\n\n    function hyphen(target) {\n        //转换为连字符线风格\n        return target.replace(/([a-z\\d])([A-Z]+)/g, \"$1-$2\").toLowerCase()\n    }\n\n    function camelize(target) {\n        //提前判断，提高getStyle等的效率\n        if (!target || target.indexOf(\"-\") < 0 && target.indexOf(\"_\") < 0) {\n            return target\n        }\n        //转换为驼峰风格\n        return target.replace(/[-_][^-_]/g, function (match) {\n            return match.charAt(1).toUpperCase()\n        })\n    }\n\n    var fakeClassListMethods = {\n        _toString: function () {\n            var node = this.node\n            var cls = node.className\n            var str = typeof cls === \"string\" ? cls : cls.baseVal\n            return str.split(/\\s+/).join(\" \")\n        },\n        _contains: function (cls) {\n            return (\" \" + this + \" \").indexOf(\" \" + cls + \" \") > -1\n        },\n        _add: function (cls) {\n            if (!this.contains(cls)) {\n                this._set(this + \" \" + cls)\n            }\n        },\n        _remove: function (cls) {\n            this._set((\" \" + this + \" \").replace(\" \" + cls + \" \", \" \"))\n        },\n        __set: function (cls) {\n            cls = cls.trim()\n            var node = this.node\n            if (rsvg.test(node)) {\n                //SVG元素的className是一个对象 SVGAnimatedString { baseVal=\"\", animVal=\"\"}，只能通过set/getAttribute操作\n                node.setAttribute(\"class\", cls)\n            } else {\n                node.className = cls\n            }\n        } //toggle存在版本差异，因此不使用它\n    }\n\n    function fakeClassList(node) {\n        if (!(\"classList\" in node)) {\n            node.classList = {\n                node: node\n            }\n            for (var k in fakeClassListMethods) {\n                node.classList[k.slice(1)] = fakeClassListMethods[k]\n            }\n        }\n        return node.classList\n    }\n\n\n    \"add,remove\".replace(rword, function (method) {\n        avalon.fn[method + \"Class\"] = function (cls) {\n            var el = this[0]\n            //https://developer.mozilla.org/zh-CN/docs/Mozilla/Firefox/Releases/26\n            if (cls && typeof cls === \"string\" && el && el.nodeType === 1) {\n                cls.replace(/\\S+/g, function (c) {\n                    fakeClassList(el)[method](c)\n                })\n            }\n            return this\n        }\n    })\n    avalon.fn.mix({\n        hasClass: function (cls) {\n            var el = this[0] || {}\n            return el.nodeType === 1 && fakeClassList(el).contains(cls)\n        },\n        toggleClass: function (value, stateVal) {\n            var className, i = 0\n            var classNames = String(value).split(/\\s+/)\n            var isBool = typeof stateVal === \"boolean\"\n            while ((className = classNames[i++])) {\n                var state = isBool ? stateVal : !this.hasClass(className)\n                this[state ? \"addClass\" : \"removeClass\"](className)\n            }\n            return this\n        },\n        attr: function (name, value) {\n            if (arguments.length === 2) {\n                this[0].setAttribute(name, value)\n                return this\n            } else {\n                return this[0].getAttribute(name)\n            }\n        },\n        data: function (name, value) {\n            name = \"data-\" + hyphen(name || \"\")\n            switch (arguments.length) {\n                case 2:\n                    this.attr(name, value)\n                    return this\n                case 1:\n                    var val = this.attr(name)\n                    return parseData(val)\n                case 0:\n                    var ret = {}\n                    ap.forEach.call(this[0].attributes, function (attr) {\n                        if (attr) {\n                            name = attr.name\n                            if (!name.indexOf(\"data-\")) {\n                                name = camelize(name.slice(5))\n                                ret[name] = parseData(attr.value)\n                            }\n                        }\n                    })\n                    return ret\n            }\n        },\n        removeData: function (name) {\n            name = \"data-\" + hyphen(name)\n            this[0].removeAttribute(name)\n            return this\n        },\n        css: function (name, value) {\n            if (avalon.isPlainObject(name)) {\n                for (var i in name) {\n                    avalon.css(this, i, name[i])\n                }\n            } else {\n                var ret = avalon.css(this, name, value)\n            }\n            return ret !== void 0 ? ret : this\n        },\n        position: function () {\n            var offsetParent, offset,\n                elem = this[0],\n                parentOffset = {\n                    top: 0,\n                    left: 0\n                }\n            if (!elem) {\n                return\n            }\n            if (this.css(\"position\") === \"fixed\") {\n                offset = elem.getBoundingClientRect()\n            } else {\n                offsetParent = this.offsetParent() //得到真正的offsetParent\n                offset = this.offset() // 得到正确的offsetParent\n                if (offsetParent[0].tagName !== \"HTML\") {\n                    parentOffset = offsetParent.offset()\n                }\n                parentOffset.top += avalon.css(offsetParent[0], \"borderTopWidth\", true)\n                parentOffset.left += avalon.css(offsetParent[0], \"borderLeftWidth\", true)\n\n                // Subtract offsetParent scroll positions\n                parentOffset.top -= offsetParent.scrollTop()\n                parentOffset.left -= offsetParent.scrollLeft()\n            }\n            return {\n                top: offset.top - parentOffset.top - avalon.css(elem, \"marginTop\", true),\n                left: offset.left - parentOffset.left - avalon.css(elem, \"marginLeft\", true)\n            }\n        },\n        offsetParent: function () {\n            var offsetParent = this[0].offsetParent\n            while (offsetParent && avalon.css(offsetParent, \"position\") === \"static\") {\n                offsetParent = offsetParent.offsetParent;\n            }\n            return avalon(offsetParent || root)\n        },\n        bind: function (type, fn, phase) {\n            if (this[0]) { //此方法不会链\n                return avalon.bind(this[0], type, fn, phase)\n            }\n        },\n        unbind: function (type, fn, phase) {\n            if (this[0]) {\n                avalon.unbind(this[0], type, fn, phase)\n            }\n            return this\n        },\n        val: function (value) {\n            var node = this[0]\n            if (node && node.nodeType === 1) {\n                var get = arguments.length === 0\n                var access = get ? \":get\" : \":set\"\n                var fn = valHooks[getValType(node) + access]\n                if (fn) {\n                    var val = fn(node, value)\n                } else if (get) {\n                    return (node.value || \"\").replace(/\\r/g, \"\")\n                } else {\n                    node.value = value\n                }\n            }\n            return get ? val : this\n        }\n    })\n\n    function parseData(data) {\n        try {\n            if (typeof data === \"object\")\n                return data\n            data = data === \"true\" ? true :\n                data === \"false\" ? false :\n                    data === \"null\" ? null : +data + \"\" === data ? +data : rbrace.test(data) ? avalon.parseJSON(data) : data\n        } catch (e) {\n        }\n        return data\n    }\n    var rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n        rvalidchars = /^[\\],:{}\\s]*$/,\n        rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n        rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n        rvalidtokens = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g\n    avalon.parseJSON = window.JSON ? JSON.parse : function (data) {\n        if (typeof data === \"string\") {\n            data = data.trim();\n            if (data) {\n                if (rvalidchars.test(data.replace(rvalidescape, \"@\")\n                        .replace(rvalidtokens, \"]\")\n                        .replace(rvalidbraces, \"\"))) {\n                    return (new Function(\"return \" + data))() // jshint ignore:line\n                }\n            }\n            avalon.error(\"Invalid JSON: \" + data)\n        }\n        return data\n    }\n    avalon.fireDom = function (elem, type, opts) {\n        if (DOC.createEvent) {\n            var hackEvent = DOC.createEvent(\"Events\");\n            hackEvent.initEvent(type, true, true)\n            avalon.mix(hackEvent, opts)\n            elem.dispatchEvent(hackEvent)\n        } else {\n            try {\n                hackEvent = DOC.createEventObject()\n                avalon.mix(hackEvent, opts)\n                elem.fireEvent(\"on\" + type, hackEvent)\n            } catch (e) {//IE6-8触发事件必须保证在DOM树中,否则报\"SCRIPT16389: 未指明的错误\"\n            }\n        }\n    }\n\n//生成avalon.fn.scrollLeft, avalon.fn.scrollTop方法\n    avalon.each({\n        scrollLeft: \"pageXOffset\",\n        scrollTop: \"pageYOffset\"\n    }, function (method, prop) {\n        avalon.fn[method] = function (val) {\n            var node = this[0] || {}, win = getWindow(node),\n                top = method === \"scrollTop\"\n            if (!arguments.length) {\n                return win ? (prop in win) ? win[prop] : root[method] : node[method]\n            } else {\n                if (win) {\n                    win.scrollTo(!top ? val : avalon(win).scrollLeft(), top ? val : avalon(win).scrollTop())\n                } else {\n                    node[method] = val\n                }\n            }\n        }\n    })\n\n    function getWindow(node) {\n        return node.window && node.document ? node : node.nodeType === 9 ? node.defaultView || node.parentWindow : false;\n    }\n//=============================css相关=======================\n    var cssHooks = avalon.cssHooks = {}\n    var prefixes = [\"\", \"-webkit-\", \"-o-\", \"-moz-\", \"-ms-\"]\n    var cssMap = {\n        \"float\": W3C ? \"cssFloat\" : \"styleFloat\"\n    }\n    avalon.cssNumber = oneObject(\"animationIterationCount,columnCount,order,flex,flexGrow,flexShrink,fillOpacity,fontWeight,lineHeight,opacity,orphans,widows,zIndex,zoom\")\n\n    avalon.cssName = function (name, host, camelCase) {\n        if (cssMap[name]) {\n            return cssMap[name]\n        }\n        host = host || root.style\n        for (var i = 0, n = prefixes.length; i < n; i++) {\n            camelCase = camelize(prefixes[i] + name)\n            if (camelCase in host) {\n                return (cssMap[name] = camelCase)\n            }\n        }\n        return null\n    }\n    cssHooks[\"@:set\"] = function (node, name, value) {\n        try { //node.style.width = NaN;node.style.width = \"xxxxxxx\";node.style.width = undefine 在旧式IE下会抛异常\n            node.style[name] = value\n        } catch (e) {\n        }\n    }\n    if (window.getComputedStyle) {\n        cssHooks[\"@:get\"] = function (node, name) {\n            if (!node || !node.style) {\n                throw new Error(\"getComputedStyle要求传入一个节点 \" + node)\n            }\n            var ret, styles = getComputedStyle(node, null)\n            if (styles) {\n                ret = name === \"filter\" ? styles.getPropertyValue(name) : styles[name]\n                if (ret === \"\") {\n                    ret = node.style[name] //其他浏览器需要我们手动取内联样式\n                }\n            }\n            return ret\n        }\n        cssHooks[\"opacity:get\"] = function (node) {\n            var ret = cssHooks[\"@:get\"](node, \"opacity\")\n            return ret === \"\" ? \"1\" : ret\n        }\n    } else {\n        var rnumnonpx = /^-?(?:\\d*\\.)?\\d+(?!px)[^\\d\\s]+$/i\n        var rposition = /^(top|right|bottom|left)$/\n        var ralpha = /alpha\\([^)]*\\)/i\n        var ie8 = !!window.XDomainRequest\n        var salpha = \"DXImageTransform.Microsoft.Alpha\"\n        var border = {\n            thin: ie8 ? '1px' : '2px',\n            medium: ie8 ? '3px' : '4px',\n            thick: ie8 ? '5px' : '6px'\n        }\n        cssHooks[\"@:get\"] = function (node, name) {\n            //取得精确值，不过它有可能是带em,pc,mm,pt,%等单位\n            var currentStyle = node.currentStyle\n            var ret = currentStyle[name]\n            if ((rnumnonpx.test(ret) && !rposition.test(ret))) {\n                //①，保存原有的style.left, runtimeStyle.left,\n                var style = node.style,\n                    left = style.left,\n                    rsLeft = node.runtimeStyle.left\n                //②由于③处的style.left = xxx会影响到currentStyle.left，\n                //因此把它currentStyle.left放到runtimeStyle.left，\n                //runtimeStyle.left拥有最高优先级，不会style.left影响\n                node.runtimeStyle.left = currentStyle.left\n                //③将精确值赋给到style.left，然后通过IE的另一个私有属性 style.pixelLeft\n                //得到单位为px的结果；fontSize的分支见http://bugs.jquery.com/ticket/760\n                style.left = name === 'fontSize' ? '1em' : (ret || 0)\n                ret = style.pixelLeft + \"px\"\n                //④还原 style.left，runtimeStyle.left\n                style.left = left\n                node.runtimeStyle.left = rsLeft\n            }\n            if (ret === \"medium\") {\n                name = name.replace(\"Width\", \"Style\")\n                //border width 默认值为medium，即使其为0\"\n                if (currentStyle[name] === \"none\") {\n                    ret = \"0px\"\n                }\n            }\n            return ret === \"\" ? \"auto\" : border[ret] || ret\n        }\n        cssHooks[\"opacity:set\"] = function (node, name, value) {\n            var style = node.style\n            var opacity = isFinite(value) && value <= 1 ? \"alpha(opacity=\" + value * 100 + \")\" : \"\"\n            var filter = style.filter || \"\";\n            style.zoom = 1\n            //不能使用以下方式设置透明度\n            //node.filters.alpha.opacity = value * 100\n            style.filter = (ralpha.test(filter) ?\n                filter.replace(ralpha, opacity) :\n            filter + \" \" + opacity).trim()\n            if (!style.filter) {\n                style.removeAttribute(\"filter\")\n            }\n        }\n        cssHooks[\"opacity:get\"] = function (node) {\n            //这是最快的获取IE透明值的方式，不需要动用正则了！\n            var alpha = node.filters.alpha || node.filters[salpha],\n                op = alpha && alpha.enabled ? alpha.opacity : 100\n            return (op / 100) + \"\" //确保返回的是字符串\n        }\n    }\n\n    \"top,left\".replace(rword, function (name) {\n        cssHooks[name + \":get\"] = function (node) {\n            var computed = cssHooks[\"@:get\"](node, name)\n            return /px$/.test(computed) ? computed :\n            avalon(node).position()[name] + \"px\"\n        }\n    })\n\n    var cssShow = {\n        position: \"absolute\",\n        visibility: \"hidden\",\n        display: \"block\"\n    }\n\n    var rdisplayswap = /^(none|table(?!-c[ea]).+)/\n\n    function showHidden(node, array) {\n        //http://www.cnblogs.com/rubylouvre/archive/2012/10/27/2742529.html\n        if (node.offsetWidth <= 0) { //opera.offsetWidth可能小于0\n            if (rdisplayswap.test(cssHooks[\"@:get\"](node, \"display\"))) {\n                var obj = {\n                    node: node\n                }\n                for (var name in cssShow) {\n                    obj[name] = node.style[name]\n                    node.style[name] = cssShow[name]\n                }\n                array.push(obj)\n            }\n            var parent = node.parentNode\n            if (parent && parent.nodeType === 1) {\n                showHidden(parent, array)\n            }\n        }\n    }\n    \"Width,Height\".replace(rword, function (name) { //fix 481\n        var method = name.toLowerCase(),\n            clientProp = \"client\" + name,\n            scrollProp = \"scroll\" + name,\n            offsetProp = \"offset\" + name\n        cssHooks[method + \":get\"] = function (node, which, override) {\n            var boxSizing = -4\n            if (typeof override === \"number\") {\n                boxSizing = override\n            }\n            which = name === \"Width\" ? [\"Left\", \"Right\"] : [\"Top\", \"Bottom\"]\n            var ret = node[offsetProp] // border-box 0\n            if (boxSizing === 2) { // margin-box 2\n                return ret + avalon.css(node, \"margin\" + which[0], true) + avalon.css(node, \"margin\" + which[1], true)\n            }\n            if (boxSizing < 0) { // padding-box  -2\n                ret = ret - avalon.css(node, \"border\" + which[0] + \"Width\", true) - avalon.css(node, \"border\" + which[1] + \"Width\", true)\n            }\n            if (boxSizing === -4) { // content-box -4\n                ret = ret - avalon.css(node, \"padding\" + which[0], true) - avalon.css(node, \"padding\" + which[1], true)\n            }\n            return ret\n        }\n        cssHooks[method + \"&get\"] = function (node) {\n            var hidden = [];\n            showHidden(node, hidden);\n            var val = cssHooks[method + \":get\"](node)\n            for (var i = 0, obj; obj = hidden[i++]; ) {\n                node = obj.node\n                for (var n in obj) {\n                    if (typeof obj[n] === \"string\") {\n                        node.style[n] = obj[n]\n                    }\n                }\n            }\n            return val;\n        }\n        avalon.fn[method] = function (value) { //会忽视其display\n            var node = this[0]\n            if (arguments.length === 0) {\n                if (node.setTimeout) { //取得窗口尺寸,IE9后可以用node.innerWidth /innerHeight代替\n                    return node[\"inner\" + name] || node.document.documentElement[clientProp] ||\n                        node.document.body[clientProp]//IE6下前两个分别为undefine,0\n                }\n                if (node.nodeType === 9) { //取得页面尺寸\n                    var doc = node.documentElement\n                    //FF chrome    html.scrollHeight< body.scrollHeight\n                    //IE 标准模式 : html.scrollHeight> body.scrollHeight\n                    //IE 怪异模式 : html.scrollHeight 最大等于可视窗口多一点？\n                    return Math.max(node.body[scrollProp], doc[scrollProp], node.body[offsetProp], doc[offsetProp], doc[clientProp])\n                }\n                return cssHooks[method + \"&get\"](node)\n            } else {\n                return this.css(method, value)\n            }\n        }\n        avalon.fn[\"inner\" + name] = function () {\n            return cssHooks[method + \":get\"](this[0], void 0, -2)\n        }\n        avalon.fn[\"outer\" + name] = function (includeMargin) {\n            return cssHooks[method + \":get\"](this[0], void 0, includeMargin === true ? 2 : 0)\n        }\n    })\n    avalon.fn.offset = function () { //取得距离页面左右角的坐标\n        var node = this[0],\n            box = {\n                left: 0,\n                top: 0\n            }\n        if (!node || !node.tagName || !node.ownerDocument) {\n            return box\n        }\n        var doc = node.ownerDocument,\n            body = doc.body,\n            root = doc.documentElement,\n            win = doc.defaultView || doc.parentWindow\n        if (!avalon.contains(root, node)) {\n            return box\n        }\n        //http://hkom.blog1.fc2.com/?mode=m&no=750 body的偏移量是不包含margin的\n        //我们可以通过getBoundingClientRect来获得元素相对于client的rect.\n        //http://msdn.microsoft.com/en-us/library/ms536433.aspx\n        if (node.getBoundingClientRect) {\n            box = node.getBoundingClientRect() // BlackBerry 5, iOS 3 (original iPhone)\n        }\n        //chrome/IE6: body.scrollTop, firefox/other: root.scrollTop\n        var clientTop = root.clientTop || body.clientTop,\n            clientLeft = root.clientLeft || body.clientLeft,\n            scrollTop = Math.max(win.pageYOffset || 0, root.scrollTop, body.scrollTop),\n            scrollLeft = Math.max(win.pageXOffset || 0, root.scrollLeft, body.scrollLeft)\n        // 把滚动距离加到left,top中去。\n        // IE一些版本中会自动为HTML元素加上2px的border，我们需要去掉它\n        // http://msdn.microsoft.com/en-us/library/ms533564(VS.85).aspx\n        return {\n            top: box.top + scrollTop - clientTop,\n            left: box.left + scrollLeft - clientLeft\n        }\n    }\n\n//==================================val相关============================\n\n    function getValType(elem) {\n        var ret = elem.tagName.toLowerCase()\n        return ret === \"input\" && /checkbox|radio/.test(elem.type) ? \"checked\" : ret\n    }\n    var roption = /^<option(?:\\s+\\w+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s>]+))?)*\\s+value[\\s=]/i\n    var valHooks = {\n        \"option:get\": IEVersion ? function (node) {\n            //在IE11及W3C，如果没有指定value，那么node.value默认为node.text（存在trim作），但IE9-10则是取innerHTML(没trim操作)\n            //specified并不可靠，因此通过分析outerHTML判定用户有没有显示定义value\n            return roption.test(node.outerHTML) ? node.value : node.text.trim()\n        } : function (node) {\n            return node.value\n        },\n        \"select:get\": function (node, value) {\n            var option, options = node.options,\n                index = node.selectedIndex,\n                getter = valHooks[\"option:get\"],\n                one = node.type === \"select-one\" || index < 0,\n                values = one ? null : [],\n                max = one ? index + 1 : options.length,\n                i = index < 0 ? max : one ? index : 0\n            for (; i < max; i++) {\n                option = options[i]\n                //旧式IE在reset后不会改变selected，需要改用i === index判定\n                //我们过滤所有disabled的option元素，但在safari5下，如果设置select为disable，那么其所有孩子都disable\n                //因此当一个元素为disable，需要检测其是否显式设置了disable及其父节点的disable情况\n                if ((option.selected || i === index) && !option.disabled) {\n                    value = getter(option)\n                    if (one) {\n                        return value\n                    }\n                    //收集所有selected值组成数组返回\n                    values.push(value)\n                }\n            }\n            return values\n        },\n        \"select:set\": function (node, values, optionSet) {\n            values = [].concat(values) //强制转换为数组\n            var getter = valHooks[\"option:get\"]\n            for (var i = 0, el; el = node.options[i++]; ) {\n                if ((el.selected = values.indexOf(getter(el)) > -1)) {\n                    optionSet = true\n                }\n            }\n            if (!optionSet) {\n                node.selectedIndex = -1\n            }\n        }\n    }\n\n    /*********************************************************************\n     *                          编译系统                                  *\n     **********************************************************************/\n    var meta = {\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"': '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    }\n    var quote = window.JSON && JSON.stringify || function(str) {\n            return '\"' + str.replace(/[\\\\\\\"\\x00-\\x1f]/g, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                    '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"'\n        }\n\n    var keywords = [\n        \"break,case,catch,continue,debugger,default,delete,do,else,false\",\n        \"finally,for,function,if,in,instanceof,new,null,return,switch,this\",\n        \"throw,true,try,typeof,var,void,while,with\", /* 关键字*/\n        \"abstract,boolean,byte,char,class,const,double,enum,export,extends\",\n        \"final,float,goto,implements,import,int,interface,long,native\",\n        \"package,private,protected,public,short,static,super,synchronized\",\n        \"throws,transient,volatile\", /*保留字*/\n        \"arguments,let,yield,undefined\" /* ECMA 5 - use strict*/].join(\",\")\n    var rrexpstr = /\\/\\*[\\w\\W]*?\\*\\/|\\/\\/[^\\n]*\\n|\\/\\/[^\\n]*$|\"(?:[^\"\\\\]|\\\\[\\w\\W])*\"|'(?:[^'\\\\]|\\\\[\\w\\W])*'|[\\s\\t\\n]*\\.[\\s\\t\\n]*[$\\w\\.]+/g\n    var rsplit = /[^\\w$]+/g\n    var rkeywords = new RegExp([\"\\\\b\" + keywords.replace(/,/g, '\\\\b|\\\\b') + \"\\\\b\"].join('|'), 'g')\n    var rnumber = /\\b\\d[^,]*/g\n    var rcomma = /^,+|,+$/g\n    var variablePool = new Cache(512)\n    var getVariables = function (code) {\n        var key = \",\" + code.trim()\n        var ret = variablePool.get(key)\n        if (ret) {\n            return ret\n        }\n        var match = code\n            .replace(rrexpstr, \"\")\n            .replace(rsplit, \",\")\n            .replace(rkeywords, \"\")\n            .replace(rnumber, \"\")\n            .replace(rcomma, \"\")\n            .split(/^$|,+/)\n        return variablePool.put(key, uniqSet(match))\n    }\n    /*添加赋值语句*/\n\n    function addAssign(vars, scope, name, data) {\n        var ret = [],\n            prefix = \" = \" + name + \".\"\n        for (var i = vars.length, prop; prop = vars[--i]; ) {\n            if (scope.hasOwnProperty(prop)) {\n                ret.push(prop + prefix + prop)\n                data.vars.push(prop)\n                if (data.type === \"duplex\") {\n                    vars.get = name + \".\" + prop\n                }\n                vars.splice(i, 1)\n            }\n        }\n        return ret\n    }\n\n    function uniqSet(array) {\n        var ret = [],\n            unique = {}\n        for (var i = 0; i < array.length; i++) {\n            var el = array[i]\n            var id = el && typeof el.$id === \"string\" ? el.$id : el\n            if (!unique[id]) {\n                unique[id] = ret.push(el)\n            }\n        }\n        return ret\n    }\n//缓存求值函数，以便多次利用\n    var evaluatorPool = new Cache(128)\n//取得求值函数及其传参\n    var rduplex = /\\w\\[.*\\]|\\w\\.\\w/\n    var rproxy = /(\\$proxy\\$[a-z]+)\\d+$/\n    var rthimRightParentheses = /\\)\\s*$/\n    var rthimOtherParentheses = /\\)\\s*\\|/g\n    var rquoteFilterName = /\\|\\s*([$\\w]+)/g\n    var rpatchBracket = /\"\\s*\\[\"/g\n    var rthimLeftParentheses = /\"\\s*\\(/g\n    function parseFilter(val, filters) {\n        filters = filters\n            .replace(rthimRightParentheses, \"\")//处理最后的小括号\n            .replace(rthimOtherParentheses, function () {//处理其他小括号\n                return \"],|\"\n            })\n            .replace(rquoteFilterName, function (a, b) { //处理|及它后面的过滤器的名字\n                return \"[\" + quote(b)\n            })\n            .replace(rpatchBracket, function () {\n                return '\"],[\"'\n            })\n            .replace(rthimLeftParentheses, function () {\n                return '\",'\n            }) + \"]\"\n        return  \"return this.filters.$filter(\" + val + \", \" + filters + \")\"\n    }\n\n    function parseExpr(code, scopes, data) {\n        var dataType = data.type\n        var filters = data.filters || \"\"\n        var exprId = scopes.map(function (el) {\n                return String(el.$id).replace(rproxy, \"$1\")\n            }) + code + dataType + filters\n        var vars = getVariables(code).concat(),\n            assigns = [],\n            names = [],\n            args = [],\n            prefix = \"\"\n        //args 是一个对象数组， names 是将要生成的求值函数的参数\n        scopes = uniqSet(scopes)\n        data.vars = []\n        for (var i = 0, sn = scopes.length; i < sn; i++) {\n            if (vars.length) {\n                var name = \"vm\" + expose + \"_\" + i\n                names.push(name)\n                args.push(scopes[i])\n                assigns.push.apply(assigns, addAssign(vars, scopes[i], name, data))\n            }\n        }\n        if (!assigns.length && dataType === \"duplex\") {\n            return\n        }\n        if (dataType !== \"duplex\" && (code.indexOf(\"||\") > -1 || code.indexOf(\"&&\") > -1)) {\n            //https://github.com/RubyLouvre/avalon/issues/583\n            data.vars.forEach(function (v) {\n                var reg = new RegExp(\"\\\\b\" + v + \"(?:\\\\.\\\\w+|\\\\[\\\\w+\\\\])+\", \"ig\")\n                code = code.replace(reg, function (_, cap) {\n                    var c = _.charAt(v.length)\n                    //var r = IEVersion ? code.slice(arguments[1] + _.length) : RegExp.rightContext\n                    //https://github.com/RubyLouvre/avalon/issues/966\n                    var r = code.slice(cap + _.length)\n                    var method = /^\\s*\\(/.test(r)\n                    if (c === \".\" || c === \"[\" || method) {//比如v为aa,我们只匹配aa.bb,aa[cc],不匹配aaa.xxx\n                        var name = \"var\" + String(Math.random()).replace(/^0\\./, \"\")\n                        if (method) {//array.size()\n                            var array = _.split(\".\")\n                            if (array.length > 2) {\n                                var last = array.pop()\n                                assigns.push(name + \" = \" + array.join(\".\"))\n                                return name + \".\" + last\n                            } else {\n                                return _\n                            }\n                        }\n                        assigns.push(name + \" = \" + _)\n                        return name\n                    } else {\n                        return _\n                    }\n                })\n            })\n        }\n        //---------------args----------------\n        data.args = args\n        //---------------cache----------------\n        delete data.vars\n        var fn = evaluatorPool.get(exprId) //直接从缓存，免得重复生成\n        if (fn) {\n            data.evaluator = fn\n            return\n        }\n        prefix = assigns.join(\", \")\n        if (prefix) {\n            prefix = \"var \" + prefix\n        }\n        if (/\\S/.test(filters)) { //文本绑定，双工绑定才有过滤器\n            if (!/text|html/.test(data.type)) {\n                throw Error(\"ms-\" + data.type + \"不支持过滤器\")\n            }\n            code = \"\\nvar ret\" + expose + \" = \" + code + \";\\r\\n\"\n            code += parseFilter(\"ret\" + expose, filters)\n            try {\n                fn = Function.apply(noop, names.concat(\"'use strict';\\n\" + prefix + code))\n                data.evaluator = evaluatorPool.put(exprId, function() {\n                    return fn.apply(avalon, arguments)//确保可以在编译代码中使用this获取avalon对象\n                })\n            } catch (e) {\n                log(\"debug: parse error,\" + e.message)\n            }\n            vars = assigns = names = null //释放内存\n            return\n        } else if (dataType === \"duplex\") { //双工绑定\n            var _body = \"'use strict';\\nreturn function(vvv){\\n\\t\" +\n                prefix +\n                \";\\n\\tif(!arguments.length){\\n\\t\\treturn \" +\n                code +\n                \"\\n\\t}\\n\\t\" + (!rduplex.test(code) ? vars.get : code) +\n                \"= vvv;\\n} \"\n            try {\n                fn = Function.apply(noop, names.concat(_body))\n                data.evaluator = evaluatorPool.put(exprId, fn)\n            } catch (e) {\n                log(\"debug: parse error,\" + e.message)\n            }\n            vars = assigns = names = null //释放内存\n            return\n        } else if (dataType === \"on\") { //事件绑定\n            if (code.indexOf(\"(\") === -1) {\n                code += \".call(this, $event)\"\n            } else {\n                code = code.replace(\"(\", \".call(this,\")\n            }\n            names.push(\"$event\")\n            code = \"\\nreturn \" + code + \";\" //IE全家 Function(\"return \")出错，需要Function(\"return ;\")\n            var lastIndex = code.lastIndexOf(\"\\nreturn\")\n            var header = code.slice(0, lastIndex)\n            var footer = code.slice(lastIndex)\n            code = header + \"\\n\" + footer\n        } else { //其他绑定\n            code = \"\\nreturn \" + code + \";\" //IE全家 Function(\"return \")出错，需要Function(\"return ;\")\n        }\n        try {\n            fn = Function.apply(noop, names.concat(\"'use strict';\\n\" + prefix + code))\n            data.evaluator = evaluatorPool.put(exprId, fn)\n        } catch (e) {\n            log(\"debug: parse error,\" + e.message)\n        }\n        vars = assigns = names = null //释放内存\n    }\n    function stringifyExpr(code) {\n        var hasExpr = rexpr.test(code) //比如ms-class=\"width{{w}}\"的情况\n        if (hasExpr) {\n            var array = scanExpr(code)\n            if (array.length === 1) {\n                return array[0].value\n            }\n            return array.map(function (el) {\n                return el.expr ? \"(\" + el.value + \")\" : quote(el.value)\n            }).join(\" + \")\n        } else {\n            return code\n        }\n    }\n//parseExpr的智能引用代理\n\n    function parseExprProxy(code, scopes, data, noRegister) {\n        code = code || \"\" //code 可能未定义\n        parseExpr(code, scopes, data)\n        if (data.evaluator && !noRegister) {\n            data.handler = bindingExecutors[data.handlerName || data.type]\n            //方便调试\n            //这里非常重要,我们通过判定视图刷新函数的element是否在DOM树决定\n            //将它移出订阅者列表\n            avalon.injectBinding(data)\n        }\n    }\n    avalon.parseExprProxy = parseExprProxy\n    /*********************************************************************\n     *                           扫描系统                                 *\n     **********************************************************************/\n\n    avalon.scan = function(elem, vmodel) {\n        elem = elem || root\n        var vmodels = vmodel ? [].concat(vmodel) : []\n        scanTag(elem, vmodels)\n    }\n\n//http://www.w3.org/TR/html5/syntax.html#void-elements\n    var stopScan = oneObject(\"area,base,basefont,br,col,command,embed,hr,img,input,link,meta,param,source,track,wbr,noscript,script,style,textarea\".toUpperCase())\n\n    function checkScan(elem, callback, innerHTML) {\n        var id = setTimeout(function() {\n            var currHTML = elem.innerHTML\n            clearTimeout(id)\n            if (currHTML === innerHTML) {\n                callback()\n            } else {\n                checkScan(elem, callback, currHTML)\n            }\n        })\n    }\n\n\n    function createSignalTower(elem, vmodel) {\n        var id = elem.getAttribute(\"avalonctrl\") || vmodel.$id\n        elem.setAttribute(\"avalonctrl\", id)\n        vmodel.$events.expr = elem.tagName + '[avalonctrl=\"' + id + '\"]'\n    }\n\n    var getBindingCallback = function(elem, name, vmodels) {\n        var callback = elem.getAttribute(name)\n        if (callback) {\n            for (var i = 0, vm; vm = vmodels[i++]; ) {\n                if (vm.hasOwnProperty(callback) && typeof vm[callback] === \"function\") {\n                    return vm[callback]\n                }\n            }\n        }\n    }\n\n    function executeBindings(bindings, vmodels) {\n        for (var i = 0, data; data = bindings[i++]; ) {\n            data.vmodels = vmodels\n            bindingHandlers[data.type](data, vmodels)\n            if (data.evaluator && data.element && data.element.nodeType === 1) { //移除数据绑定，防止被二次解析\n                //chrome使用removeAttributeNode移除不存在的特性节点时会报错 https://github.com/RubyLouvre/avalon/issues/99\n                data.element.removeAttribute(data.name)\n            }\n        }\n        bindings.length = 0\n    }\n\n//https://github.com/RubyLouvre/avalon/issues/636\n    var mergeTextNodes = IEVersion && window.MutationObserver ? function (elem) {\n        var node = elem.firstChild, text\n        while (node) {\n            var aaa = node.nextSibling\n            if (node.nodeType === 3) {\n                if (text) {\n                    text.nodeValue += node.nodeValue\n                    elem.removeChild(node)\n                } else {\n                    text = node\n                }\n            } else {\n                text = null\n            }\n            node = aaa\n        }\n    } : 0\n    var roneTime = /^\\s*::/\n    var rmsAttr = /ms-(\\w+)-?(.*)/\n    var priorityMap = {\n        \"if\": 10,\n        \"repeat\": 90,\n        \"data\": 100,\n        \"widget\": 110,\n        \"each\": 1400,\n        \"with\": 1500,\n        \"duplex\": 2000,\n        \"on\": 3000\n    }\n\n    var events = oneObject(\"animationend,blur,change,input,click,dblclick,focus,keydown,keypress,keyup,mousedown,mouseenter,mouseleave,mousemove,mouseout,mouseover,mouseup,scan,scroll,submit\")\n    var obsoleteAttrs = oneObject(\"value,title,alt,checked,selected,disabled,readonly,enabled\")\n    function bindingSorter(a, b) {\n        return a.priority - b.priority\n    }\n\n    function scanAttr(elem, vmodels, match) {\n        var scanNode = true\n        if (vmodels.length) {\n            var attributes = getAttributes ? getAttributes(elem) : elem.attributes\n            var bindings = []\n            var fixAttrs = []\n            var msData = {}\n            var uniq = {}\n            for (var i = 0, attr; attr = attributes[i++]; ) {\n                if (attr.specified) {\n                    if (match = attr.name.match(rmsAttr)) {\n                        //如果是以指定前缀命名的\n                        var type = match[1]\n                        var param = match[2] || \"\"\n                        var value = attr.value\n                        var name = attr.name\n                        if (uniq[name]) {//IE8下ms-repeat,ms-with BUG\n                            continue\n                        }\n                        uniq[name] = 1\n                        if (events[type]) {\n                            param = type\n                            type = \"on\"\n                        } else if (obsoleteAttrs[type]) {\n                            if (type === \"enabled\") {//吃掉ms-enabled绑定,用ms-disabled代替\n                                log(\"warning!ms-enabled或ms-attr-enabled已经被废弃\")\n                                type = \"disabled\"\n                                value = \"!(\" + value + \")\"\n                            }\n                            param = type\n                            type = \"attr\"\n                            name = \"ms-\" + type + \"-\" + param\n                            fixAttrs.push([attr.name, name, value])\n                        }\n                        msData[name] = value\n                        if (typeof bindingHandlers[type] === \"function\") {\n                            var newValue = value.replace(roneTime, \"\")\n                            var oneTime = value !== newValue\n                            var binding = {\n                                type: type,\n                                param: param,\n                                element: elem,\n                                name: name,\n                                value: newValue,\n                                oneTime: oneTime,\n                                uuid: name + \"-\" + getUid(elem),\n                                //chrome与firefox下Number(param)得到的值不一样 #855\n                                priority: (priorityMap[type] || type.charCodeAt(0) * 10) + (Number(param.replace(/\\D/g, \"\")) || 0)\n                            }\n                            if (type === \"html\" || type === \"text\") {\n                                var token = getToken(value)\n                                avalon.mix(binding, token)\n                                binding.filters = binding.filters.replace(rhasHtml, function () {\n                                    binding.type = \"html\"\n                                    binding.group = 1\n                                    return \"\"\n                                })// jshint ignore:line\n                            } else if (type === \"duplex\") {\n                                var hasDuplex = name\n                            } else if (name === \"ms-if-loop\") {\n                                binding.priority += 100\n                            }\n                            bindings.push(binding)\n                            if (type === \"widget\") {\n                                elem.msData = elem.msData || msData\n                            }\n                        }\n                    }\n                }\n            }\n            if (bindings.length) {\n                bindings.sort(bindingSorter)\n                fixAttrs.forEach(function (arr) {\n                    log(\"warning!请改用\" + arr[1] + \"代替\" + arr[0] + \"!\")\n                    elem.removeAttribute(arr[0])\n                    elem.setAttribute(arr[1], arr[2])\n                })\n                //http://bugs.jquery.com/ticket/7071\n                //在IE下对VML读取type属性,会让此元素所有属性都变成<Failed>\n                if (hasDuplex && msData[\"ms-attr-value\"] && !elem.scopeName && elem.type === \"text\") {\n                    log(\"warning!一个控件不能同时定义ms-attr-value与\" + hasDuplex)\n                }\n                for (i = 0; binding = bindings[i]; i++) {\n                    type = binding.type\n                    if (rnoscanAttrBinding.test(type)) {\n                        return executeBindings(bindings.slice(0, i + 1), vmodels)\n                    } else if (scanNode) {\n                        scanNode = !rnoscanNodeBinding.test(type)\n                    }\n                }\n                executeBindings(bindings, vmodels)\n            }\n        }\n        if (scanNode && !stopScan[elem.tagName] && rbind.test(elem.innerHTML.replace(rlt, \"<\").replace(rgt, \">\"))) {\n            mergeTextNodes && mergeTextNodes(elem)\n            scanNodeList(elem, vmodels) //扫描子孙元素\n        }\n    }\n    var rnoscanAttrBinding = /^if|widget|repeat$/\n    var rnoscanNodeBinding = /^each|with|html|include$/\n//IE67下，在循环绑定中，一个节点如果是通过cloneNode得到，自定义属性的specified为false，无法进入里面的分支，\n//但如果我们去掉scanAttr中的attr.specified检测，一个元素会有80+个特性节点（因为它不区分固有属性与自定义属性），很容易卡死页面\n    if (!W3C) {\n        var attrPool = new Cache(512)\n        var rattrs = /\\s+(ms-[^=\\s]+)(?:=(\"[^\"]*\"|'[^']*'|[^\\s>]+))?/g,\n            rquote = /^['\"]/,\n            rtag = /<\\w+\\b(?:([\"'])[^\"]*?(\\1)|[^>])*>/i,\n            ramp = /&amp;/g\n        //IE6-8解析HTML5新标签，会将它分解两个元素节点与一个文本节点\n        //<body><section>ddd</section></body>\n        //        window.onload = function() {\n        //            var body = document.body\n        //            for (var i = 0, el; el = body.children[i++]; ) {\n        //                avalon.log(el.outerHTML)\n        //            }\n        //        }\n        //依次输出<SECTION>, </SECTION>\n        var getAttributes = function (elem) {\n            var html = elem.outerHTML\n            //处理IE6-8解析HTML5新标签的情况，及<br>等半闭合标签outerHTML为空的情况\n            if (html.slice(0, 2) === \"</\" || !html.trim()) {\n                return []\n            }\n            var str = html.match(rtag)[0]\n            var attributes = [],\n                match,\n                k, v\n            var ret = attrPool.get(str)\n            if (ret) {\n                return ret\n            }\n            while (k = rattrs.exec(str)) {\n                v = k[2]\n                if (v) {\n                    v = (rquote.test(v) ? v.slice(1, -1) : v).replace(ramp, \"&\")\n                }\n                var name = k[1].toLowerCase()\n                match = name.match(rmsAttr)\n                var binding = {\n                    name: name,\n                    specified: true,\n                    value: v || \"\"\n                }\n                attributes.push(binding)\n            }\n            return attrPool.put(str, attributes)\n        }\n    }\n\n    function scanNodeList(parent, vmodels) {\n        var nodes = avalon.slice(parent.childNodes)\n        scanNodeArray(nodes, vmodels)\n    }\n\n    function scanNodeArray(nodes, vmodels) {\n        for (var i = 0, node; node = nodes[i++];) {\n            switch (node.nodeType) {\n                case 1:\n                    scanTag(node, vmodels) //扫描元素节点\n                    if (node.msCallback) {\n                        node.msCallback()\n                        node.msCallback = void 0\n                    }\n                    break\n                case 3:\n                    if(rexpr.test(node.nodeValue)){\n                        scanText(node, vmodels, i) //扫描文本节点\n                    }\n                    break\n            }\n        }\n    }\n\n\n    function scanTag(elem, vmodels, node) {\n        //扫描顺序  ms-skip(0) --> ms-important(1) --> ms-controller(2) --> ms-if(10) --> ms-repeat(100)\n        //--> ms-if-loop(110) --> ms-attr(970) ...--> ms-each(1400)-->ms-with(1500)--〉ms-duplex(2000)垫后\n        var a = elem.getAttribute(\"ms-skip\")\n        //#360 在旧式IE中 Object标签在引入Flash等资源时,可能出现没有getAttributeNode,innerHTML的情形\n        if (!elem.getAttributeNode) {\n            return log(\"warning \" + elem.tagName + \" no getAttributeNode method\")\n        }\n        var b = elem.getAttributeNode(\"ms-important\")\n        var c = elem.getAttributeNode(\"ms-controller\")\n        if (typeof a === \"string\") {\n            return\n        } else if (node = b || c) {\n            var newVmodel = avalon.vmodels[node.value]\n            if (!newVmodel) {\n                return\n            }\n            //ms-important不包含父VM，ms-controller相反\n            vmodels = node === b ? [newVmodel] : [newVmodel].concat(vmodels)\n            var name = node.name\n            elem.removeAttribute(name) //removeAttributeNode不会刷新[ms-controller]样式规则\n            avalon(elem).removeClass(name)\n            createSignalTower(elem, newVmodel)\n        }\n        scanAttr(elem, vmodels) //扫描特性节点\n    }\n    var rhasHtml = /\\|\\s*html(?:\\b|$)/,\n        r11a = /\\|\\|/g,\n        rlt = /&lt;/g,\n        rgt = /&gt;/g,\n        rstringLiteral = /(['\"])(\\\\\\1|.)+?\\1/g\n    function getToken(value) {\n        if (value.indexOf(\"|\") > 0) {\n            var scapegoat = value.replace(rstringLiteral, function (_) {\n                return Array(_.length + 1).join(\"1\")// jshint ignore:line\n            })\n            var index = scapegoat.replace(r11a, \"\\u1122\\u3344\").indexOf(\"|\") //干掉所有短路或\n            if (index > -1) {\n                return {\n                    filters: value.slice(index),\n                    value: value.slice(0, index),\n                    expr: true\n                }\n            }\n        }\n        return {\n            value: value,\n            filters: \"\",\n            expr: true\n        }\n    }\n\n    function scanExpr(str) {\n        var tokens = [],\n            value, start = 0,\n            stop\n        do {\n            stop = str.indexOf(openTag, start)\n            if (stop === -1) {\n                break\n            }\n            value = str.slice(start, stop)\n            if (value) { // {{ 左边的文本\n                tokens.push({\n                    value: value,\n                    filters: \"\",\n                    expr: false\n                })\n            }\n            start = stop + openTag.length\n            stop = str.indexOf(closeTag, start)\n            if (stop === -1) {\n                break\n            }\n            value = str.slice(start, stop)\n            if (value) { //处理{{ }}插值表达式\n                tokens.push(getToken(value))\n            }\n            start = stop + closeTag.length\n        } while (1)\n        value = str.slice(start)\n        if (value) { //}} 右边的文本\n            tokens.push({\n                value: value,\n                expr: false,\n                filters: \"\"\n            })\n        }\n        return tokens\n    }\n\n    function scanText(textNode, vmodels) {\n        var bindings = [], tokens = scanExpr(textNode.data)\n        if (tokens.length) {\n            for (var i = 0, token; token = tokens[i++]; ) {\n                var node = DOC.createTextNode(token.value) //将文本转换为文本节点，并替换原来的文本节点\n                if (token.expr) {\n                    token.value = token.value.replace(roneTime, function () {\n                        token.oneTime = true\n                        return \"\"\n                    })// jshint ignore:line\n                    token.type = \"text\"\n                    token.element = node\n                    token.filters = token.filters.replace(rhasHtml, function (a, b,c) {\n                        token.type = \"html\"\n                        return \"\"\n                    })// jshint ignore:line\n                    bindings.push(token) //收集带有插值表达式的文本\n                }\n                avalonFragment.appendChild(node)\n            }\n            textNode.parentNode.replaceChild(avalonFragment, textNode)\n            if (bindings.length)\n                executeBindings(bindings, vmodels)\n        }\n    }\n\n    var bools = [\"autofocus,autoplay,async,allowTransparency,checked,controls\",\n        \"declare,disabled,defer,defaultChecked,defaultSelected\",\n        \"contentEditable,isMap,loop,multiple,noHref,noResize,noShade\",\n        \"open,readOnly,selected\"\n    ].join(\",\")\n    var boolMap = {}\n    bools.replace(rword, function (name) {\n        boolMap[name.toLowerCase()] = name\n    })\n\n    var propMap = {//属性名映射\n        \"accept-charset\": \"acceptCharset\",\n        \"char\": \"ch\",\n        \"charoff\": \"chOff\",\n        \"class\": \"className\",\n        \"for\": \"htmlFor\",\n        \"http-equiv\": \"httpEquiv\"\n    }\n\n    var anomaly = [\"accessKey,bgColor,cellPadding,cellSpacing,codeBase,codeType,colSpan\",\n        \"dateTime,defaultValue,frameBorder,longDesc,maxLength,marginWidth,marginHeight\",\n        \"rowSpan,tabIndex,useMap,vSpace,valueType,vAlign\"\n    ].join(\",\")\n    anomaly.replace(rword, function (name) {\n        propMap[name.toLowerCase()] = name\n    })\n\n    var rnoscripts = /<noscript.*?>(?:[\\s\\S]+?)<\\/noscript>/img\n    var rnoscriptText = /<noscript.*?>([\\s\\S]+?)<\\/noscript>/im\n\n    var getXHR = function () {\n        return new (window.XMLHttpRequest || ActiveXObject)(\"Microsoft.XMLHTTP\") // jshint ignore:line\n    }\n\n    var templatePool = avalon.templateCache = {}\n\n    bindingHandlers.attr = function (data, vmodels) {\n        var value = stringifyExpr(data.value.trim())\n        if (data.type === \"include\") {\n            var elem = data.element\n            data.includeRendered = getBindingCallback(elem, \"data-include-rendered\", vmodels)\n            data.includeLoaded = getBindingCallback(elem, \"data-include-loaded\", vmodels)\n            var outer = data.includeReplace = !!avalon(elem).data(\"includeReplace\")\n            if (avalon(elem).data(\"includeCache\")) {\n                data.templateCache = {}\n            }\n            data.startInclude = DOC.createComment(\"ms-include\")\n            data.endInclude = DOC.createComment(\"ms-include-end\")\n            if (outer) {\n                data.element = data.startInclude\n                elem.parentNode.insertBefore(data.startInclude, elem)\n                elem.parentNode.insertBefore(data.endInclude, elem.nextSibling)\n            } else {\n                elem.insertBefore(data.startInclude, elem.firstChild)\n                elem.appendChild(data.endInclude)\n            }\n        }\n        data.handlerName = \"attr\" //handleName用于处理多种绑定共用同一种bindingExecutor的情况\n        parseExprProxy(value, vmodels, data)\n    }\n\n    bindingExecutors.attr = function (val, elem, data) {\n        var method = data.type,\n            attrName = data.param\n        if (method === \"css\") {\n            avalon(elem).css(attrName, val)\n        } else if (method === \"attr\") {\n\n            // ms-attr-class=\"xxx\" vm.xxx=\"aaa bbb ccc\"将元素的className设置为aaa bbb ccc\n            // ms-attr-class=\"xxx\" vm.xxx=false  清空元素的所有类名\n            // ms-attr-name=\"yyy\"  vm.yyy=\"ooo\" 为元素设置name属性\n            var toRemove = (val === false) || (val === null) || (val === void 0)\n\n            if (!W3C && propMap[attrName]) { //旧式IE下需要进行名字映射\n                attrName = propMap[attrName]\n            }\n            var bool = boolMap[attrName]\n            if (typeof elem[bool] === \"boolean\") {\n                elem[bool] = !!val //布尔属性必须使用el.xxx = true|false方式设值\n                if (!val) { //如果为false, IE全系列下相当于setAttribute(xxx,''),会影响到样式,需要进一步处理\n                    toRemove = true\n                }\n            }\n            if (toRemove) {\n                return elem.removeAttribute(attrName)\n            }\n            //SVG只能使用setAttribute(xxx, yyy), VML只能使用elem.xxx = yyy ,HTML的固有属性必须elem.xxx = yyy\n            var isInnate = rsvg.test(elem) ? false : (DOC.namespaces && isVML(elem)) ? true : attrName in elem.cloneNode(false)\n            if (isInnate) {\n                elem[attrName] = val + \"\"\n            } else {\n                elem.setAttribute(attrName, val)\n            }\n        } else if (method === \"include\" && val) {\n            var vmodels = data.vmodels\n            var rendered = data.includeRendered\n            var loaded = data.includeLoaded\n            var replace = data.includeReplace\n            var target = replace ? elem.parentNode : elem\n            var scanTemplate = function (text) {\n                if (data.vmodels === null) {\n                    return\n                }\n\n                if (loaded) {\n                    var newText = loaded.apply(target, [text].concat(vmodels))\n                    if (typeof newText === \"string\")\n                        text = newText\n                }\n                if (rendered) {\n                    checkScan(target, function () {\n                        rendered.call(target)\n                    }, NaN)\n                }\n                var lastID = data.includeLastID\n                if (data.templateCache && lastID && lastID !== val) {\n                    var lastTemplate = data.templateCache[lastID]\n                    if (!lastTemplate) {\n                        lastTemplate = data.templateCache[lastID] = DOC.createElement(\"div\")\n                        ifGroup.appendChild(lastTemplate)\n                    }\n                }\n                data.includeLastID = val\n                while (data.startInclude) {\n                    var node = data.startInclude.nextSibling\n                    if (node && node !== data.endInclude) {\n                        target.removeChild(node)\n                        if (lastTemplate)\n                            lastTemplate.appendChild(node)\n                    } else {\n                        break\n                    }\n                }\n                var dom = getTemplateNodes(data, val, text)\n                var nodes = avalon.slice(dom.childNodes)\n                target.insertBefore(dom, data.endInclude)\n                scanNodeArray(nodes, vmodels)\n            }\n\n            if (data.param === \"src\") {\n                if (typeof templatePool[val] === \"string\") {\n                    avalon.nextTick(function () {\n                        scanTemplate(templatePool[val])\n                    })\n                } else if (Array.isArray(templatePool[val])) { //#805 防止在循环绑定中发出许多相同的请求\n                    templatePool[val].push(scanTemplate)\n                } else {\n                    var xhr = getXHR()\n                    xhr.onreadystatechange = function () {\n                        if (xhr.readyState === 4) {\n                            var s = xhr.status\n                            if (s >= 200 && s < 300 || s === 304 || s === 1223) {\n                                var text = xhr.responseText\n                                for (var f = 0, fn; fn = templatePool[val][f++]; ) {\n                                    fn(text)\n                                }\n                                templatePool[val] = text\n                            }\n                        }\n                    }\n                    templatePool[val] = [scanTemplate]\n                    xhr.open(\"GET\", val, true)\n                    if (\"withCredentials\" in xhr) {\n                        xhr.withCredentials = true\n                    }\n                    xhr.setRequestHeader(\"X-Requested-With\", \"XMLHttpRequest\")\n                    xhr.send(null)\n                }\n            } else {\n                //IE系列与够新的标准浏览器支持通过ID取得元素（firefox14+）\n                //http://tjvantoll.com/2012/07/19/dom-element-references-as-global-variables/\n                var el = val && val.nodeType === 1 ? val : DOC.getElementById(val)\n                if (el) {\n                    if (el.tagName === \"NOSCRIPT\" && !(el.innerHTML || el.fixIE78)) { //IE7-8 innerText,innerHTML都无法取得其内容，IE6能取得其innerHTML\n                        xhr = getXHR() //IE9-11与chrome的innerHTML会得到转义的内容，它们的innerText可以\n                        xhr.open(\"GET\", location, false) //谢谢Nodejs 乱炖群 深圳-纯属虚构\n                        xhr.send(null)\n                        //http://bbs.csdn.net/topics/390349046?page=1#post-393492653\n                        var noscripts = DOC.getElementsByTagName(\"noscript\")\n                        var array = (xhr.responseText || \"\").match(rnoscripts) || []\n                        var n = array.length\n                        for (var i = 0; i < n; i++) {\n                            var tag = noscripts[i]\n                            if (tag) { //IE6-8中noscript标签的innerHTML,innerText是只读的\n                                tag.style.display = \"none\" //http://haslayout.net/css/noscript-Ghost-Bug\n                                tag.fixIE78 = (array[i].match(rnoscriptText) || [\"\", \"&nbsp;\"])[1]\n                            }\n                        }\n                    }\n                    avalon.nextTick(function () {\n                        scanTemplate(el.fixIE78 || el.value || el.innerText || el.innerHTML)\n                    })\n                }\n            }\n        } else {\n            if (!root.hasAttribute && typeof val === \"string\" && (method === \"src\" || method === \"href\")) {\n                val = val.replace(/&amp;/g, \"&\") //处理IE67自动转义的问题\n            }\n            elem[method] = val\n            if (window.chrome && elem.tagName === \"EMBED\") {\n                var parent = elem.parentNode //#525  chrome1-37下embed标签动态设置src不能发生请求\n                var comment = document.createComment(\"ms-src\")\n                parent.replaceChild(comment, elem)\n                parent.replaceChild(elem, comment)\n            }\n        }\n    }\n\n    function getTemplateNodes(data, id, text) {\n        var div = data.templateCache && data.templateCache[id]\n        if (div) {\n            var dom = DOC.createDocumentFragment(),\n                firstChild\n            while (firstChild = div.firstChild) {\n                dom.appendChild(firstChild)\n            }\n            return dom\n        }\n        return avalon.parseHTML(text)\n    }\n\n//这几个指令都可以使用插值表达式，如ms-src=\"aaa/{{b}}/{{c}}.html\"\n    \"title,alt,src,value,css,include,href\".replace(rword, function (name) {\n        bindingHandlers[name] = bindingHandlers.attr\n    })\n//根据VM的属性值或表达式的值切换类名，ms-class=\"xxx yyy zzz:flag\"\n//http://www.cnblogs.com/rubylouvre/archive/2012/12/17/2818540.html\n    bindingHandlers[\"class\"] = function (binding, vmodels) {\n        var oldStyle = binding.param,\n            text = binding.value,\n            rightExpr\n        binding.handlerName = \"class\"\n        if (!oldStyle || isFinite(oldStyle)) {\n            binding.param = \"\" //去掉数字\n            var colonIndex = text.replace(rexprg, function (a) {\n                return a.replace(/./g, \"0\")\n            }).indexOf(\":\") //取得第一个冒号的位置\n            if (colonIndex === -1) { // 比如 ms-class=\"aaa bbb ccc\" 的情况\n                var className = text\n                rightExpr = true\n            } else { // 比如 ms-class-1=\"ui-state-active:checked\" 的情况\n                className = text.slice(0, colonIndex)\n                rightExpr = text.slice(colonIndex + 1)\n            }\n            if (!rexpr.test(text)) {\n                className = quote(className)\n            } else {\n                className = stringifyExpr(className)\n            }\n            binding.expr = \"[\" + className + \",\" + rightExpr + \"]\"\n        } else {\n            binding.expr = '[' + quote(oldStyle) + \",\" + text + \"]\"\n            binding.oldStyle = oldStyle\n        }\n        var method = binding.type\n        if (method === \"hover\" || method === \"active\") { //确保只绑定一次\n            if (!binding.hasBindEvent) {\n                var elem = binding.element\n                var $elem = avalon(elem)\n                var activate = \"mouseenter\" //在移出移入时切换类名\n                var abandon = \"mouseleave\"\n                if (method === \"active\") { //在聚焦失焦中切换类名\n                    elem.tabIndex = elem.tabIndex || -1\n                    activate = \"mousedown\"\n                    abandon = \"mouseup\"\n                    var fn0 = $elem.bind(\"mouseleave\", function () {\n                        binding.toggleClass && $elem.removeClass(binding.newClass)\n                    })\n                }\n            }\n\n            var fn1 = $elem.bind(activate, function () {\n                binding.toggleClass && $elem.addClass(binding.newClass)\n            })\n            var fn2 = $elem.bind(abandon, function () {\n                binding.toggleClass && $elem.removeClass(binding.newClass)\n            })\n            binding.rollback = function () {\n                $elem.unbind(\"mouseleave\", fn0)\n                $elem.unbind(activate, fn1)\n                $elem.unbind(abandon, fn2)\n            }\n            binding.hasBindEvent = true\n        }\n        parseExprProxy(binding.expr, vmodels, binding)\n    }\n\n    bindingExecutors[\"class\"] = function (arr, elem, binding) {\n        var $elem = avalon(elem)\n        binding.newClass = arr[0]\n        binding.toggleClass = !!arr[1]\n        if (binding.oldClass && binding.newClass !== binding.oldClass) {\n            $elem.removeClass(binding.oldClass)\n        }\n        binding.oldClass = binding.newClass\n        if (binding.type === \"class\") {\n            if (binding.oldStyle) {\n                $elem.toggleClass(binding.oldStyle, !!arr[1])\n            } else {\n                $elem.toggleClass(binding.newClass, binding.toggleClass)\n            }\n        }\n\n    }\n\n    \"hover,active\".replace(rword, function (method) {\n        bindingHandlers[method] = bindingHandlers[\"class\"]\n    })\n//ms-controller绑定已经在scanTag 方法中实现\n//ms-css绑定已由ms-attr绑定实现\n\n\n// bindingHandlers.data 定义在if.js\n    bindingExecutors.data = function(val, elem, data) {\n        var key = \"data-\" + data.param\n        if (val && typeof val === \"object\") {\n            elem[key] = val\n        } else {\n            elem.setAttribute(key, String(val))\n        }\n    }\n//双工绑定\n    var duplexBinding = bindingHandlers.duplex = function(data, vmodels) {\n        var elem = data.element,\n            hasCast\n        parseExprProxy(data.value, vmodels, data, 1)\n\n        data.changed = getBindingCallback(elem, \"data-duplex-changed\", vmodels) || noop\n        if (data.evaluator && data.args) {\n            var params = []\n            var casting = oneObject(\"string,number,boolean,checked\")\n            if (elem.type === \"radio\" && data.param === \"\") {\n                data.param = \"checked\"\n            }\n            if (elem.msData) {\n                elem.msData[\"ms-duplex\"] = data.value\n            }\n            data.param.replace(/\\w+/g, function(name) {\n                if (/^(checkbox|radio)$/.test(elem.type) && /^(radio|checked)$/.test(name)) {\n                    if (name === \"radio\")\n                        log(\"ms-duplex-radio已经更名为ms-duplex-checked\")\n                    name = \"checked\"\n                    data.isChecked = true\n                }\n                if (name === \"bool\") {\n                    name = \"boolean\"\n                    log(\"ms-duplex-bool已经更名为ms-duplex-boolean\")\n                } else if (name === \"text\") {\n                    name = \"string\"\n                    log(\"ms-duplex-text已经更名为ms-duplex-string\")\n                }\n                if (casting[name]) {\n                    hasCast = true\n                }\n                avalon.Array.ensure(params, name)\n            })\n            if (!hasCast) {\n                params.push(\"string\")\n            }\n            data.param = params.join(\"-\")\n            data.bound = function(type, callback) {\n                if (elem.addEventListener) {\n                    elem.addEventListener(type, callback, false)\n                } else {\n                    elem.attachEvent(\"on\" + type, callback)\n                }\n                var old = data.rollback\n                data.rollback = function() {\n                    elem.avalonSetter = null\n                    avalon.unbind(elem, type, callback)\n                    old && old()\n                }\n            }\n            for (var i in avalon.vmodels) {\n                var v = avalon.vmodels[i]\n                v.$fire(\"avalon-ms-duplex-init\", data)\n            }\n            var cpipe = data.pipe || (data.pipe = pipe)\n            cpipe(null, data, \"init\")\n            var tagName = elem.tagName\n            duplexBinding[tagName] && duplexBinding[tagName](elem, data.evaluator.apply(null, data.args), data)\n        }\n    }\n//不存在 bindingExecutors.duplex\n\n    function fixNull(val) {\n        return val == null ? \"\" : val\n    }\n    avalon.duplexHooks = {\n        checked: {\n            get: function(val, data) {\n                return !data.element.oldValue\n            }\n        },\n        string: {\n            get: function(val) { //同步到VM\n                return val\n            },\n            set: fixNull\n        },\n        \"boolean\": {\n            get: function(val) {\n                return val === \"true\"\n            },\n            set: fixNull\n        },\n        number: {\n            get: function(val, data) {\n                var number = parseFloat(val)\n                if (-val === -number) {\n                    return number\n                }\n                var arr = /strong|medium|weak/.exec(data.element.getAttribute(\"data-duplex-number\")) || [\"medium\"]\n                switch (arr[0]) {\n                    case \"strong\":\n                        return 0\n                    case \"medium\":\n                        return val === \"\" ? \"\" : 0\n                    case \"weak\":\n                        return val\n                }\n            },\n            set: fixNull\n        }\n    }\n\n    function pipe(val, data, action, e) {\n        data.param.replace(/\\w+/g, function(name) {\n            var hook = avalon.duplexHooks[name]\n            if (hook && typeof hook[action] === \"function\") {\n                val = hook[action](val, data)\n            }\n        })\n        return val\n    }\n\n    var TimerID, ribbon = []\n\n    avalon.tick = function(fn) {\n        if (ribbon.push(fn) === 1) {\n            TimerID = setInterval(ticker, 60)\n        }\n    }\n\n    function ticker() {\n        for (var n = ribbon.length - 1; n >= 0; n--) {\n            var el = ribbon[n]\n            if (el() === false) {\n                ribbon.splice(n, 1)\n            }\n        }\n        if (!ribbon.length) {\n            clearInterval(TimerID)\n        }\n    }\n\n    var watchValueInTimer = noop\n    new function() { // jshint ignore:line\n        try { //#272 IE9-IE11, firefox\n            var setters = {}\n            var aproto = HTMLInputElement.prototype\n            var bproto = HTMLTextAreaElement.prototype\n            function newSetter(value) { // jshint ignore:line\n                setters[this.tagName].call(this, value)\n                if (!this.msFocus && this.avalonSetter) {\n                    this.avalonSetter()\n                }\n            }\n            var inputProto = HTMLInputElement.prototype\n            Object.getOwnPropertyNames(inputProto) //故意引发IE6-8等浏览器报错\n            setters[\"INPUT\"] = Object.getOwnPropertyDescriptor(aproto, \"value\").set\n\n            Object.defineProperty(aproto, \"value\", {\n                set: newSetter\n            })\n            setters[\"TEXTAREA\"] = Object.getOwnPropertyDescriptor(bproto, \"value\").set\n            Object.defineProperty(bproto, \"value\", {\n                set: newSetter\n            })\n        } catch (e) {\n            //在chrome 43中 ms-duplex终于不需要使用定时器实现双向绑定了\n            // http://updates.html5rocks.com/2015/04/DOM-attributes-now-on-the-prototype\n            // https://docs.google.com/document/d/1jwA8mtClwxI-QJuHT7872Z0pxpZz8PBkf2bGAbsUtqs/edit?pli=1\n            watchValueInTimer = avalon.tick\n        }\n    } // jshint ignore:line\n    if (IEVersion) {\n        avalon.bind(DOC, \"selectionchange\", function (e) {\n            var el = DOC.activeElement || {}\n            if (!el.msFocus && el.avalonSetter) {\n                el.avalonSetter()\n            }\n        })\n    }\n    var rnoduplex = /^(file|button|reset|submit|checkbox|radio|range)$/\n//处理radio, checkbox, text, textarea, password\n    duplexBinding.INPUT = function (elem, evaluator, data) {\n        var $type = elem.type,\n            bound = data.bound,\n            $elem = avalon(elem),\n            composing = false\n\n        function callback(value) {\n            data.changed.call(this, value, data)\n        }\n\n        function compositionStart() {\n            composing = true\n        }\n\n        function compositionEnd() {\n            composing = false\n        }\n        var IE9Value\n        //当value变化时改变model的值\n        var updateVModel = function () {\n            var val = elem.value //防止递归调用形成死循环\n            if (composing || val === IE9Value) //处理中文输入法在minlengh下引发的BUG\n                return\n            var lastValue = data.pipe(val, data, \"get\")\n            if ($elem.data(\"duplexObserve\") !== false) {\n                IE9Value = val\n                evaluator(lastValue)\n                callback.call(elem, lastValue)\n            }\n        }\n        //当model变化时,它就会改变value的值\n        data.handler = function () {\n            var val = data.pipe(evaluator(), data, \"set\")  //fix #673 #1106\n            if (val !== IE9Value) {\n                var fixCaret = false\n                if (elem.msFocus) {\n                    try {\n                        var pos = getCaret(elem)\n                        if (pos.start === pos.end) {\n                            pos = pos.start\n                            fixCaret = true\n                        }\n                    } catch (e) {\n                    }\n                }\n                elem.value = IE9Value = val\n                if (fixCaret && !elem.readyOnly) {\n                    setCaret(elem, pos, pos)\n                }\n            }\n        }\n        if (data.isChecked || $type === \"radio\") {\n            var IE6 = IEVersion === 6\n            updateVModel = function () {\n                if ($elem.data(\"duplexObserve\") !== false) {\n                    var lastValue = data.pipe(elem.value, data, \"get\")\n                    evaluator(lastValue)\n                    callback.call(elem, lastValue)\n                }\n            }\n            data.handler = function () {\n                var val = evaluator()\n                var checked = data.isChecked ? !!val : val + \"\" === elem.value\n                elem.oldValue = checked\n                if (IE6) {\n                    setTimeout(function () {\n                        //IE8 checkbox, radio是使用defaultChecked控制选中状态，\n                        //并且要先设置defaultChecked后设置checked\n                        //并且必须设置延迟\n                        elem.defaultChecked = checked\n                        elem.checked = checked\n                    }, 31)\n                } else {\n                    elem.checked = checked\n                }\n            }\n            bound(\"click\", updateVModel)\n        } else if ($type === \"checkbox\") {\n            updateVModel = function () {\n                if ($elem.data(\"duplexObserve\") !== false) {\n                    var method = elem.checked ? \"ensure\" : \"remove\"\n                    var array = evaluator()\n                    if (!Array.isArray(array)) {\n                        log(\"ms-duplex应用于checkbox上要对应一个数组\")\n                        array = [array]\n                    }\n                    var val = data.pipe(elem.value, data, \"get\")\n                    avalon.Array[method](array, val)\n                    callback.call(elem, array)\n                }\n            }\n\n            data.handler = function () {\n                var array = [].concat(evaluator()) //强制转换为数组\n                var val = data.pipe(elem.value, data, \"get\")\n                elem.checked = array.indexOf(val) > -1\n            }\n            bound(W3C ? \"change\" : \"click\", updateVModel)\n        } else {\n            var events = elem.getAttribute(\"data-duplex-event\") || \"input\"\n            if (elem.attributes[\"data-event\"]) {\n                log(\"data-event指令已经废弃，请改用data-duplex-event\")\n            }\n\n            function delay(e) { // jshint ignore:line\n                setTimeout(function () {\n                    updateVModel(e)\n                })\n            }\n            events.replace(rword, function (name) {\n                switch (name) {\n                    case \"input\":\n                        if (!IEVersion) { // W3C\n                            bound(\"input\", updateVModel)\n                            //非IE浏览器才用这个\n                            bound(\"compositionstart\", compositionStart)\n                            bound(\"compositionend\", compositionEnd)\n                            bound(\"DOMAutoComplete\", updateVModel)\n                        } else {\n                            // IE下通过selectionchange事件监听IE9+点击input右边的X的清空行为，及粘贴，剪切，删除行为\n                            if (IEVersion > 8) {\n                                if(IEVersion === 9){\n                                    //IE9删除字符后再失去焦点不会同步 #1167\n                                    bound(\"keyup\", updateVModel)\n                                }\n                                //IE9使用propertychange无法监听中文输入改动\n                                bound(\"input\", updateVModel)\n                            } else {\n                                //onpropertychange事件无法区分是程序触发还是用户触发\n                                //IE6-8下第一次修改时不会触发,需要使用keydown或selectionchange修正\n                                bound(\"propertychange\", function (e) {\n                                    if (e.propertyName === \"value\") {\n                                        updateVModel()\n                                    }\n                                })\n                            }\n                            bound(\"dragend\", delay)\n                            //http://www.cnblogs.com/rubylouvre/archive/2013/02/17/2914604.html\n                            //http://www.matts411.com/post/internet-explorer-9-oninput/\n                        }\n                        break\n                    default:\n                        bound(name, updateVModel)\n                        break\n                }\n            })\n\n\n            if (!rnoduplex.test(elem.type)) {\n                if (elem.type !== \"hidden\") {\n                    bound(\"focus\", function () {\n                        elem.msFocus = true\n                    })\n                    bound(\"blur\", function () {\n                        elem.msFocus = false\n                    })\n                }\n\n                elem.avalonSetter = updateVModel //#765\n                watchValueInTimer(function () {\n                    if (root.contains(elem)) {\n                        if (!elem.msFocus ) {\n                            updateVModel()\n                        }\n                    } else if (!elem.msRetain) {\n                        return false\n                    }\n                })\n            }\n\n        }\n\n        avalon.injectBinding(data)\n        callback.call(elem, elem.value)\n    }\n    duplexBinding.TEXTAREA = duplexBinding.INPUT\n    function getCaret(ctrl) {\n        var start = NaN, end = NaN\n        //https://github.com/RobinHerbots/jquery.inputmask/blob/3.x/js/inputmask.js#L1736\n        if (ctrl.setSelectionRange) {\n            start = ctrl.selectionStart\n            end = ctrl.selectionEnd\n        } else {\n            var range = document.selection.createRange()\n            start = 0 - range.duplicate().moveStart('character', -100000)\n            end = start + range.text.length\n        }\n        return {\n            start: start,\n            end: end\n        }\n    }\n    function setCaret(ctrl, begin, end) {\n        if (!ctrl.value || ctrl.readOnly)\n            return\n        if (ctrl.createTextRange) {//IE6-8\n            var range = ctrl.createTextRange()\n            range.collapse(true)\n            range.moveStart(\"character\", begin)\n            range.select()\n        } else {\n            ctrl.selectionStart = begin\n            ctrl.selectionEnd = end\n        }\n    }\n    duplexBinding.SELECT = function(element, evaluator, data) {\n        var $elem = avalon(element)\n\n        function updateVModel() {\n            if ($elem.data(\"duplexObserve\") !== false) {\n                var val = $elem.val() //字符串或字符串数组\n                if (Array.isArray(val)) {\n                    val = val.map(function(v) {\n                        return data.pipe(v, data, \"get\")\n                    })\n                } else {\n                    val = data.pipe(val, data, \"get\")\n                }\n                if (val + \"\" !== element.oldValue) {\n                    evaluator(val)\n                }\n                data.changed.call(element, val, data)\n            }\n        }\n        data.handler = function() {\n            var val = evaluator()\n            val = val && val.$model || val\n            if (Array.isArray(val)) {\n                if (!element.multiple) {\n                    log(\"ms-duplex在<select multiple=true>上要求对应一个数组\")\n                }\n            } else {\n                if (element.multiple) {\n                    log(\"ms-duplex在<select multiple=false>不能对应一个数组\")\n                }\n            }\n            //必须变成字符串后才能比较\n            val = Array.isArray(val) ? val.map(String) : val + \"\"\n            if (val + \"\" !== element.oldValue) {\n                $elem.val(val)\n                element.oldValue = val + \"\"\n            }\n        }\n        data.bound(\"change\", updateVModel)\n        element.msCallback = function() {\n            avalon.injectBinding(data)\n            data.changed.call(element, evaluator(), data)\n        }\n    }\n// bindingHandlers.html 定义在if.js\n    bindingExecutors.html = function (val, elem, data) {\n        var isHtmlFilter = elem.nodeType !== 1\n        var parent = isHtmlFilter ? elem.parentNode : elem\n        if (!parent)\n            return\n        val = val == null ? \"\" : val\n        if (data.oldText !== val) {\n            data.oldText = val\n        } else {\n            return\n        }\n        if (elem.nodeType === 3) {\n            var signature = generateID(\"html\")\n            parent.insertBefore(DOC.createComment(signature), elem)\n            data.element = DOC.createComment(signature + \":end\")\n            parent.replaceChild(data.element, elem)\n            elem = data.element\n        }\n        if (typeof val !== \"object\") {//string, number, boolean\n            var fragment = avalon.parseHTML(String(val))\n        } else if (val.nodeType === 11) { //将val转换为文档碎片\n            fragment = val\n        } else if (val.nodeType === 1 || val.item) {\n            var nodes = val.nodeType === 1 ? val.childNodes : val.item\n            fragment = avalonFragment.cloneNode(true)\n            while (nodes[0]) {\n                fragment.appendChild(nodes[0])\n            }\n        }\n\n        nodes = avalon.slice(fragment.childNodes)\n        //插入占位符, 如果是过滤器,需要有节制地移除指定的数量,如果是html指令,直接清空\n        if (isHtmlFilter) {\n            var endValue = elem.nodeValue.slice(0, -4)\n            while (true) {\n                var node = elem.previousSibling\n                if (!node || node.nodeType === 8 && node.nodeValue === endValue) {\n                    break\n                } else {\n                    parent.removeChild(node)\n                }\n            }\n            parent.insertBefore(fragment, elem)\n        } else {\n            avalon.clearHTML(elem).appendChild(fragment)\n        }\n        scanNodeArray(nodes, data.vmodels)\n    }\n    bindingHandlers[\"if\"] =\n        bindingHandlers.data =\n            bindingHandlers.text =\n                bindingHandlers.html =\n                    function(data, vmodels) {\n                        parseExprProxy(data.value, vmodels, data)\n                    }\n\n    bindingExecutors[\"if\"] = function(val, elem, data) {\n        try {\n            if(!elem.parentNode) return\n        } catch(e) {return}\n        if (val) { //插回DOM树\n            if (elem.nodeType === 8) {\n                elem.parentNode.replaceChild(data.template, elem)\n                elem.ifRemove = null\n                //   animate.enter(data.template, elem.parentNode)\n                elem = data.element = data.template //这时可能为null\n            }\n            if (elem.getAttribute(data.name)) {\n                elem.removeAttribute(data.name)\n                scanAttr(elem, data.vmodels)\n            }\n            data.rollback = null\n        } else { //移出DOM树，并用注释节点占据原位置\n            if (elem.nodeType === 1) {\n                var node = data.element = DOC.createComment(\"ms-if\")\n                elem.parentNode.replaceChild(node, elem)\n                elem.ifRemove = node\n                //     animate.leave(elem, node.parentNode, node)\n                data.template = elem //元素节点\n                ifGroup.appendChild(elem)\n                data.rollback = function() {\n                    if (elem.parentNode === ifGroup) {\n                        ifGroup.removeChild(elem)\n                    }\n                }\n            }\n        }\n    }\n//ms-important绑定已经在scanTag 方法中实现\n//ms-include绑定已由ms-attr绑定实现\n\n    var rdash = /\\(([^)]*)\\)/\n    bindingHandlers.on = function(data, vmodels) {\n        var value = data.value\n        data.type = \"on\"\n        var eventType = data.param.replace(/-\\d+$/, \"\") // ms-on-mousemove-10\n        if (typeof bindingHandlers.on[eventType + \"Hook\"] === \"function\") {\n            bindingHandlers.on[eventType + \"Hook\"](data)\n        }\n        if (value.indexOf(\"(\") > 0 && value.indexOf(\")\") > -1) {\n            var matched = (value.match(rdash) || [\"\", \"\"])[1].trim()\n            if (matched === \"\" || matched === \"$event\") { // aaa() aaa($event)当成aaa处理\n                value = value.replace(rdash, \"\")\n            }\n        }\n        parseExprProxy(value, vmodels, data)\n    }\n\n    bindingExecutors.on = function(callback, elem, data) {\n        callback = function(e) {\n            var fn = data.evaluator || noop\n            return fn.apply(this, data.args.concat(e))\n        }\n        var eventType = data.param.replace(/-\\d+$/, \"\") // ms-on-mousemove-10\n        if (eventType === \"scan\") {\n            callback.call(elem, {\n                type: eventType\n            })\n        } else if (typeof data.specialBind === \"function\") {\n            data.specialBind(elem, callback)\n        } else {\n            var removeFn = avalon.bind(elem, eventType, callback)\n        }\n        data.rollback = function() {\n            if (typeof data.specialUnbind === \"function\") {\n                data.specialUnbind()\n            } else {\n                avalon.unbind(elem, eventType, removeFn)\n            }\n        }\n    }\n    bindingHandlers.repeat = function (data, vmodels) {\n        var type = data.type\n        parseExprProxy(data.value, vmodels, data, 1)\n        data.proxies = []\n        var freturn = false\n        try {\n            var $repeat = data.$repeat = data.evaluator.apply(0, data.args || [])\n            var xtype = avalon.type($repeat)\n            if (xtype !== \"object\" && xtype !== \"array\") {\n                freturn = true\n                avalon.log(\"warning:\" + data.value + \"只能是对象或数组\")\n            } else {\n                data.xtype = xtype\n            }\n        } catch (e) {\n            freturn = true\n        }\n        var arr = data.value.split(\".\") || []\n        if (arr.length > 1) {\n            arr.pop()\n            var n = arr[0]\n            for (var i = 0, v; v = vmodels[i++]; ) {\n                if (v && v.hasOwnProperty(n)) {\n                    var events = v[n].$events || {}\n                    events[subscribers] = events[subscribers] || []\n                    events[subscribers].push(data)\n                    break\n                }\n            }\n        }\n\n        var oldHandler = data.handler\n        data.handler = noop\n        avalon.injectBinding(data)\n        data.handler = oldHandler\n\n        var elem = data.element\n        if (elem.nodeType === 1) {\n            elem.removeAttribute(data.name)\n            data.sortedCallback = getBindingCallback(elem, \"data-with-sorted\", vmodels)\n            data.renderedCallback = getBindingCallback(elem, \"data-\" + type + \"-rendered\", vmodels)\n            var signature = generateID(type)\n            var start = DOC.createComment(signature)\n            var end = DOC.createComment(signature + \":end\")\n            data.signature = signature\n            data.template = avalonFragment.cloneNode(false)\n            if (type === \"repeat\") {\n                var parent = elem.parentNode\n                parent.replaceChild(end, elem)\n                parent.insertBefore(start, end)\n                data.template.appendChild(elem)\n            } else {\n                while (elem.firstChild) {\n                    data.template.appendChild(elem.firstChild)\n                }\n                elem.appendChild(start)\n                elem.appendChild(end)\n            }\n            data.element = end\n            data.handler = bindingExecutors.repeat\n            data.rollback = function () {\n                var elem = data.element\n                if (!elem)\n                    return\n                data.handler(\"clear\")\n            }\n        }\n\n        if (freturn) {\n            return\n        }\n\n        data.$outer = {}\n        var check0 = \"$key\"\n        var check1 = \"$val\"\n        if (Array.isArray($repeat)) {\n            check0 = \"$first\"\n            check1 = \"$last\"\n        }\n\n        for (i = 0; v = vmodels[i++]; ) {\n            if (v.hasOwnProperty(check0) && v.hasOwnProperty(check1)) {\n                data.$outer = v\n                break\n            }\n        }\n        var $events = $repeat.$events\n        var $list = ($events || {})[subscribers]\n        injectDependency($list, data)\n        if (xtype === \"object\") {\n            data.handler(\"append\")\n        } else if ($repeat.length) {\n            data.handler(\"add\", 0, $repeat.length)\n        }\n    }\n\n    bindingExecutors.repeat = function (method, pos, el) {\n        var data = this\n        if (!method && data.xtype) {\n            var old = data.$repeat\n            var neo = data.evaluator.apply(0, data.args || [])\n\n            if (data.xtype === \"array\") {\n                if (old.length === neo.length) {\n                    if (old !== neo && old.length > 0) {\n                        bindingExecutors.repeat.call(this, 'clear', pos, el)\n                    }\n                    else {\n                        return\n                    }\n                }\n                method = \"add\"\n                pos = 0\n                data.$repeat = neo\n                el = neo.length\n            } else {\n                if (keysVM(old).join(\";;\") === keysVM(neo).join(\";;\")) {\n                    return\n                }\n                method = \"append\"\n                data.$repeat = neo\n            }\n        }\n        if (method) {\n            var start, fragment\n            var end = data.element\n            var comments = getComments(data)\n            var parent = end.parentNode\n            var proxies = data.proxies\n            var transation = avalonFragment.cloneNode(false)\n            switch (method) {\n                case \"add\": //在pos位置后添加el数组（pos为插入位置,el为要插入的个数）\n                    var n = pos + el\n                    var fragments = []\n                    for (var i = pos; i < n; i++) {\n                        var proxy = eachProxyAgent(i, data)\n                        proxies.splice(i, 0, proxy)\n                        shimController(data, transation, proxy, fragments)\n                    }\n                    parent.insertBefore(transation, comments[pos] || end)\n                    for (i = 0; fragment = fragments[i++]; ) {\n                        scanNodeArray(fragment.nodes, fragment.vmodels)\n                        fragment.nodes = fragment.vmodels = null\n                    }\n\n                    break\n                case \"del\": //将pos后的el个元素删掉(pos, el都是数字)\n                    sweepNodes(comments[pos], comments[pos + el] || end)\n                    var removed = proxies.splice(pos, el)\n                    recycleProxies(removed, \"each\")\n                    break\n                case \"clear\":\n                    start = comments[0]\n                    if (start) {\n                        sweepNodes(start, end)\n                        if (data.xtype === \"object\") {\n                            parent.insertBefore(start, end)\n                        }else{\n                            recycleProxies(proxies, \"each\")\n                        }\n                    }\n                    break\n                case \"move\":\n                    start = comments[0]\n                    if (start) {\n                        var signature = start.nodeValue\n                        var rooms = []\n                        var room = [],\n                            node\n                        sweepNodes(start, end, function () {\n                            room.unshift(this)\n                            if (this.nodeValue === signature) {\n                                rooms.unshift(room)\n                                room = []\n                            }\n                        })\n                        sortByIndex(rooms, pos)\n                        sortByIndex(proxies, pos)\n                        while (room = rooms.shift()) {\n                            while (node = room.shift()) {\n                                transation.appendChild(node)\n                            }\n                        }\n                        parent.insertBefore(transation, end)\n                    }\n                    break\n                case \"index\": //将proxies中的第pos个起的所有元素重新索引\n                    var last = proxies.length - 1\n                    for (; el = proxies[pos]; pos++) {\n                        el.$index = pos\n                        el.$first = pos === 0\n                        el.$last = pos === last\n                    }\n                    return\n                case \"set\": //将proxies中的第pos个元素的VM设置为el（pos为数字，el任意）\n                    proxy = proxies[pos]\n                    if (proxy) {\n                        fireDependencies(proxy.$events[data.param || \"el\"])\n                    }\n                    break\n                case \"append\":\n                    var object = data.$repeat //原来第2参数， 被循环对象\n                    var pool = Array.isArray(proxies) ||!proxies ?  {}: proxies   //代理对象组成的hash\n                    data.proxies = pool\n                    var keys = []\n                    fragments = []\n                    for (var key in pool) {\n                        if (!object.hasOwnProperty(key)) {\n                            proxyRecycler(pool[key], withProxyPool) //去掉之前的代理VM\n                            delete(pool[key])\n                        }\n                    }\n                    for (key in object) { //得到所有键名\n                        if (object.hasOwnProperty(key) && key !== \"hasOwnProperty\") {\n                            keys.push(key)\n                        }\n                    }\n                    if (data.sortedCallback) { //如果有回调，则让它们排序\n                        var keys2 = data.sortedCallback.call(parent, keys)\n                        if (keys2 && Array.isArray(keys2) && keys2.length) {\n                            keys = keys2\n                        }\n                    }\n                    for (i = 0; key = keys[i++]; ) {\n                        if (key !== \"hasOwnProperty\") {\n                            pool[key] = withProxyAgent(pool[key], key, data)\n                            shimController(data, transation, pool[key], fragments)\n                        }\n                    }\n\n                    parent.insertBefore(transation, end)\n                    for (i = 0; fragment = fragments[i++]; ) {\n                        scanNodeArray(fragment.nodes, fragment.vmodels)\n                        fragment.nodes = fragment.vmodels = null\n                    }\n                    break\n            }\n            if (!data.$repeat || data.$repeat.hasOwnProperty(\"$lock\")) //IE6-8 VBScript对象会报错, 有时候data.$repeat不存在\n                return\n            if (method === \"clear\")\n                method = \"del\"\n            var callback = data.renderedCallback || noop,\n                args = arguments\n            if (parent.oldValue && parent.tagName === \"SELECT\") { //fix #503\n                avalon(parent).val(parent.oldValue.split(\",\"))\n            }\n            callback.apply(parent, args)\n        }\n    }\n    \"with,each\".replace(rword, function (name) {\n        bindingHandlers[name] = bindingHandlers.repeat\n    })\n\n    function shimController(data, transation, proxy, fragments) {\n        var content = data.template.cloneNode(true)\n        var nodes = avalon.slice(content.childNodes)\n        content.insertBefore(DOC.createComment(data.signature), content.firstChild)\n        transation.appendChild(content)\n        var nv = [proxy].concat(data.vmodels)\n        var fragment = {\n            nodes: nodes,\n            vmodels: nv\n        }\n        fragments.push(fragment)\n    }\n\n    function getComments(data) {\n        var ret = []\n        var nodes = data.element.parentNode.childNodes\n        for (var i = 0, node; node = nodes[i++]; ) {\n            if (node.nodeValue === data.signature) {\n                ret.push(node)\n            } else if (node.nodeValue === data.signature + \":end\") {\n                break\n            }\n        }\n        return ret\n    }\n\n\n//移除掉start与end之间的节点(保留end)\n    function sweepNodes(start, end, callback) {\n        while (true) {\n            var node = end.previousSibling\n            if (!node)\n                break\n            node.parentNode.removeChild(node)\n            callback && callback.call(node)\n            if (node === start) {\n                break\n            }\n        }\n    }\n\n// 为ms-each,ms-with, ms-repeat会创建一个代理VM，\n// 通过它们保持一个下上文，让用户能调用$index,$first,$last,$remove,$key,$val,$outer等属性与方法\n// 所有代理VM的产生,消费,收集,存放通过xxxProxyFactory,xxxProxyAgent, recycleProxies,xxxProxyPool实现\n    var withProxyPool = []\n    function withProxyFactory() {\n        var proxy = modelFactory({\n            $key: \"\",\n            $outer: {},\n            $host: {},\n            $val: {\n                get: function () {\n                    return this.$host[this.$key]\n                },\n                set: function (val) {\n                    this.$host[this.$key] = val\n                }\n            }\n        }, {\n            $val: 1\n        })\n        proxy.$id = generateID(\"$proxy$with\")\n        return proxy\n    }\n\n    function withProxyAgent(proxy, key, data) {\n        proxy = proxy || withProxyPool.pop()\n        if (!proxy) {\n            proxy = withProxyFactory()\n        } else {\n            proxy.$reinitialize()\n        }\n        var host = data.$repeat\n        proxy.$key = key\n\n        proxy.$host = host\n        proxy.$outer = data.$outer\n        if (host.$events) {\n            proxy.$events.$val = host.$events[key]\n        } else {\n            proxy.$events = {}\n        }\n        return proxy\n    }\n\n\n    function  recycleProxies(proxies) {\n        eachProxyRecycler(proxies)\n    }\n    function eachProxyRecycler(proxies) {\n        proxies.forEach(function (proxy) {\n            proxyRecycler(proxy, eachProxyPool)\n        })\n        proxies.length = 0\n    }\n\n\n    var eachProxyPool = []\n    function eachProxyFactory(name) {\n        var source = {\n            $host: [],\n            $outer: {},\n            $index: 0,\n            $first: false,\n            $last: false,\n            $remove: avalon.noop\n        }\n        source[name] = {\n            get: function () {\n                var e = this.$events\n                var array = e.$index\n                e.$index = e[name] //#817 通过$index为el收集依赖\n                try {\n                    return this.$host[this.$index]\n                } finally {\n                    e.$index = array\n                }\n            },\n            set: function (val) {\n                try {\n                    var e = this.$events\n                    var array = e.$index\n                    e.$index = []\n                    this.$host.set(this.$index, val)\n                } finally {\n                    e.$index = array\n                }\n            }\n        }\n        var second = {\n            $last: 1,\n            $first: 1,\n            $index: 1\n        }\n        var proxy = modelFactory(source, second)\n        proxy.$id = generateID(\"$proxy$each\")\n        return proxy\n    }\n\n    function eachProxyAgent(index, data) {\n        var param = data.param || \"el\",\n            proxy\n        for (var i = 0, n = eachProxyPool.length; i < n; i++) {\n            var candidate = eachProxyPool[i]\n            if (candidate && candidate.hasOwnProperty(param)) {\n                proxy = candidate\n                eachProxyPool.splice(i, 1)\n            }\n        }\n        if (!proxy) {\n            proxy = eachProxyFactory(param)\n        }\n        var host = data.$repeat\n        var last = host.length - 1\n        proxy.$index = index\n        proxy.$first = index === 0\n        proxy.$last = index === last\n        proxy.$host = host\n        proxy.$outer = data.$outer\n        proxy.$remove = function () {\n            return host.removeAt(proxy.$index)\n        }\n        return proxy\n    }\n\n\n    function proxyRecycler(proxy, proxyPool) {\n        for (var i in proxy.$events) {\n            var arr = proxy.$events[i]\n            if (Array.isArray(arr)) {\n                arr.forEach(function (data) {\n                    if (typeof data === \"object\")\n                        disposeData(data)\n                })// jshint ignore:line\n                arr.length = 0\n            }\n        }\n        proxy.$host = proxy.$outer = {}\n        if (proxyPool.unshift(proxy) > kernel.maxRepeatSize) {\n            proxyPool.pop()\n        }\n    }\n\n    /*********************************************************************\n     *                         各种指令                                  *\n     **********************************************************************/\n//ms-skip绑定已经在scanTag 方法中实现\n// bindingHandlers.text 定义在if.js\n    bindingExecutors.text = function(val, elem) {\n        val = val == null ? \"\" : val //不在页面上显示undefined null\n        if (elem.nodeType === 3) { //绑定在文本节点上\n            try { //IE对游离于DOM树外的节点赋值会报错\n                elem.data = val\n            } catch (e) {}\n        } else { //绑定在特性节点上\n            if (\"textContent\" in elem) {\n                elem.textContent = val\n            } else {\n                elem.innerText = val\n            }\n        }\n    }\n    function parseDisplay(nodeName, val) {\n        //用于取得此类标签的默认display值\n        var key = \"_\" + nodeName\n        if (!parseDisplay[key]) {\n            var node = DOC.createElement(nodeName)\n            root.appendChild(node)\n            if (W3C) {\n                val = getComputedStyle(node, null).display\n            } else {\n                val = node.currentStyle.display\n            }\n            root.removeChild(node)\n            parseDisplay[key] = val\n        }\n        return parseDisplay[key]\n    }\n\n    avalon.parseDisplay = parseDisplay\n\n    bindingHandlers.visible = function (data, vmodels) {\n        parseExprProxy(data.value, vmodels, data)\n    }\n\n    bindingExecutors.visible = function (val, elem, binding) {\n        if (val) {\n            elem.style.display = binding.display || \"\"\n            if (avalon(elem).css(\"display\") === \"none\") {\n                elem.style.display = binding.display = parseDisplay(elem.nodeName)\n            }\n        } else {\n            elem.style.display = \"none\"\n        }\n    }\n    bindingHandlers.widget = function(data, vmodels) {\n        var args = data.value.match(rword)\n        var elem = data.element\n        var widget = args[0]\n        var id = args[1]\n        if (!id || id === \"$\") { //没有定义或为$时，取组件名+随机数\n            id = generateID(widget)\n        }\n        var optName = args[2] || widget //没有定义，取组件名\n        var constructor = avalon.ui[widget]\n        if (typeof constructor === \"function\") { //ms-widget=\"tabs,tabsAAA,optname\"\n            vmodels = elem.vmodels || vmodels\n            for (var i = 0, v; v = vmodels[i++];) {\n                if (v.hasOwnProperty(optName) && typeof v[optName] === \"object\") {\n                    var vmOptions = v[optName]\n                    vmOptions = vmOptions.$model || vmOptions\n                    break\n                }\n            }\n            if (vmOptions) {\n                var wid = vmOptions[widget + \"Id\"]\n                if (typeof wid === \"string\") {\n                    log(\"warning!不再支持\" + widget + \"Id\")\n                    id = wid\n                }\n            }\n            //抽取data-tooltip-text、data-tooltip-attr属性，组成一个配置对象\n            var widgetData = avalon.getWidgetData(elem, widget)\n            data.value = [widget, id, optName].join(\",\")\n            data[widget + \"Id\"] = id\n            data.evaluator = noop\n            elem.msData[\"ms-widget-id\"] = id\n            var options = data[widget + \"Options\"] = avalon.mix({}, constructor.defaults, vmOptions || {}, widgetData)\n            elem.removeAttribute(\"ms-widget\")\n            var vmodel = constructor(elem, data, vmodels) || {} //防止组件不返回VM\n            if (vmodel.$id) {\n                avalon.vmodels[id] = vmodel\n                createSignalTower(elem, vmodel)\n                try {\n                    vmodel.$init(function() {\n                        avalon.scan(elem, [vmodel].concat(vmodels))\n                        if (typeof options.onInit === \"function\") {\n                            options.onInit.call(elem, vmodel, options, vmodels)\n                        }\n                    })\n                } catch (e) {log(e)}\n                data.rollback = function() {\n                    try {\n                        vmodel.$remove()\n                        vmodel.widgetElement = null // 放到$remove后边\n                    } catch (e) {}\n                    elem.msData = {}\n                    delete avalon.vmodels[vmodel.$id]\n                }\n                injectDisposeQueue(data, widgetList)\n                if (window.chrome) {\n                    elem.addEventListener(\"DOMNodeRemovedFromDocument\", function() {\n                        setTimeout(rejectDisposeQueue)\n                    })\n                }\n            } else {\n                avalon.scan(elem, vmodels)\n            }\n        } else if (vmodels.length) { //如果该组件还没有加载，那么保存当前的vmodels\n            elem.vmodels = vmodels\n        }\n    }\n    var widgetList = []\n//不存在 bindingExecutors.widget\n    /*********************************************************************\n     *                             自带过滤器                            *\n     **********************************************************************/\n    var rscripts = /<script[^>]*>([\\S\\s]*?)<\\/script\\s*>/gim\n    var ron = /\\s+(on[^=\\s]+)(?:=(\"[^\"]*\"|'[^']*'|[^\\s>]+))?/g\n    var ropen = /<\\w+\\b(?:([\"'])[^\"]*?(\\1)|[^>])*>/ig\n    var rsanitize = {\n        a: /\\b(href)\\=(\"javascript[^\"]*\"|'javascript[^']*')/ig,\n        img: /\\b(src)\\=(\"javascript[^\"]*\"|'javascript[^']*')/ig,\n        form: /\\b(action)\\=(\"javascript[^\"]*\"|'javascript[^']*')/ig\n    }\n    var rsurrogate = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\n    var rnoalphanumeric = /([^\\#-~| |!])/g;\n\n    function numberFormat(number, decimals, point, thousands) {\n        //form http://phpjs.org/functions/number_format/\n        //number\t必需，要格式化的数字\n        //decimals\t可选，规定多少个小数位。\n        //point\t可选，规定用作小数点的字符串（默认为 . ）。\n        //thousands\t可选，规定用作千位分隔符的字符串（默认为 , ），如果设置了该参数，那么所有其他参数都是必需的。\n        number = (number + '')\n            .replace(/[^0-9+\\-Ee.]/g, '')\n        var n = !isFinite(+number) ? 0 : +number,\n            prec = !isFinite(+decimals) ? 3 : Math.abs(decimals),\n            sep = thousands || \",\",\n            dec = point || \".\",\n            s = '',\n            toFixedFix = function(n, prec) {\n                var k = Math.pow(10, prec)\n                return '' + (Math.round(n * k) / k)\n                        .toFixed(prec)\n            }\n        // Fix for IE parseFloat(0.55).toFixed(0) = 0;\n        s = (prec ? toFixedFix(n, prec) : '' + Math.round(n))\n            .split('.')\n        if (s[0].length > 3) {\n            s[0] = s[0].replace(/\\B(?=(?:\\d{3})+(?!\\d))/g, sep)\n        }\n        if ((s[1] || '')\n                .length < prec) {\n            s[1] = s[1] || ''\n            s[1] += new Array(prec - s[1].length + 1)\n                .join('0')\n        }\n        return s.join(dec)\n    }\n\n\n    var filters = avalon.filters = {\n        uppercase: function(str) {\n            return str.toUpperCase()\n        },\n        lowercase: function(str) {\n            return str.toLowerCase()\n        },\n        truncate: function(str, length, truncation) {\n            //length，新字符串长度，truncation，新字符串的结尾的字段,返回新字符串\n            length = length || 30\n            truncation = typeof truncation === \"string\" ?  truncation : \"...\"\n            return str.length > length ? str.slice(0, length - truncation.length) + truncation : String(str)\n        },\n        $filter: function(val) {\n            for (var i = 1, n = arguments.length; i < n; i++) {\n                var array = arguments[i]\n                var fn = avalon.filters[array[0]]\n                if (typeof fn === \"function\") {\n                    var arr = [val].concat(array.slice(1))\n                    val = fn.apply(null, arr)\n                }\n            }\n            return val\n        },\n        camelize: camelize,\n        //https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n        //    <a href=\"javasc&NewLine;ript&colon;alert('XSS')\">chrome</a>\n        //    <a href=\"data:text/html;base64, PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==\">chrome</a>\n        //    <a href=\"jav\tascript:alert('XSS');\">IE67chrome</a>\n        //    <a href=\"jav&#x09;ascript:alert('XSS');\">IE67chrome</a>\n        //    <a href=\"jav&#x0A;ascript:alert('XSS');\">IE67chrome</a>\n        sanitize: function(str) {\n            return str.replace(rscripts, \"\").replace(ropen, function(a, b) {\n                var match = a.toLowerCase().match(/<(\\w+)\\s/)\n                if (match) { //处理a标签的href属性，img标签的src属性，form标签的action属性\n                    var reg = rsanitize[match[1]]\n                    if (reg) {\n                        a = a.replace(reg, function(s, name, value) {\n                            var quote = value.charAt(0)\n                            return name + \"=\" + quote + \"javascript:void(0)\" + quote// jshint ignore:line\n                        })\n                    }\n                }\n                return a.replace(ron, \" \").replace(/\\s+/g, \" \") //移除onXXX事件\n            })\n        },\n        escape: function(str) {\n            //将字符串经过 str 转义得到适合在页面中显示的内容, 例如替换 < 为 &lt\n            return String(str).\n                replace(/&/g, '&amp;').\n                replace(rsurrogate, function(value) {\n                    var hi = value.charCodeAt(0)\n                    var low = value.charCodeAt(1)\n                    return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';'\n                }).\n                replace(rnoalphanumeric, function(value) {\n                    return '&#' + value.charCodeAt(0) + ';'\n                }).\n                replace(/</g, '&lt;').\n                replace(/>/g, '&gt;')\n        },\n        currency: function(amount, symbol, fractionSize) {\n            return (symbol || \"\\uFFE5\") + numberFormat(amount, isFinite(fractionSize) ? fractionSize : 2)\n        },\n        number: numberFormat\n    }\n    /*\n     'yyyy': 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)\n     'yy': 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)\n     'y': 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)\n     'MMMM': Month in year (January-December)\n     'MMM': Month in year (Jan-Dec)\n     'MM': Month in year, padded (01-12)\n     'M': Month in year (1-12)\n     'dd': Day in month, padded (01-31)\n     'd': Day in month (1-31)\n     'EEEE': Day in Week,(Sunday-Saturday)\n     'EEE': Day in Week, (Sun-Sat)\n     'HH': Hour in day, padded (00-23)\n     'H': Hour in day (0-23)\n     'hh': Hour in am/pm, padded (01-12)\n     'h': Hour in am/pm, (1-12)\n     'mm': Minute in hour, padded (00-59)\n     'm': Minute in hour (0-59)\n     'ss': Second in minute, padded (00-59)\n     's': Second in minute (0-59)\n     'a': am/pm marker\n     'Z': 4 digit (+sign) representation of the timezone offset (-1200-+1200)\n     format string can also be one of the following predefined localizable formats:\n\n     'medium': equivalent to 'MMM d, y h:mm:ss a' for en_US locale (e.g. Sep 3, 2010 12:05:08 pm)\n     'short': equivalent to 'M/d/yy h:mm a' for en_US locale (e.g. 9/3/10 12:05 pm)\n     'fullDate': equivalent to 'EEEE, MMMM d,y' for en_US locale (e.g. Friday, September 3, 2010)\n     'longDate': equivalent to 'MMMM d, y' for en_US locale (e.g. September 3, 2010\n     'mediumDate': equivalent to 'MMM d, y' for en_US locale (e.g. Sep 3, 2010)\n     'shortDate': equivalent to 'M/d/yy' for en_US locale (e.g. 9/3/10)\n     'mediumTime': equivalent to 'h:mm:ss a' for en_US locale (e.g. 12:05:08 pm)\n     'shortTime': equivalent to 'h:mm a' for en_US locale (e.g. 12:05 pm)\n     */\n    new function() {// jshint ignore:line\n        function toInt(str) {\n            return parseInt(str, 10) || 0\n        }\n\n        function padNumber(num, digits, trim) {\n            var neg = \"\"\n            if (num < 0) {\n                neg = '-'\n                num = -num\n            }\n            num = \"\" + num\n            while (num.length < digits)\n                num = \"0\" + num\n            if (trim)\n                num = num.substr(num.length - digits)\n            return neg + num\n        }\n\n        function dateGetter(name, size, offset, trim) {\n            return function(date) {\n                var value = date[\"get\" + name]()\n                if (offset > 0 || value > -offset)\n                    value += offset\n                if (value === 0 && offset === -12) {\n                    value = 12\n                }\n                return padNumber(value, size, trim)\n            }\n        }\n\n        function dateStrGetter(name, shortForm) {\n            return function(date, formats) {\n                var value = date[\"get\" + name]()\n                var get = (shortForm ? (\"SHORT\" + name) : name).toUpperCase()\n                return formats[get][value]\n            }\n        }\n\n        function timeZoneGetter(date) {\n            var zone = -1 * date.getTimezoneOffset()\n            var paddedZone = (zone >= 0) ? \"+\" : \"\"\n            paddedZone += padNumber(Math[zone > 0 ? \"floor\" : \"ceil\"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)\n            return paddedZone\n        }\n        //取得上午下午\n\n        function ampmGetter(date, formats) {\n            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]\n        }\n        var DATE_FORMATS = {\n            yyyy: dateGetter(\"FullYear\", 4),\n            yy: dateGetter(\"FullYear\", 2, 0, true),\n            y: dateGetter(\"FullYear\", 1),\n            MMMM: dateStrGetter(\"Month\"),\n            MMM: dateStrGetter(\"Month\", true),\n            MM: dateGetter(\"Month\", 2, 1),\n            M: dateGetter(\"Month\", 1, 1),\n            dd: dateGetter(\"Date\", 2),\n            d: dateGetter(\"Date\", 1),\n            HH: dateGetter(\"Hours\", 2),\n            H: dateGetter(\"Hours\", 1),\n            hh: dateGetter(\"Hours\", 2, -12),\n            h: dateGetter(\"Hours\", 1, -12),\n            mm: dateGetter(\"Minutes\", 2),\n            m: dateGetter(\"Minutes\", 1),\n            ss: dateGetter(\"Seconds\", 2),\n            s: dateGetter(\"Seconds\", 1),\n            sss: dateGetter(\"Milliseconds\", 3),\n            EEEE: dateStrGetter(\"Day\"),\n            EEE: dateStrGetter(\"Day\", true),\n            a: ampmGetter,\n            Z: timeZoneGetter\n        }\n        var rdateFormat = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/\n        var raspnetjson = /^\\/Date\\((\\d+)\\)\\/$/\n        filters.date = function(date, format) {\n            var locate = filters.date.locate,\n                text = \"\",\n                parts = [],\n                fn, match\n            format = format || \"mediumDate\"\n            format = locate[format] || format\n            if (typeof date === \"string\") {\n                if (/^\\d+$/.test(date)) {\n                    date = toInt(date)\n                } else if (raspnetjson.test(date)) {\n                    date = +RegExp.$1\n                } else {\n                    var trimDate = date.trim()\n                    var dateArray = [0, 0, 0, 0, 0, 0, 0]\n                    var oDate = new Date(0)\n                    //取得年月日\n                    trimDate = trimDate.replace(/^(\\d+)\\D(\\d+)\\D(\\d+)/, function(_, a, b, c) {\n                        var array = c.length === 4 ? [c, a, b] : [a, b, c]\n                        dateArray[0] = toInt(array[0])     //年\n                        dateArray[1] = toInt(array[1]) - 1 //月\n                        dateArray[2] = toInt(array[2])     //日\n                        return \"\"\n                    })\n                    var dateSetter = oDate.setFullYear\n                    var timeSetter = oDate.setHours\n                    trimDate = trimDate.replace(/[T\\s](\\d+):(\\d+):?(\\d+)?\\.?(\\d)?/, function(_, a, b, c, d) {\n                        dateArray[3] = toInt(a) //小时\n                        dateArray[4] = toInt(b) //分钟\n                        dateArray[5] = toInt(c) //秒\n                        if (d) {                //毫秒\n                            dateArray[6] = Math.round(parseFloat(\"0.\" + d) * 1000)\n                        }\n                        return \"\"\n                    })\n                    var tzHour = 0\n                    var tzMin = 0\n                    trimDate = trimDate.replace(/Z|([+-])(\\d\\d):?(\\d\\d)/, function(z, symbol, c, d) {\n                        dateSetter = oDate.setUTCFullYear\n                        timeSetter = oDate.setUTCHours\n                        if (symbol) {\n                            tzHour = toInt(symbol + c)\n                            tzMin = toInt(symbol + d)\n                        }\n                        return \"\"\n                    })\n\n                    dateArray[3] -= tzHour\n                    dateArray[4] -= tzMin\n                    dateSetter.apply(oDate, dateArray.slice(0, 3))\n                    timeSetter.apply(oDate, dateArray.slice(3))\n                    date = oDate\n                }\n            }\n            if (typeof date === \"number\") {\n                date = new Date(date)\n            }\n            if (avalon.type(date) !== \"date\") {\n                return\n            }\n            while (format) {\n                match = rdateFormat.exec(format)\n                if (match) {\n                    parts = parts.concat(match.slice(1))\n                    format = parts.pop()\n                } else {\n                    parts.push(format)\n                    format = null\n                }\n            }\n            parts.forEach(function(value) {\n                fn = DATE_FORMATS[value]\n                text += fn ? fn(date, locate) : value.replace(/(^'|'$)/g, \"\").replace(/''/g, \"'\")\n            })\n            return text\n        }\n        var locate = {\n            AMPMS: {\n                0: \"上午\",\n                1: \"下午\"\n            },\n            DAY: {\n                0: \"星期日\",\n                1: \"星期一\",\n                2: \"星期二\",\n                3: \"星期三\",\n                4: \"星期四\",\n                5: \"星期五\",\n                6: \"星期六\"\n            },\n            MONTH: {\n                0: \"1月\",\n                1: \"2月\",\n                2: \"3月\",\n                3: \"4月\",\n                4: \"5月\",\n                5: \"6月\",\n                6: \"7月\",\n                7: \"8月\",\n                8: \"9月\",\n                9: \"10月\",\n                10: \"11月\",\n                11: \"12月\"\n            },\n            SHORTDAY: {\n                \"0\": \"周日\",\n                \"1\": \"周一\",\n                \"2\": \"周二\",\n                \"3\": \"周三\",\n                \"4\": \"周四\",\n                \"5\": \"周五\",\n                \"6\": \"周六\"\n            },\n            fullDate: \"y年M月d日EEEE\",\n            longDate: \"y年M月d日\",\n            medium: \"yyyy-M-d H:mm:ss\",\n            mediumDate: \"yyyy-M-d\",\n            mediumTime: \"H:mm:ss\",\n            \"short\": \"yy-M-d ah:mm\",\n            shortDate: \"yy-M-d\",\n            shortTime: \"ah:mm\"\n        }\n        locate.SHORTMONTH = locate.MONTH\n        filters.date.locate = locate\n    }// jshint ignore:line\n    /*********************************************************************\n     *                     END                                  *\n     **********************************************************************/\n    new function () {\n        avalon.config({\n            loader: false\n        })\n        var fns = [], loaded = DOC.readyState === \"complete\", fn\n        function flush(f) {\n            loaded = 1\n            while (f = fns.shift())\n                f()\n        }\n\n        avalon.bind(DOC, \"DOMContentLoaded\", fn = function () {\n            avalon.unbind(DOC, \"DOMContentLoaded\", fn)\n            flush()\n        })\n\n        var id = setInterval(function () {\n            if (document.readyState === \"complete\" && document.body) {\n                clearInterval(id)\n                flush()\n            }\n        }, 50)\n\n        avalon.ready = function (fn) {\n            loaded ? fn(avalon) : fns.push(fn)\n        }\n        avalon.ready(function () {\n            avalon.scan(DOC.body)\n        })\n    }\n\n\n// Register as a named AMD module, since avalon can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase avalon is used because AMD module names are\n// derived from file names, and Avalon is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of avalon, it will work.\n\n// Note that for maximum portability, libraries that are not avalon should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. avalon is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n    if (typeof define === \"function\" && define.amd) {\n        define(\"avalon\", [], function() {\n            return avalon\n        })\n    }\n// Map over avalon in case of overwrite\n    var _avalon = window.avalon\n    avalon.noConflict = function(deep) {\n        if (deep && window.avalon === avalon) {\n            window.avalon = _avalon\n        }\n        return avalon\n    }\n// Expose avalon identifiers, even in AMD\n// and CommonJS for browser emulators\n    if (noGlobal === void 0) {\n        window.avalon = avalon\n    }\n\n    return avalon\n\n}));\n\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvYXZhbG9uLmpzP2NiMGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwwQkFBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxFQUFFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0Esc0RBQXNELG9CQUFvQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUZBQXFGO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxtQkFBbUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZUFBZTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxlQUFlLElBQUk7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHdCQUF3QjtBQUNsRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsU0FBUztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQSxzREFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE9BQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMEJBQTBCLDZCQUE2QjtBQUNwRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3QkFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtCQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0EsYUFBYTtBQUNiLHdEQUF3RDtBQUN4RDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxrQ0FBa0M7QUFDM0Msc0NBQXNDLHVCQUF1QjtBQUM3RDtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQSxzQkFBc0I7QUFDdEIsdUJBQXVCLEdBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbURBQW1EO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCLDBDQUEwQyxtREFBbUQ7QUFDN0Y7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEdBQUc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1CQUFtQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPLEdBQUc7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCLDZDQUE2QztBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsNkJBQTZCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBLHNDQUFzQztBQUN0QztBQUNBLDRGQUE0RjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxHQUFHLEdBQUcsR0FBRztBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBLFNBQVMsZ0NBQWdDO0FBQ3pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYix3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJCQUEyQjtBQUMxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwyQkFBMkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLHVDQUF1QztBQUN6RztBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVMsMkJBQTJCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxFQUFFO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNDQUFzQyxXQUFXO0FBQ2pELHNDQUFzQztBQUN0QyxnREFBZ0Q7QUFDaEQsZ0NBQWdDLHFCQUFxQjtBQUNyRCxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRjtBQUMzRixpQkFBaUI7QUFDakI7QUFDQSwwREFBMEQ7QUFDMUQsaUJBQWlCO0FBQ2pCLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUMiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IOWPuOW+kuato+e+jiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9ydWJ5bG91dnJlL1xuIGh0dHBzOi8vZ2l0aHViLmNvbS9SdWJ5TG91dnJlXG4gaHR0cDovL3dlaWJvLmNvbS9qc2xvdXZyZS9cblxuIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuIGF2YWxvbi5zaGltLmpzKOaXoOWKoOi9veWZqOeJiOacrCkgMS40LjcuMSBidWlsdCBpbiAyMDE1LjExLjE5XG4gc3VwcG9ydCBJRTYrIGFuZCBvdGhlciBicm93c2Vyc1xuID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbihmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcblxuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG4gICAgICAgIC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBhdmFsb24uXG4gICAgICAgIC8vIEZvciBlbnZpcm9ubWVudHMgdGhhdCBkbyBub3QgaGF2ZSBhIGB3aW5kb3dgIHdpdGggYSBgZG9jdW1lbnRgXG4gICAgICAgIC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuICAgICAgICAvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuICAgICAgICAvLyBlLmcuIHZhciBhdmFsb24gPSByZXF1aXJlKFwiYXZhbG9uXCIpKHdpbmRvdyk7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID8gZmFjdG9yeShnbG9iYWwsIHRydWUpIDogZnVuY3Rpb24odykge1xuICAgICAgICAgICAgaWYgKCF3LmRvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXZhbG9uIHJlcXVpcmVzIGEgd2luZG93IHdpdGggYSBkb2N1bWVudFwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhY3RvcnkodylcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZhY3RvcnkoZ2xvYmFsKVxuICAgIH1cblxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcbn0odHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHRoaXMsIGZ1bmN0aW9uKHdpbmRvdywgbm9HbG9iYWwpe1xuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqICAgICAgICAgICAgICAgICAgICDlhajlsYDlj5jph4/lj4rmlrnms5UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBleHBvc2UgPSBuZXcgRGF0ZSgpIC0gMFxuLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzcyOTAwODYvamF2YXNjcmlwdC11c2Utc3RyaWN0LWFuZC1uaWNrcy1maW5kLWdsb2JhbC1mdW5jdGlvblxuICAgIHZhciBET0MgPSB3aW5kb3cuZG9jdW1lbnRcbiAgICB2YXIgaGVhZCA9IERPQy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0gLy9IRUFE5YWD57SgXG4gICAgdmFyIGlmR3JvdXAgPSBoZWFkLmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYXZhbG9uXCIpLCBoZWFkLmZpcnN0Q2hpbGQpIC8v6YG/5YWNSUU2IGJhc2XmoIfnrb5CVUdcbiAgICBpZkdyb3VwLmlubmVySFRNTCA9IFwiWDxzdHlsZSBpZD0nYXZhbG9uU3R5bGUnPi5hdmFsb25IaWRleyBkaXNwbGF5OiBub25lIWltcG9ydGFudCB9PC9zdHlsZT5cIlxuICAgIGlmR3JvdXAuc2V0QXR0cmlidXRlKFwibXMtc2tpcFwiLCBcIjFcIilcbiAgICBpZkdyb3VwLmNsYXNzTmFtZSA9IFwiYXZhbG9uSGlkZVwiXG4gICAgdmFyIHJuYXRpdmUgPSAvXFxbbmF0aXZlIGNvZGVcXF0vIC8v5Yik5a6a5piv5ZCm5Y6f55Sf5Ye95pWwXG4gICAgZnVuY3Rpb24gbG9nKCkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgYXZhbG9uLmNvbmZpZy5kZWJ1Zykge1xuICAgICAgICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84Nzg1NjI0L2hvdy10by1zYWZlbHktd3JhcC1jb25zb2xlLWxvZ1xuICAgICAgICAgICAgRnVuY3Rpb24uYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICB2YXIgc3Vic2NyaWJlcnMgPSBcIiRcIiArIGV4cG9zZVxuICAgIHZhciBzdG9wUmVwZWF0QXNzaWduID0gZmFsc2VcbiAgICB2YXIgcndvcmQgPSAvW14sIF0rL2cgLy/liIflibLlrZfnrKbkuLLkuLrkuIDkuKrkuKrlsI/lnZfvvIzku6XnqbrmoLzmiJbosYblj7fliIblvIDlroPku6zvvIznu5PlkIhyZXBsYWNl5a6e546w5a2X56ym5Liy55qEZm9yRWFjaFxuICAgIHZhciByY29tcGxleFR5cGUgPSAvXig/Om9iamVjdHxhcnJheSkkL1xuICAgIHZhciByc3ZnID0gL15cXFtvYmplY3QgU1ZHXFx3KkVsZW1lbnRcXF0kL1xuICAgIHZhciByd2luZG93ID0gL15cXFtvYmplY3QgKD86V2luZG93fERPTVdpbmRvd3xnbG9iYWwpXFxdJC9cbiAgICB2YXIgb3Byb3RvID0gT2JqZWN0LnByb3RvdHlwZVxuICAgIHZhciBvaGFzT3duID0gb3Byb3RvLmhhc093blByb3BlcnR5XG4gICAgdmFyIHNlcmlhbGl6ZSA9IG9wcm90by50b1N0cmluZ1xuICAgIHZhciBhcCA9IEFycmF5LnByb3RvdHlwZVxuICAgIHZhciBhc2xpY2UgPSBhcC5zbGljZVxuICAgIHZhciBXM0MgPSB3aW5kb3cuZGlzcGF0Y2hFdmVudFxuICAgIHZhciByb290ID0gRE9DLmRvY3VtZW50RWxlbWVudFxuICAgIHZhciBhdmFsb25GcmFnbWVudCA9IERPQy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICB2YXIgY2luZXJhdG9yID0gRE9DLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICB2YXIgY2xhc3MydHlwZSA9IHt9XG4gICAgXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yXCIucmVwbGFjZShyd29yZCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgY2xhc3MydHlwZVtcIltvYmplY3QgXCIgKyBuYW1lICsgXCJdXCJdID0gbmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgfSlcblxuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG9uZU9iamVjdChhcnJheSwgdmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJyYXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGFycmF5ID0gYXJyYXkubWF0Y2gocndvcmQpIHx8IFtdXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgdmFsdWUgPSB2YWwgIT09IHZvaWQgMCA/IHZhbCA6IDFcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBhcnJheS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFthcnJheVtpXV0gPSB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbi8v55Sf5oiQVVVJRCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHRcbiAgICB2YXIgZ2VuZXJhdGVJRCA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8IFwiYXZhbG9uXCJcbiAgICAgICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpICsgTWF0aC5yYW5kb20oKSkucmVwbGFjZSgvXFxkXFwuXFxkezR9LywgcHJlZml4KVxuICAgIH1cbiAgICBmdW5jdGlvbiBJRSgpIHtcbiAgICAgICAgaWYgKHdpbmRvdy5WQkFycmF5KSB7XG4gICAgICAgICAgICB2YXIgbW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZVxuICAgICAgICAgICAgcmV0dXJuIG1vZGUgPyBtb2RlIDogd2luZG93LlhNTEh0dHBSZXF1ZXN0ID8gNyA6IDZcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBOYU5cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgSUVWZXJzaW9uID0gSUUoKVxuXG4gICAgYXZhbG9uID0gZnVuY3Rpb24gKGVsKSB7IC8v5Yib5bu6alF1ZXJ55byP55qE5pegbmV3IOWunuS+i+WMlue7k+aehFxuICAgICAgICByZXR1cm4gbmV3IGF2YWxvbi5pbml0KGVsKVxuICAgIH1cblxuICAgIGF2YWxvbi5wcm9maWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUgJiYgYXZhbG9uLmNvbmZpZy5wcm9maWxlKSB7XG4gICAgICAgICAgICBGdW5jdGlvbi5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKuinhua1j+iniOWZqOaDheWGtemHh+eUqOacgOW/q+eahOW8guatpeWbnuiwgyovXG4gICAgYXZhbG9uLm5leHRUaWNrID0gbmV3IGZ1bmN0aW9uICgpIHsvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgdmFyIHRpY2tJbW1lZGlhdGUgPSB3aW5kb3cuc2V0SW1tZWRpYXRlXG4gICAgICAgIHZhciB0aWNrT2JzZXJ2ZXIgPSB3aW5kb3cuTXV0YXRpb25PYnNlcnZlclxuICAgICAgICBpZiAodGlja0ltbWVkaWF0ZSkgey8vSUUxMMKgXFwxMSBlZGFnZVxuICAgICAgICAgICAgcmV0dXJuIHRpY2tJbW1lZGlhdGUuYmluZCh3aW5kb3cpXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcXVldWUgPSBbXVxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHZhciBuID0gcXVldWUubGVuZ3RoXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIHF1ZXVlW2ldKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlID0gcXVldWUuc2xpY2UobilcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aWNrT2JzZXJ2ZXIpIHsvL8Kg5pSv5oyBTXV0YXRpb25PYnNlcnZlclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcImF2YWxvblwiKVxuICAgICAgICAgICAgbmV3IHRpY2tPYnNlcnZlcihjYWxsYmFjaykub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChmbilcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luZG93LlZCQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKVxuICAgICAgICAgICAgICAgIHZhciBub2RlID0gRE9DLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcbiAgICAgICAgICAgICAgICBub2RlLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKSAvL+WcqGludGVyYWN0aXZl6Zi25q615bCx6Kem5Y+RXG4gICAgICAgICAgICAgICAgICAgIG5vZGUub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICBoZWFkLnJlbW92ZUNoaWxkKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbiwgNClcbiAgICAgICAgfVxuICAgIH0vLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgIGF2YWxvbueahOmdmeaAgeaWueazleWumuS5ieWMuiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICBhdmFsb24uaW5pdCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICB0aGlzWzBdID0gdGhpcy5lbGVtZW50ID0gZWxcbiAgICB9XG4gICAgYXZhbG9uLmZuID0gYXZhbG9uLnByb3RvdHlwZSA9IGF2YWxvbi5pbml0LnByb3RvdHlwZVxuXG4gICAgYXZhbG9uLnR5cGUgPSBmdW5jdGlvbiAob2JqKSB7IC8v5Y+W5b6X55uu5qCH55qE57G75Z6LXG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhvYmopXG4gICAgICAgIH1cbiAgICAgICAgLy8g5pep5pyf55qEd2Via2l05YaF5qC45rWP6KeI5Zmo5a6e546w5LqG5bey5bqf5byD55qEZWNtYTI2MnY05qCH5YeG77yM5Y+v5Lul5bCG5q2j5YiZ5a2X6Z2i6YeP5b2T5L2c5Ye95pWw5L2/55So77yM5Zug5q2kdHlwZW9m5Zyo5Yik5a6a5q2j5YiZ5pe25Lya6L+U5ZueZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cbiAgICAgICAgY2xhc3MydHlwZVtzZXJpYWxpemUuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiIDpcbiAgICAgICAgICAgIHR5cGVvZiBvYmpcbiAgICB9XG5cbiAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBhbGVydCA9PT0gXCJvYmplY3RcIiA/IGZ1bmN0aW9uIChmbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIC9eXFxzKlxcYmZ1bmN0aW9uXFxiLy50ZXN0KGZuICsgXCJcIilcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9IDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemUuY2FsbChmbikgPT09IFwiW29iamVjdCBGdW5jdGlvbl1cIlxuICAgIH1cbiAgICBhdmFsb24uaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb25cblxuICAgIGF2YWxvbi5pc1dpbmRvdyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgaWYgKCFvYmopXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgLy8g5Yip55SoSUU2Nzggd2luZG93ID09IGRvY3VtZW505Li6dHJ1ZSxkb2N1bWVudCA9PSB3aW5kb3fnq5/nhLbkuLpmYWxzZeeahOelnuWlh+eJueaAp1xuICAgICAgICAvLyDmoIflh4bmtY/op4jlmajlj4pJRTnvvIxJRTEw562J5L2/55SoIOato+WImeajgOa1i1xuICAgICAgICByZXR1cm4gb2JqID09IG9iai5kb2N1bWVudCAmJiBvYmouZG9jdW1lbnQgIT0gb2JqIC8vanNoaW50IGlnbm9yZTpsaW5lXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNXaW5kb3cob2JqKSB7XG4gICAgICAgIHJldHVybiByd2luZG93LnRlc3Qoc2VyaWFsaXplLmNhbGwob2JqKSlcbiAgICB9XG4gICAgaWYgKGlzV2luZG93KHdpbmRvdykpIHtcbiAgICAgICAgYXZhbG9uLmlzV2luZG93ID0gaXNXaW5kb3dcbiAgICB9XG4gICAgdmFyIGVudVxuICAgIGZvciAoZW51IGluIGF2YWxvbih7fSkpIHtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgdmFyIGVudW1lcmF0ZUJVRyA9IGVudSAhPT0gXCIwXCIgLy9JRTbkuIvkuLp0cnVlLCDlhbbku5bkuLpmYWxzZVxuICAgIC8q5Yik5a6a5piv5ZCm5piv5LiA5Liq5py057Sg55qEamF2YXNjcmlwdOWvueixoe+8iE9iamVjdO+8ie+8jOS4jeaYr0RPTeWvueixoe+8jOS4jeaYr0JPTeWvueixoe+8jOS4jeaYr+iHquWumuS5ieexu+eahOWunuS+iyovXG4gICAgYXZhbG9uLmlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICAgICAgaWYgKCFvYmogfHwgYXZhbG9uLnR5cGUob2JqKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgYXZhbG9uLmlzV2luZG93KG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkgeyAvL0lF5YaF572u5a+56LGh5rKh5pyJY29uc3RydWN0b3JcbiAgICAgICAgICAgIGlmIChvYmouY29uc3RydWN0b3IgJiYgIW9oYXNPd24uY2FsbChvYmosIFwiY29uc3RydWN0b3JcIikgJiYgIW9oYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgLy9JRTggOeS8muWcqOi/memHjOaKm+mUmVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnVtZXJhdGVCVUcpIHtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvaGFzT3duLmNhbGwob2JqLCBrZXkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleSA9PT0gdm9pZCAwIHx8IG9oYXNPd24uY2FsbChvYmosIGtleSlcbiAgICB9XG4gICAgaWYgKHJuYXRpdmUudGVzdChPYmplY3QuZ2V0UHJvdG90eXBlT2YpKSB7XG4gICAgICAgIGF2YWxvbi5pc1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgLy8g566A5Y2V55qEIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCLmo4DmtYvvvIzkvJroh7Tkvb/nlKhpc1BsYWluT2JqZWN0KHdpbmRvdynlnKhvcGVyYeS4i+mAmuS4jei/h1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZS5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCIgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT09IG9wcm90b1xuICAgICAgICB9XG4gICAgfVxuLy/kuI5qUXVlcnkuZXh0ZW5k5pa55rOV77yM5Y+v55So5LqO5rWF5ou36LSd77yM5rex5ou36LSdXG4gICAgYXZhbG9uLm1peCA9IGF2YWxvbi5mbi5taXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcbiAgICAgICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1swXSB8fCB7fSxcbiAgICAgICAgICAgIGkgPSAxLFxuICAgICAgICAgICAgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGRlZXAgPSBmYWxzZVxuXG4gICAgICAgIC8vIOWmguaenOesrOS4gOS4quWPguaVsOS4uuW4g+WwlCzliKTlrprmmK/lkKbmt7Hmi7fotJ1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICBkZWVwID0gdGFyZ2V0XG4gICAgICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge31cbiAgICAgICAgICAgIGkrK1xuICAgICAgICB9XG5cbiAgICAgICAgLy/noa7kv53mjqXlj5fmlrnkuLrkuIDkuKrlpI3mnYLnmoTmlbDmja7nsbvlnotcbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGFyZ2V0ID0ge31cbiAgICAgICAgfVxuXG4gICAgICAgIC8v5aaC5p6c5Y+q5pyJ5LiA5Liq5Y+C5pWw77yM6YKj5LmI5paw5oiQ5ZGY5re75Yqg5LqObWl45omA5Zyo55qE5a+56LGh5LiKXG4gICAgICAgIGlmIChpID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXNcbiAgICAgICAgICAgIGktLVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy/lj6rlpITnkIbpnZ7nqbrlj4LmlbBcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyA9IGFyZ3VtZW50c1tpXSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IHRhcmdldFtuYW1lXVxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IG9wdGlvbnNbbmFtZV0gLy/lvZNvcHRpb25z5Li6VkJT5a+56LGh5pe25oql6ZSZXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyDpmLLmraLnjq/lvJXnlKhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gY29weSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBjb3B5ICYmIChhdmFsb24uaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvcHkpKSkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUlzQXJyYXkgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIEFycmF5LmlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgYXZhbG9uLmlzUGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtuYW1lXSA9IGF2YWxvbi5taXgoZGVlcCwgY2xvbmUsIGNvcHkpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29weSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBjb3B5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIF9udW1iZXIoYSwgbGVuKSB7IC8v55So5LqO5qih5oufc2xpY2UsIHNwbGljZeeahOaViOaenFxuICAgICAgICBhID0gTWF0aC5mbG9vcihhKSB8fCAwXG4gICAgICAgIHJldHVybiBhIDwgMCA/IE1hdGgubWF4KGxlbiArIGEsIDApIDogTWF0aC5taW4oYSwgbGVuKTtcbiAgICB9XG5cbiAgICBhdmFsb24ubWl4KHtcbiAgICAgICAgcndvcmQ6IHJ3b3JkLFxuICAgICAgICBzdWJzY3JpYmVyczogc3Vic2NyaWJlcnMsXG4gICAgICAgIHZlcnNpb246IDEuNDcxLFxuICAgICAgICB1aToge30sXG4gICAgICAgIGxvZzogbG9nLFxuICAgICAgICBzbGljZTogVzNDID8gZnVuY3Rpb24gKG5vZGVzLCBzdGFydCwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gYXNsaWNlLmNhbGwobm9kZXMsIHN0YXJ0LCBlbmQpXG4gICAgICAgIH0gOiBmdW5jdGlvbiAobm9kZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXVxuICAgICAgICAgICAgdmFyIGxlbiA9IG5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIGVuZCA9IGxlblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmQgPT09IFwibnVtYmVyXCIgJiYgaXNGaW5pdGUoZW5kKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gX251bWJlcihzdGFydCwgbGVuKVxuICAgICAgICAgICAgICAgIGVuZCA9IF9udW1iZXIoZW5kLCBsZW4pXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0W2kgLSBzdGFydF0gPSBub2Rlc1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgfSxcbiAgICAgICAgbm9vcDogbm9vcCxcbiAgICAgICAgLyrlpoLmnpzkuI3nlKhFcnJvcuWvueixoeWwgeijheS4gOS4i++8jHN0cuWcqOaOp+WItuWPsOS4i+WPr+iDveS8muS5seeggSovXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoc3RyLCBlKSB7XG4gICAgICAgICAgICB0aHJvdyAgKGUgfHwgRXJyb3IpKHN0cilcbiAgICAgICAgfSxcbiAgICAgICAgLyrlsIbkuIDkuKrku6XnqbrmoLzmiJbpgJflj7fpmpTlvIDnmoTlrZfnrKbkuLLmiJbmlbDnu4Qs6L2s5o2i5oiQ5LiA5Liq6ZSu5YC86YO95Li6MeeahOWvueixoSovXG4gICAgICAgIG9uZU9iamVjdDogb25lT2JqZWN0LFxuICAgICAgICAvKiBhdmFsb24ucmFuZ2UoMTApXG4gICAgICAgICA9PiBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOV1cbiAgICAgICAgIGF2YWxvbi5yYW5nZSgxLCAxMSlcbiAgICAgICAgID0+IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF1cbiAgICAgICAgIGF2YWxvbi5yYW5nZSgwLCAzMCwgNSlcbiAgICAgICAgID0+IFswLCA1LCAxMCwgMTUsIDIwLCAyNV1cbiAgICAgICAgIGF2YWxvbi5yYW5nZSgwLCAtMTAsIC0xKVxuICAgICAgICAgPT4gWzAsIC0xLCAtMiwgLTMsIC00LCAtNSwgLTYsIC03LCAtOCwgLTldXG4gICAgICAgICBhdmFsb24ucmFuZ2UoMClcbiAgICAgICAgID0+IFtdKi9cbiAgICAgICAgcmFuZ2U6IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGVwKSB7IC8vIOeUqOS6jueUn+aIkOaVtOaVsOaVsOe7hFxuICAgICAgICAgICAgc3RlcCB8fCAoc3RlcCA9IDEpXG4gICAgICAgICAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzdGFydCB8fCAwXG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKGVuZCAtIHN0YXJ0KSAvIHN0ZXApKSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKVxuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gc3RhcnRcbiAgICAgICAgICAgICAgICBzdGFydCArPSBzdGVwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50SG9va3M6IFtdLFxuICAgICAgICAvKue7keWumuS6i+S7tiovXG4gICAgICAgIGJpbmQ6IGZ1bmN0aW9uIChlbCwgdHlwZSwgZm4sIHBoYXNlKSB7XG4gICAgICAgICAgICB2YXIgaG9va3MgPSBhdmFsb24uZXZlbnRIb29rc1xuICAgICAgICAgICAgdmFyIGhvb2sgPSBob29rc1t0eXBlXVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBob29rID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGhvb2sudHlwZSB8fCB0eXBlXG4gICAgICAgICAgICAgICAgcGhhc2UgPSBob29rLnBoYXNlIHx8ICEhcGhhc2VcbiAgICAgICAgICAgICAgICBmbiA9IGhvb2suZm4gPyBob29rLmZuKGVsLGZuKTogZm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IFczQyA/IGZuIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGVsLCBmaXhFdmVudChlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVzNDKSB7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgcGhhc2UpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrXG4gICAgICAgIH0sXG4gICAgICAgIC8q5Y246L295LqL5Lu2Ki9cbiAgICAgICAgdW5iaW5kOiBmdW5jdGlvbiAoZWwsIHR5cGUsIGZuLCBwaGFzZSkge1xuICAgICAgICAgICAgdmFyIGhvb2tzID0gYXZhbG9uLmV2ZW50SG9va3NcbiAgICAgICAgICAgIHZhciBob29rID0gaG9va3NbdHlwZV1cbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGZuIHx8IG5vb3BcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaG9vayA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBob29rLnR5cGUgfHwgdHlwZVxuICAgICAgICAgICAgICAgIHBoYXNlID0gaG9vay5waGFzZSB8fCAhIXBoYXNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoVzNDKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaywgcGhhc2UpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsLmRldGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKuivu+WGmeWIoOmZpOWFg+e0oOiKgueCueeahOagt+W8jyovXG4gICAgICAgIGNzczogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIGF2YWxvbikge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlWzBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJvcCA9IC9bXy1dLy50ZXN0KG5hbWUpID8gY2FtZWxpemUobmFtZSkgOiBuYW1lLCBmblxuICAgICAgICAgICAgbmFtZSA9IGF2YWxvbi5jc3NOYW1lKHByb3ApIHx8IHByb3BcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHsgLy/ojrflj5bmoLflvI9cbiAgICAgICAgICAgICAgICBmbiA9IGNzc0hvb2tzW3Byb3AgKyBcIjpnZXRcIl0gfHwgY3NzSG9va3NbXCJAOmdldFwiXVxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBcImJhY2tncm91bmRcIikge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gZm4obm9kZSwgbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgPyBwYXJzZUZsb2F0KHZhbCkgfHwgMCA6IHZhbFxuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gXCJcIikgeyAvL+ivt+mZpOagt+W8j1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbbmFtZV0gPSBcIlwiXG4gICAgICAgICAgICB9IGVsc2UgeyAvL+iuvue9ruagt+W8j1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRmluaXRlKHZhbHVlKSAmJiAhYXZhbG9uLmNzc051bWJlcltwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBcInB4XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4gPSBjc3NIb29rc1twcm9wICsgXCI6c2V0XCJdIHx8IGNzc0hvb2tzW1wiQDpzZXRcIl1cbiAgICAgICAgICAgICAgICBmbihub2RlLCBuYW1lLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyrpgY3ljobmlbDnu4TkuI7lr7nosaEs5Zue6LCD55qE56ys5LiA5Liq5Y+C5pWw5Li657Si5byV5oiW6ZSu5ZCNLOesrOS6jOS4quaIluWFg+e0oOaIlumUruWAvCovXG4gICAgICAgIGVhY2g6IGZ1bmN0aW9uIChvYmosIGZuKSB7XG4gICAgICAgICAgICBpZiAob2JqKSB7IC8v5o6S6ZmkbnVsbCwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAwXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IG9iai5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbihpLCBvYmpbaV0pID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBmbihpLCBvYmpbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8v5pS26ZuG5YWD57Sg55qEZGF0YS17e3ByZWZpeH19LSrlsZ7mgKfvvIzlubbovazmjaLkuLrlr7nosaFcbiAgICAgICAgZ2V0V2lkZ2V0RGF0YTogZnVuY3Rpb24gKGVsZW0sIHByZWZpeCkge1xuICAgICAgICAgICAgdmFyIHJhdyA9IGF2YWxvbihlbGVtKS5kYXRhKClcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fVxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiByYXcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaS5pbmRleE9mKHByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2kucmVwbGFjZShwcmVmaXgsIFwiXCIpLnJlcGxhY2UoL1xcdy8sIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICAgICAgICAgIH0pXSA9IHJhd1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSxcbiAgICAgICAgQXJyYXk6IHtcbiAgICAgICAgICAgIC8q5Y+q5pyJ5b2T5YmN5pWw57uE5LiN5a2Y5Zyo5q2k5YWD57Sg5pe25Y+q5re75Yqg5a6DKi9cbiAgICAgICAgICAgIGVuc3VyZTogZnVuY3Rpb24gKHRhcmdldCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5wdXNoKGl0ZW0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8q56e76Zmk5pWw57uE5Lit5oyH5a6a5L2N572u55qE5YWD57Sg77yM6L+U5Zue5biD5bCU6KGo56S65oiQ5Yqf5LiO5ZCmKi9cbiAgICAgICAgICAgIHJlbW92ZUF0OiBmdW5jdGlvbiAodGFyZ2V0LCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhIXRhcmdldC5zcGxpY2UoaW5kZXgsIDEpLmxlbmd0aFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8q56e76Zmk5pWw57uE5Lit56ys5LiA5Liq5Yy56YWN5Lyg5Y+C55qE6YKj5Liq5YWD57Sg77yM6L+U5Zue5biD5bCU6KGo56S65oiQ5Yqf5LiO5ZCmKi9cbiAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKHRhcmdldCwgaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRhcmdldC5pbmRleE9mKGl0ZW0pXG4gICAgICAgICAgICAgICAgaWYgKH5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF2YWxvbi5BcnJheS5yZW1vdmVBdCh0YXJnZXQsIGluZGV4KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcblxuICAgIHZhciBiaW5kaW5nSGFuZGxlcnMgPSBhdmFsb24uYmluZGluZ0hhbmRsZXJzID0ge31cbiAgICB2YXIgYmluZGluZ0V4ZWN1dG9ycyA9IGF2YWxvbi5iaW5kaW5nRXhlY3V0b3JzID0ge31cblxuICAgIC8q5Yik5a6a5piv5ZCm57G75pWw57uE77yM5aaC6IqC54K56ZuG5ZCI77yM57qv5pWw57uE77yMYXJndW1lbnRz5LiO5oul5pyJ6Z2e6LSf5pW05pWw55qEbGVuZ3Ro5bGe5oCn55qE57qvSlPlr7nosaEqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKG9iaikge1xuICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB2YXIgbiA9IG9iai5sZW5ndGhcbiAgICAgICAgaWYgKG4gPT09IChuID4+PiAwKSkgeyAvL+ajgOa1i2xlbmd0aOWxnuaAp+aYr+WQpuS4uumdnui0n+aVtOaVsFxuICAgICAgICAgICAgdmFyIHR5cGUgPSBzZXJpYWxpemUuY2FsbChvYmopLnNsaWNlKDgsIC0xKVxuICAgICAgICAgICAgaWYgKC8oPzpyZWdleHB8c3RyaW5nfGZ1bmN0aW9ufHdpbmRvd3xnbG9iYWwpJC9pLnRlc3QodHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJBcnJheVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgXCJsZW5ndGhcIikgPT09IGZhbHNlKSB7IC8v5aaC5p6c5piv5Y6f55Sf5a+56LGhXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAgL15cXHM/ZnVuY3Rpb24vLnRlc3Qob2JqLml0ZW0gfHwgb2JqLmNhbGxlZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgLy9JReeahE5vZGVMaXN055u05o6l5oqb6ZSZXG4gICAgICAgICAgICAgICAgcmV0dXJuICFvYmoud2luZG93IC8vSUU2LTggd2luZG93XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yc21zL2pzLWxydVxuICAgIHZhciBDYWNoZSA9IG5ldyBmdW5jdGlvbigpIHsvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgZnVuY3Rpb24gTFJVKG1heExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zaXplID0gMFxuICAgICAgICAgICAgdGhpcy5saW1pdCA9IG1heExlbmd0aFxuICAgICAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gdm9pZCAwXG4gICAgICAgICAgICB0aGlzLl9rZXltYXAgPSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHAgPSBMUlUucHJvdG90eXBlXG5cbiAgICAgICAgcC5wdXQgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXltYXBba2V5XSA9IGVudHJ5XG4gICAgICAgICAgICBpZiAodGhpcy50YWlsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWlsLm5ld2VyID0gZW50cnlcbiAgICAgICAgICAgICAgICBlbnRyeS5vbGRlciA9IHRoaXMudGFpbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBlbnRyeVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50YWlsID0gZW50cnlcbiAgICAgICAgICAgIGlmICh0aGlzLnNpemUgPT09IHRoaXMubGltaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoaWZ0KClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplKytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG5cbiAgICAgICAgcC5zaGlmdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5oZWFkXG4gICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV3ZXJcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQub2xkZXIgPVxuICAgICAgICAgICAgICAgICAgICBlbnRyeS5uZXdlciA9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnRyeS5vbGRlciA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gPSB2b2lkIDBcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fa2V5bWFwW2VudHJ5LmtleV0gLy8jMTAyOVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAuZ2V0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9rZXltYXBba2V5XVxuICAgICAgICAgICAgaWYgKGVudHJ5ID09PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICBpZiAoZW50cnkgPT09IHRoaXMudGFpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAgZW50cnkudmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhFQUQtLS0tLS0tLS0tLS0tLVRBSUxcbiAgICAgICAgICAgIC8vICAgPC5vbGRlciAgIC5uZXdlcj5cbiAgICAgICAgICAgIC8vICA8LS0tIGFkZCBkaXJlY3Rpb24gLS1cbiAgICAgICAgICAgIC8vICAgQSAgQiAgQyAgPEQ+ICBFXG4gICAgICAgICAgICBpZiAoZW50cnkubmV3ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkgPT09IHRoaXMuaGVhZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhlYWQgPSBlbnRyeS5uZXdlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRyeS5uZXdlci5vbGRlciA9IGVudHJ5Lm9sZGVyIC8vIEMgPC0tIEUuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50cnkub2xkZXIpIHtcbiAgICAgICAgICAgICAgICBlbnRyeS5vbGRlci5uZXdlciA9IGVudHJ5Lm5ld2VyIC8vIEMuIC0tPiBFXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnRyeS5uZXdlciA9IHZvaWQgMCAvLyBEIC0teFxuICAgICAgICAgICAgZW50cnkub2xkZXIgPSB0aGlzLnRhaWwgLy8gRC4gLS0+IEVcbiAgICAgICAgICAgIGlmICh0aGlzLnRhaWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwubmV3ZXIgPSBlbnRyeSAvLyBFLiA8LS0gRFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50YWlsID0gZW50cnlcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS52YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMUlVcbiAgICB9Ly8ganNoaW50IGlnbm9yZTpsaW5lXG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgamF2YXNjcmlwdCDlupXlsYLooaXkuIEgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICBpZiAoIVwi5Y+45b6S5q2j576OXCIudHJpbSkge1xuICAgICAgICB2YXIgcnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2dcbiAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShydHJpbSwgXCJcIilcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgaGFzRG9udEVudW1CdWcgPSAhKHtcbiAgICAgICAgICAgICd0b1N0cmluZyc6IG51bGxcbiAgICAgICAgfSkucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyksXG4gICAgICAgIGhhc1Byb3RvRW51bUJ1ZyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIH0pLnByb3BlcnR5SXNFbnVtZXJhYmxlKCdwcm90b3R5cGUnKSxcbiAgICAgICAgZG9udEVudW1zID0gW1xuICAgICAgICAgICAgXCJ0b1N0cmluZ1wiLFxuICAgICAgICAgICAgXCJ0b0xvY2FsZVN0cmluZ1wiLFxuICAgICAgICAgICAgXCJ2YWx1ZU9mXCIsXG4gICAgICAgICAgICBcImhhc093blByb3BlcnR5XCIsXG4gICAgICAgICAgICBcImlzUHJvdG90eXBlT2ZcIixcbiAgICAgICAgICAgIFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcbiAgICAgICAgICAgIFwiY29uc3RydWN0b3JcIlxuICAgICAgICBdLFxuICAgICAgICBkb250RW51bXNMZW5ndGggPSBkb250RW51bXMubGVuZ3RoO1xuICAgIGlmICghT2JqZWN0LmtleXMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMgPSBmdW5jdGlvbiAob2JqZWN0KSB7IC8vZWNtYTI2MnY1IDE1LjIuMy4xNFxuICAgICAgICAgICAgdmFyIHRoZUtleXMgPSBbXVxuICAgICAgICAgICAgdmFyIHNraXBQcm90byA9IGhhc1Byb3RvRW51bUJ1ZyAmJiB0eXBlb2Ygb2JqZWN0ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSBcInN0cmluZ1wiIHx8IChvYmplY3QgJiYgb2JqZWN0LmNhbGxlZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goU3RyaW5nKGkpKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2tpcFByb3RvICYmIG5hbWUgPT09IFwicHJvdG90eXBlXCIpICYmIG9oYXNPd24uY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGFzRG9udEVudW1CdWcpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICAgICAgc2tpcENvbnN0cnVjdG9yID0gY3RvciAmJiBjdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkb250RW51bXNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9udEVudW0gPSBkb250RW51bXNbal1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2tpcENvbnN0cnVjdG9yICYmIGRvbnRFbnVtID09PSBcImNvbnN0cnVjdG9yXCIpICYmIG9oYXNPd24uY2FsbChvYmplY3QsIGRvbnRFbnVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhlS2V5cy5wdXNoKGRvbnRFbnVtKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoZUtleXNcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplLmNhbGwoYSkgPT09IFwiW29iamVjdCBBcnJheV1cIlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFub29wLmJpbmQpIHtcbiAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiAmJiBzY29wZSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICB2YXIgZm4gPSB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3YgPSBhcmd1bWVudHNcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgaVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd2Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndltpXSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShzY29wZSwgYXJncylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKHZhcnMsIGJvZHksIHJldCkge1xuICAgICAgICB2YXIgZnVuID0gJ2Zvcih2YXIgJyArIHZhcnMgKyAnaT0wLG4gPSB0aGlzLmxlbmd0aDsgaSA8IG47IGkrKyl7JyArIGJvZHkucmVwbGFjZSgnXycsICcoKGkgaW4gdGhpcykgJiYgZm4uY2FsbChzY29wZSx0aGlzW2ldLGksdGhpcykpJykgKyAnfScgKyByZXRcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICAgICByZXR1cm4gRnVuY3Rpb24oXCJmbixzY29wZVwiLCBmdW4pXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gICAgfVxuICAgIGlmICghcm5hdGl2ZS50ZXN0KFtdLm1hcCkpIHtcbiAgICAgICAgYXZhbG9uLm1peChhcCwge1xuICAgICAgICAgICAgLy/lrprkvY3mk43kvZzvvIzov5Tlm57mlbDnu4TkuK3nrKzkuIDkuKrnrYnkuo7nu5nlrprlj4LmlbDnmoTlhYPntKDnmoTntKLlvJXlgLzjgIJcbiAgICAgICAgICAgIGluZGV4T2Y6IGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGkgPSB+fmluZGV4XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBpICs9IG5cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICAgICAgICAgIHJldHVybiAtMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8v5a6a5L2N5pON5L2c77yM5ZCM5LiK77yM5LiN6L+H5piv5LuO5ZCO6YGN5Y6G44CCXG4gICAgICAgICAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaSA9IGluZGV4ID09IG51bGwgPyBuIC0gMSA6IGluZGV4XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5tYXgoMCwgbiArIGkpXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy/ov63ku6Pmk43kvZzvvIzlsIbmlbDnu4TnmoTlhYPntKDmjKjkuKrlhL/kvKDlhaXkuIDkuKrlh73mlbDkuK3miafooYzjgIJQcm90b3R5cGUuanPnmoTlr7nlupTlkI3lrZfkuLplYWNo44CCXG4gICAgICAgICAgICBmb3JFYWNoOiBpdGVyYXRvcihcIlwiLCAnXycsIFwiXCIpLFxuICAgICAgICAgICAgLy/ov63ku6Pnsbsg5Zyo5pWw57uE5Lit55qE5q+P5Liq6aG55LiK6L+Q6KGM5LiA5Liq5Ye95pWw77yM5aaC5p6c5q2k5Ye95pWw55qE5YC85Li655yf77yM5YiZ5q2k5YWD57Sg5L2c5Li65paw5pWw57uE55qE5YWD57Sg5pS26ZuG6LW35p2l77yM5bm26L+U5Zue5paw5pWw57uEXG4gICAgICAgICAgICBmaWx0ZXI6IGl0ZXJhdG9yKCdyPVtdLGo9MCwnLCAnaWYoXylyW2orK109dGhpc1tpXScsICdyZXR1cm4gcicpLFxuICAgICAgICAgICAgLy/mlLbpm4bmk43kvZzvvIzlsIbmlbDnu4TnmoTlhYPntKDmjKjkuKrlhL/kvKDlhaXkuIDkuKrlh73mlbDkuK3miafooYzvvIznhLblkI7miorlroPku6znmoTov5Tlm57lgLznu4TmiJDkuIDkuKrmlrDmlbDnu4Tov5Tlm57jgIJQcm90b3R5cGUuanPnmoTlr7nlupTlkI3lrZfkuLpjb2xsZWN044CCXG4gICAgICAgICAgICBtYXA6IGl0ZXJhdG9yKCdyPVtdLCcsICdyW2ldPV8nLCAncmV0dXJuIHInKSxcbiAgICAgICAgICAgIC8v5Y+q6KaB5pWw57uE5Lit5pyJ5LiA5Liq5YWD57Sg5ruh6Laz5p2h5Lu277yI5pS+6L+b57uZ5a6a5Ye95pWw6L+U5ZuedHJ1Ze+8ie+8jOmCo+S5iOWug+Wwsei/lOWbnnRydWXjgIJQcm90b3R5cGUuanPnmoTlr7nlupTlkI3lrZfkuLphbnnjgIJcbiAgICAgICAgICAgIHNvbWU6IGl0ZXJhdG9yKFwiXCIsICdpZihfKXJldHVybiB0cnVlJywgJ3JldHVybiBmYWxzZScpLFxuICAgICAgICAgICAgLy/lj6rmnInmlbDnu4TkuK3nmoTlhYPntKDpg73mu6HotrPmnaHku7bvvIjmlL7ov5vnu5nlrprlh73mlbDov5Tlm550cnVl77yJ77yM5a6D5omN6L+U5ZuedHJ1ZeOAglByb3RvdHlwZS5qc+eahOWvueW6lOWQjeWtl+S4umFsbOOAglxuICAgICAgICAgICAgZXZlcnk6IGl0ZXJhdG9yKFwiXCIsICdpZighXylyZXR1cm4gZmFsc2UnLCAncmV0dXJuIHRydWUnKVxuICAgICAgICB9KVxuICAgIH1cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBET00g5bqV5bGC6KGl5LiBICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBmaXhDb250YWlucyhyb290LCBlbCkge1xuICAgICAgICB0cnkgeyAvL0lFNi04LOa4uOemu+S6jkRPTeagkeWklueahOaWh+acrOiKgueCue+8jOiuv+mXrnBhcmVudE5vZGXmnInml7bkvJrmipvplJlcbiAgICAgICAgICAgIHdoaWxlICgoZWwgPSBlbC5wYXJlbnROb2RlKSlcbiAgICAgICAgICAgICAgICBpZiAoZWwgPT09IHJvb3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICB9XG4gICAgYXZhbG9uLmNvbnRhaW5zID0gZml4Q29udGFpbnNcbi8vSUU2LTEx55qE5paH5qGj5a+56LGh5rKh5pyJY29udGFpbnNcbiAgICBpZiAoIURPQy5jb250YWlucykge1xuICAgICAgICBET0MuY29udGFpbnMgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICAgICAgcmV0dXJuIGZpeENvbnRhaW5zKERPQywgYilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG91dGVySFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcodGhpcylcbiAgICB9XG5cbiAgICBpZiAod2luZG93LlNWR0VsZW1lbnQpIHtcbiAgICAgICAgLy9zYWZhcmk1K+aYr+aKimNvbnRhaW5z5pa55rOV5pS+5ZyoRWxlbWVudC5wcm90b3R5cGXkuIrogIzkuI3mmK9Ob2RlLnByb3RvdHlwZVxuICAgICAgICBpZiAoIURPQy5jcmVhdGVUZXh0Tm9kZShcInhcIikuY29udGFpbnMpIHtcbiAgICAgICAgICAgIE5vZGUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGFyZykgey8vSUU2LTjmsqHmnIlOb2Rl5a+56LGhXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHRoaXMuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYXJnKSAmIDE2KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzdmducyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICAgICAgICB2YXIgc3ZnID0gRE9DLmNyZWF0ZUVsZW1lbnROUyhzdmducywgXCJzdmdcIilcbiAgICAgICAgc3ZnLmlubmVySFRNTCA9ICc8Y2lyY2xlIGN4PVwiNTBcIiBjeT1cIjUwXCIgcj1cIjQwXCIgZmlsbD1cInJlZFwiIC8+J1xuICAgICAgICBpZiAoIXJzdmcudGVzdChzdmcuZmlyc3RDaGlsZCkpIHsgLy8gIzQwOVxuICAgICAgICAgICAgZnVuY3Rpb24gZW51bWVyYXRlTm9kZShub2RlLCB0YXJnZXROb2RlKSB7Ly8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZWw7IGVsID0gbm9kZXNbaSsrXTsgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWwudGFnTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdmcgPSBET0MuY3JlYXRlRWxlbWVudE5TKHN2Z25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXAuZm9yRWFjaC5jYWxsKGVsLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKSAvL+WkjeWItuWxnuaAp1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8g6YCS5b2S5aSE55CG5a2Q6IqC54K5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYXRlTm9kZShlbCwgc3ZnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUuYXBwZW5kQ2hpbGQoc3ZnKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU1ZHRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgICAgICBcIm91dGVySFRNTFwiOiB7Ly9JRTktMTEsZmlyZWZveOS4jeaUr+aMgVNWR+WFg+e0oOeahGlubmVySFRNTCxvdXRlckhUTUzlsZ7mgKdcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBnZXQ6IG91dGVySFRNTCxcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZ05hbWUgPSB0aGlzLnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXIgPSB0aGlzLnBhcmVudE5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyA9IGF2YWxvbi5wYXJzZUhUTUwoaHRtbClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOaTjeS9nOeahHN2Z++8jOebtOaOpeaPkuWFpVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ05hbWUgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXIuaW5zZXJ0QmVmb3JlKGZyYWcsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Zn6IqC54K555qE5a2Q6IqC54K557G75Ly8XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdGcmFnID0gRE9DLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0ZU5vZGUoZnJhZywgbmV3RnJhZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXIuaW5zZXJ0QmVmb3JlKG5ld0ZyYWcsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXIucmVtb3ZlQ2hpbGQodGhpcylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJpbm5lckhUTUxcIjoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLm91dGVySFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvcGVuID0gbmV3IFJlZ0V4cChcIjxcIiArIHRoaXMubm9kZU5hbWUgKyAnXFxcXGIoPzooW1wiXFwnXSlbXlwiXSo/KFxcXFwxKXxbXj5dKSo+JywgXCJpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmNsb3NlID0gbmV3IFJlZ0V4cChcIjxcXC9cIiArIHRoaXMubm9kZU5hbWUgKyBcIj4kXCIsIFwiaVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMucmVwbGFjZShyb3BlbiwgXCJcIikucmVwbGFjZShyY2xvc2UsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdmFsb24uY2xlYXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXZhbG9uLmNsZWFySFRNTCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFnID0gYXZhbG9uLnBhcnNlSFRNTChodG1sKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmF0ZU5vZGUoZnJhZywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyb290Lm91dGVySFRNTCAmJiB3aW5kb3cuSFRNTEVsZW1lbnQpIHsgLy9maXJlZm94IOWIsDEx5pe25omN5pyJb3V0ZXJIVE1MXG4gICAgICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKFwib3V0ZXJIVE1MXCIsIG91dGVySFRNTCk7XG4gICAgfVxuXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gZXZlbnQgYmluZGluZyA9PT09PT09PT09PT09PT09PT09PT09PVxuICAgIHZhciBybW91c2VFdmVudCA9IC9eKD86bW91c2V8Y29udGV4dG1lbnV8ZHJhZyl8Y2xpY2svXG4gICAgZnVuY3Rpb24gZml4RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJldCA9IHt9XG4gICAgICAgIGZvciAodmFyIGkgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IGV2ZW50W2ldXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhcmdldCA9IHJldC50YXJnZXQgPSBldmVudC5zcmNFbGVtZW50XG4gICAgICAgIGlmIChldmVudC50eXBlLmluZGV4T2YoXCJrZXlcIikgPT09IDApIHtcbiAgICAgICAgICAgIHJldC53aGljaCA9IGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGVcbiAgICAgICAgfSBlbHNlIGlmIChybW91c2VFdmVudC50ZXN0KGV2ZW50LnR5cGUpKSB7XG4gICAgICAgICAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgRE9DXG4gICAgICAgICAgICB2YXIgYm94ID0gZG9jLmNvbXBhdE1vZGUgPT09IFwiQmFja0NvbXBhdFwiID8gZG9jLmJvZHkgOiBkb2MuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICAgICByZXQucGFnZVggPSBldmVudC5jbGllbnRYICsgKGJveC5zY3JvbGxMZWZ0ID4+IDApIC0gKGJveC5jbGllbnRMZWZ0ID4+IDApXG4gICAgICAgICAgICByZXQucGFnZVkgPSBldmVudC5jbGllbnRZICsgKGJveC5zY3JvbGxUb3AgPj4gMCkgLSAoYm94LmNsaWVudFRvcCA+PiAwKVxuICAgICAgICAgICAgcmV0LndoZWVsRGVsdGFZID0gcmV0LndoZWVsRGVsdGFcbiAgICAgICAgICAgIHJldC53aGVlbERlbHRhWCA9IDBcbiAgICAgICAgfVxuICAgICAgICByZXQudGltZVN0YW1wID0gbmV3IERhdGUoKSAtIDBcbiAgICAgICAgcmV0Lm9yaWdpbmFsRXZlbnQgPSBldmVudFxuICAgICAgICByZXQucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7IC8v6Zi75q2i6buY6K6k6KGM5Li6XG4gICAgICAgICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgcmV0LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uICgpIHsgLy/pmLvmraLkuovku7blnKhET03moJHkuK3nmoTkvKDmkq1cbiAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SG9va3MgPSBhdmFsb24uZXZlbnRIb29rc1xuLy/pkojlr7lmaXJlZm94LCBjaHJvbWXkv67mraNtb3VzZWVudGVyLCBtb3VzZWxlYXZlXG4gICAgaWYgKCEoXCJvbm1vdXNlZW50ZXJcIiBpbiByb290KSkge1xuICAgICAgICBhdmFsb24uZWFjaCh7XG4gICAgICAgICAgICBtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuICAgICAgICAgICAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG4gICAgICAgIH0sIGZ1bmN0aW9uIChvcmlnVHlwZSwgZml4VHlwZSkge1xuICAgICAgICAgICAgZXZlbnRIb29rc1tvcmlnVHlwZV0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZml4VHlwZSxcbiAgICAgICAgICAgICAgICBmbjogZnVuY3Rpb24gKGVsZW0sIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBlLnJlbGF0ZWRUYXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdCB8fCAodCAhPT0gZWxlbSAmJiAhKGVsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24odCkgJiAxNikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGUudHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUudHlwZSA9IG9yaWdUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbSwgZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4vL+mSiOWvuUlFOSssIHczY+S/ruato2FuaW1hdGlvbmVuZFxuICAgIGF2YWxvbi5lYWNoKHtcbiAgICAgICAgQW5pbWF0aW9uRXZlbnQ6IFwiYW5pbWF0aW9uZW5kXCIsXG4gICAgICAgIFdlYktpdEFuaW1hdGlvbkV2ZW50OiBcIndlYmtpdEFuaW1hdGlvbkVuZFwiXG4gICAgfSwgZnVuY3Rpb24gKGNvbnN0cnVjdCwgZml4VHlwZSkge1xuICAgICAgICBpZiAod2luZG93W2NvbnN0cnVjdF0gJiYgIWV2ZW50SG9va3MuYW5pbWF0aW9uZW5kKSB7XG4gICAgICAgICAgICBldmVudEhvb2tzLmFuaW1hdGlvbmVuZCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBmaXhUeXBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuLy/pkojlr7lJRTYtOOS/ruato2lucHV0XG4gICAgaWYgKCEoXCJvbmlucHV0XCIgaW4gRE9DLmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSkpIHtcbiAgICAgICAgZXZlbnRIb29rcy5pbnB1dCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvcGVydHljaGFuZ2VcIixcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiAoZWxlbSwgZm4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUucHJvcGVydHlOYW1lID09PSBcInZhbHVlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUudHlwZSA9IFwiaW5wdXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwoZWxlbSwgZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoRE9DLm9ubW91c2V3aGVlbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIC8qIElFNi0xMSBjaHJvbWUgbW91c2V3aGVlbCB3aGVlbERldGxhIOS4iyAtMTIwIOS4iiAxMjBcbiAgICAgICAgIGZpcmVmb3ggRE9NTW91c2VTY3JvbGwgZGV0YWlsIOS4izMg5LiKLTNcbiAgICAgICAgIGZpcmVmb3ggd2hlZWwgZGV0bGFZIOS4izMg5LiKLTNcbiAgICAgICAgIElFOS0xMSB3aGVlbCBkZWx0YVkg5LiLNDAg5LiKLTQwXG4gICAgICAgICBjaHJvbWUgd2hlZWwgZGVsdGFZIOS4izEwMCDkuIotMTAwICovXG4gICAgICAgIHZhciBmaXhXaGVlbFR5cGUgPSBET0Mub253aGVlbCAhPT0gdm9pZCAwID8gXCJ3aGVlbFwiIDogXCJET01Nb3VzZVNjcm9sbFwiXG4gICAgICAgIHZhciBmaXhXaGVlbERlbHRhID0gZml4V2hlZWxUeXBlID09PSBcIndoZWVsXCIgPyBcImRlbHRhWVwiIDogXCJkZXRhaWxcIlxuICAgICAgICBldmVudEhvb2tzLm1vdXNld2hlZWwgPSB7XG4gICAgICAgICAgICB0eXBlOiBmaXhXaGVlbFR5cGUsXG4gICAgICAgICAgICBmbjogZnVuY3Rpb24gKGVsZW0sIGZuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUud2hlZWxEZWx0YVkgPSBlLndoZWVsRGVsdGEgPSBlW2ZpeFdoZWVsRGVsdGFdID4gMCA/IC0xMjAgOiAxMjBcbiAgICAgICAgICAgICAgICAgICAgZS53aGVlbERlbHRhWCA9IDBcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwidHlwZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwibW91c2V3aGVlbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoZWxlbSwgZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg6YWN572u57O757ufICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgZnVuY3Rpb24ga2VybmVsKHNldHRpbmdzKSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmICghb2hhc093bi5jYWxsKHNldHRpbmdzLCBwKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgdmFyIHZhbCA9IHNldHRpbmdzW3BdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtlcm5lbC5wbHVnaW5zW3BdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBrZXJuZWwucGx1Z2luc1twXSh2YWwpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBrZXJuZWxbcF0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBhdmFsb24ubWl4KGtlcm5lbFtwXSwgdmFsKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXJuZWxbcF0gPSB2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICB2YXIgb3BlblRhZywgY2xvc2VUYWcsIHJleHByLCByZXhwcmcsIHJiaW5kLCBycmVnZXhwID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZ1xuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHRhcmdldCkge1xuICAgICAgICAvL2h0dHA6Ly9zdGV2ZW5sZXZpdGhhbi5jb20vcmVnZXgveHJlZ2V4cC9cbiAgICAgICAgLy/lsIblrZfnrKbkuLLlronlhajmoLzlvI/ljJbkuLrmraPliJnooajovr7lvI/nmoTmupDnoIFcbiAgICAgICAgcmV0dXJuICh0YXJnZXQgKyBcIlwiKS5yZXBsYWNlKHJyZWdleHAsIFwiXFxcXCQmXCIpXG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbnMgPSB7XG5cbiAgICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgICAgICAgICAgb3BlblRhZyA9IGFycmF5WzBdXG4gICAgICAgICAgICBjbG9zZVRhZyA9IGFycmF5WzFdXG4gICAgICAgICAgICBpZiAob3BlblRhZyA9PT0gY2xvc2VUYWcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJvcGVuVGFnPT09Y2xvc2VUYWdcIilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlc3QgPSBvcGVuVGFnICsgXCJ0ZXN0XCIgKyBjbG9zZVRhZ1xuICAgICAgICAgICAgICAgIGNpbmVyYXRvci5pbm5lckhUTUwgPSB0ZXN0XG4gICAgICAgICAgICAgICAgaWYgKGNpbmVyYXRvci5pbm5lckhUTUwgIT09IHRlc3QgJiYgY2luZXJhdG9yLmlubmVySFRNTC5pbmRleE9mKFwiJmx0O1wiKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIuatpOWumueVjOespuS4jeWQiOazlVwiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrZXJuZWwub3BlblRhZyA9IG9wZW5UYWdcbiAgICAgICAgICAgICAgICBrZXJuZWwuY2xvc2VUYWcgPSBjbG9zZVRhZ1xuICAgICAgICAgICAgICAgIGNpbmVyYXRvci5pbm5lckhUTUwgPSBcIlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbyA9IGVzY2FwZVJlZ0V4cChvcGVuVGFnKSxcbiAgICAgICAgICAgICAgICBjID0gZXNjYXBlUmVnRXhwKGNsb3NlVGFnKVxuICAgICAgICAgICAgcmV4cHIgPSBuZXcgUmVnRXhwKG8gKyBcIiguKj8pXCIgKyBjKVxuICAgICAgICAgICAgcmV4cHJnID0gbmV3IFJlZ0V4cChvICsgXCIoLio/KVwiICsgYywgXCJnXCIpXG4gICAgICAgICAgICByYmluZCA9IG5ldyBSZWdFeHAobyArIFwiLio/XCIgKyBjICsgXCJ8XFxcXHNtcy1cIilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGtlcm5lbC5kZWJ1ZyA9IHRydWVcbiAgICBrZXJuZWwucGx1Z2lucyA9IHBsdWdpbnNcbiAgICBrZXJuZWwucGx1Z2luc1snaW50ZXJwb2xhdGUnXShbXCJ7e1wiLCBcIn19XCJdKVxuICAgIGtlcm5lbC5wYXRocyA9IHt9XG4gICAga2VybmVsLnNoaW0gPSB7fVxuICAgIGtlcm5lbC5tYXhSZXBlYXRTaXplID0gMTAwXG4gICAgYXZhbG9uLmNvbmZpZyA9IGtlcm5lbFxuICAgIHZhciByYXZhbG9uID0gLyhcXHcrKVxcWyhhdmFsb25jdHJsKT1cIihcXFMrKVwiXFxdL1xuICAgIHZhciBmaW5kTm9kZXMgPSBET0MucXVlcnlTZWxlY3RvckFsbCA/IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICByZXR1cm4gRE9DLnF1ZXJ5U2VsZWN0b3JBbGwoc3RyKVxuICAgIH0gOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKHJhdmFsb24pXG4gICAgICAgIHZhciBhbGwgPSBET0MuZ2V0RWxlbWVudHNCeVRhZ05hbWUobWF0Y2hbMV0pXG4gICAgICAgIHZhciBub2RlcyA9IFtdXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBlbDsgZWwgPSBhbGxbaSsrXTsgKSB7XG4gICAgICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKG1hdGNoWzJdKSA9PT0gbWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGVsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2Rlc1xuICAgIH1cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAg5LqL5Lu25oC757q/ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB2YXIgRXZlbnRCdXMgPSB7XG4gICAgICAgICR3YXRjaDogZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gdGhpcy4kZXZlbnRzW3R5cGVdXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjaylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRldmVudHNbdHlwZV0gPSBbY2FsbGJhY2tdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHsgLy/ph43mlrDlvIDlp4vnm5HlkKzmraRWTeeahOesrOS4gOmHjeeugOWNleWxnuaAp+eahOWPmOWKqFxuICAgICAgICAgICAgICAgIHRoaXMuJGV2ZW50cyA9IHRoaXMuJHdhdGNoLmJhY2t1cFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSxcbiAgICAgICAgJHVud2F0Y2g6IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICBpZiAobiA9PT0gMCkgeyAvL+iuqeatpFZN55qE5omA5pyJJHdhdGNo5Zue6LCD5peg5pWI5YyWXG4gICAgICAgICAgICAgICAgdGhpcy4kd2F0Y2guYmFja3VwID0gdGhpcy4kZXZlbnRzXG4gICAgICAgICAgICAgICAgdGhpcy4kZXZlbnRzID0ge31cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGV2ZW50c1t0eXBlXSA9IFtdXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLiRldmVudHNbdHlwZV0gfHwgW11cbiAgICAgICAgICAgICAgICB2YXIgaSA9IGNhbGxiYWNrcy5sZW5ndGhcbiAgICAgICAgICAgICAgICB3aGlsZSAofi0taSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrc1tpXSA9PT0gY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFja3Muc3BsaWNlKGksIDEpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9LFxuICAgICAgICAkZmlyZTogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBzcGVjaWFsLCBpLCB2LCBjYWxsYmFja1xuICAgICAgICAgICAgaWYgKC9eKFxcdyspIShcXFMrKSQvLnRlc3QodHlwZSkpIHtcbiAgICAgICAgICAgICAgICBzcGVjaWFsID0gUmVnRXhwLiQxXG4gICAgICAgICAgICAgICAgdHlwZSA9IFJlZ0V4cC4kMlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuJGV2ZW50c1xuICAgICAgICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFzbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICAgICAgIHZhciBkZXRhaWwgPSBbdHlwZV0uY29uY2F0KGFyZ3MpXG4gICAgICAgICAgICBpZiAoc3BlY2lhbCA9PT0gXCJhbGxcIikge1xuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBhdmFsb24udm1vZGVscykge1xuICAgICAgICAgICAgICAgICAgICB2ID0gYXZhbG9uLnZtb2RlbHNbaV1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYuJGZpcmUuYXBwbHkodiwgZGV0YWlsKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzcGVjaWFsID09PSBcInVwXCIgfHwgc3BlY2lhbCA9PT0gXCJkb3duXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBldmVudHMuZXhwciA/IGZpbmROb2RlcyhldmVudHMuZXhwcikgOiBbXVxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIGZvciAoaSBpbiBhdmFsb24udm1vZGVscykge1xuICAgICAgICAgICAgICAgICAgICB2ID0gYXZhbG9uLnZtb2RlbHNbaV1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2LiRldmVudHMuZXhwcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudE5vZGVzID0gZmluZE5vZGVzKHYuJGV2ZW50cy5leHByKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+W+queOr+S4pOS4qnZtb2RlbOS4reeahOiKgueCue+8jOafpeaJvuWMuemFje+8iOWQkeS4iuWMuemFjeaIluiAheWQkeS4i+WMuemFje+8ieeahOiKgueCueW5tuiuvue9ruagh+ivhlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcC5mb3JFYWNoLmNhbGwoZXZlbnROb2RlcywgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXAuZm9yRWFjaC5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9rID0gc3BlY2lhbCA9PT0gXCJkb3duXCIgPyBlbGVtZW50LmNvbnRhaW5zKG5vZGUpIDogLy/lkJHkuIvmjZXojrdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNvbnRhaW5zKGVsZW1lbnQpIC8v5ZCR5LiK5YaS5rOhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLl9hdmFsb24gPSB2IC8v56ym5ZCI5p2h5Lu255qE5Yqg5LiA5Liq5qCH6K+GXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoganNoaW50IGlnbm9yZTplbmQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBET0MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIC8v5a6e546w6IqC54K55o6S5bqPXG4gICAgICAgICAgICAgICAgdmFyIGFsbHMgPSBbXVxuICAgICAgICAgICAgICAgIGFwLmZvckVhY2guY2FsbChub2RlcywgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5fYXZhbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxzLnB1c2goZWwuX2F2YWxvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLl9hdmFsb24gPSBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoXCJfYXZhbG9uXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGlmIChzcGVjaWFsID09PSBcInVwXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxscy5yZXZlcnNlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgY2FsbGJhY2sgPSBhbGxzW2krK107ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suJGZpcmUuYXBwbHkoY2FsbGJhY2ssIGRldGFpbCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gZXZlbnRzW3R5cGVdIHx8IFtdXG4gICAgICAgICAgICAgICAgdmFyIGFsbCA9IGV2ZW50cy4kYWxsIHx8IFtdXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgY2FsbGJhY2sgPSBjYWxsYmFja3NbaSsrXTsgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGNhbGxiYWNrID0gYWxsW2krK107ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihjYWxsYmFjaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsRmFjdG9yeSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLy9hdmFsb27mnIDmoLjlv4PnmoTmlrnms5XnmoTkuKTkuKrmlrnms5XkuYvkuIDvvIjlj6bkuIDkuKrmmK9hdmFsb24uc2Nhbu+8ie+8jOi/lOWbnuS4gOS4qlZpZXdNb2RlbChWTSlcbiAgICB2YXIgVk1PREVMUyA9IGF2YWxvbi52bW9kZWxzID0ge30gLy/miYDmnIl2bW9kZWzpg73lgqjlrZjlnKjov5nph4xcbiAgICBhdmFsb24uZGVmaW5lID0gZnVuY3Rpb24gKGlkLCBmYWN0b3J5KSB7XG4gICAgICAgIHZhciAkaWQgPSBpZC4kaWQgfHwgaWRcbiAgICAgICAgaWYgKCEkaWQpIHtcbiAgICAgICAgICAgIGxvZyhcIndhcm5pbmc6IHZt5b+F6aG75oyH5a6aJGlkXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKFZNT0RFTFNbJGlkXSkge1xuICAgICAgICAgICAgbG9nKFwid2FybmluZzogXCIgKyAkaWQgKyBcIiDlt7Lnu4/lrZjlnKjkuo5hdmFsb24udm1vZGVsc+S4rVwiKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IG1vZGVsRmFjdG9yeShpZClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IHtcbiAgICAgICAgICAgICAgICAkd2F0Y2g6IG5vb3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhY3Rvcnkoc2NvcGUpIC8v5b6X5Yiw5omA5pyJ5a6a5LmJXG5cbiAgICAgICAgICAgIG1vZGVsID0gbW9kZWxGYWN0b3J5KHNjb3BlKSAvL+WBt+WkqeaNouaXpe+8jOWwhnNjb3Bl5o2i5Li6bW9kZWxcbiAgICAgICAgICAgIHN0b3BSZXBlYXRBc3NpZ24gPSB0cnVlXG4gICAgICAgICAgICBmYWN0b3J5KG1vZGVsKVxuICAgICAgICAgICAgc3RvcFJlcGVhdEFzc2lnbiA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuJGlkID0gJGlkXG4gICAgICAgIHJldHVybiBWTU9ERUxTWyRpZF0gPSBtb2RlbFxuICAgIH1cblxuLy/kuIDkupvkuI3pnIDopoHooqvnm5HlkKznmoTlsZ7mgKdcbiAgICB2YXIgJCRza2lwQXJyYXkgPSBTdHJpbmcoXCIkaWQsJHdhdGNoLCR1bndhdGNoLCRmaXJlLCRldmVudHMsJG1vZGVsLCRza2lwQXJyYXksJHJlaW5pdGlhbGl6ZVwiKS5tYXRjaChyd29yZClcbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHlcbiAgICB2YXIgY2FuSGlkZU93biA9IHRydWVcbi8v5aaC5p6c5rWP6KeI5Zmo5LiN5pSv5oyBZWNtYTI2MnY155qET2JqZWN0LmRlZmluZVByb3BlcnRpZXPmiJbogIXlrZjlnKhCVUfvvIzmr5TlpoJJRThcbi8v5qCH5YeG5rWP6KeI5Zmo5L2/55SoX19kZWZpbmVHZXR0ZXJfXywgX19kZWZpbmVTZXR0ZXJfX+WunueOsFxuICAgIHRyeSB7XG4gICAgICAgIGRlZmluZVByb3BlcnR5KHt9LCBcIl9cIiwge1xuICAgICAgICAgICAgdmFsdWU6IFwieFwiXG4gICAgICAgIH0pXG4gICAgICAgIHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXNcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhbkhpZGVPd24gPSBmYWxzZVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vZGVsRmFjdG9yeShzb3VyY2UsICRzcGVjaWFsLCAkbW9kZWwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgdmFyIGFyciA9IHNvdXJjZS5jb25jYXQoKVxuICAgICAgICAgICAgc291cmNlLmxlbmd0aCA9IDBcbiAgICAgICAgICAgIHZhciBjb2xsZWN0aW9uID0gYXJyYXlGYWN0b3J5KHNvdXJjZSlcbiAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaEFycmF5KGFycilcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgLy8wIG51bGwgdW5kZWZpbmVkIHx8IE5vZGUgfHwgVk1vZGVsKGZpeCBJRTYtOCBjcmVhdGVXaXRoUHJveHkgJHZhbDogdmFs5byV5Y+R55qEQlVHKVxuICAgICAgICBpZiAoIXNvdXJjZSB8fCAoc291cmNlLiRpZCAmJiBzb3VyY2UuJGV2ZW50cykgfHwgKHNvdXJjZS5ub2RlVHlwZSA+IDAgJiYgc291cmNlLm5vZGVOYW1lKSApIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2VcbiAgICAgICAgfVxuICAgICAgICB2YXIgJHNraXBBcnJheSA9IEFycmF5LmlzQXJyYXkoc291cmNlLiRza2lwQXJyYXkpID8gc291cmNlLiRza2lwQXJyYXkgOiBbXVxuICAgICAgICAkc2tpcEFycmF5LiRzcGVjaWFsID0gJHNwZWNpYWwgfHwge30gLy/lvLrliLbopoHnm5HlkKznmoTlsZ7mgKdcbiAgICAgICAgdmFyICR2bW9kZWwgPSB7fSAvL+imgei/lOWbnueahOWvueixoSwg5a6D5ZyoSUU2LTjkuIvlj6/og73ooqvlgbfpvpnovazlh6RcbiAgICAgICAgJG1vZGVsID0gJG1vZGVsIHx8IHt9IC8vdm1vZGVscy4kbW9kZWzlsZ7mgKdcbiAgICAgICAgdmFyICRldmVudHMgPSB7fSAvL3Ztb2RlbC4kZXZlbnRz5bGe5oCnXG4gICAgICAgIHZhciBhY2Nlc3NvcnMgPSB7fSAvL+ebkeaOp+WxnuaAp1xuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbXVxuICAgICAgICAkJHNraXBBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW25hbWVdXG4gICAgICAgIH0pXG4gICAgICAgIHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHNvdXJjZSlcbiAgICAgICAgLyoganNoaW50IGlnbm9yZTpzdGFydCAqL1xuICAgICAgICBuYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lLCBhY2Nlc3Nvcikge1xuICAgICAgICAgICAgdmFyIHZhbCA9IHNvdXJjZVtuYW1lXVxuICAgICAgICAgICAgJG1vZGVsW25hbWVdID0gdmFsXG4gICAgICAgICAgICBpZiAoaXNPYnNlcnZhYmxlKG5hbWUsIHZhbCwgJHNraXBBcnJheSkpIHtcbiAgICAgICAgICAgICAgICAvL+aAu+WFseS6p+eUn+S4ieenjWFjY2Vzc29yXG4gICAgICAgICAgICAgICAgJGV2ZW50c1tuYW1lXSA9IFtdXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlVHlwZSA9IGF2YWxvbi50eXBlKHZhbClcbiAgICAgICAgICAgICAgICAvL+aAu+WFseS6p+eUn+S4ieenjWFjY2Vzc29yXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpc0Z1bmN0aW9uKHZhbC5nZXQpICYmIE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3IgPSBtYWtlQ29tcHV0ZWRBY2Nlc3NvcihuYW1lLCB2YWwpXG4gICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkLnB1c2goYWNjZXNzb3IpXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyY29tcGxleFR5cGUudGVzdCh2YWx1ZVR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzc3VlICM5NDAg6Kej5YazJG1vZGVs5bGC5qyh5L6d6LWW5Lii5aSxIGh0dHBzOi8vZ2l0aHViLmNvbS9SdWJ5TG91dnJlL2F2YWxvbi9pc3N1ZXMvOTQwXG4gICAgICAgICAgICAgICAgICAgIC8vICAkbW9kZWxbbmFtZV0gPSB7fVxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IG1ha2VDb21wbGV4QWNjZXNzb3IobmFtZSwgdmFsLCB2YWx1ZVR5cGUsICRldmVudHNbbmFtZV0sICRtb2RlbClcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3NvciA9IG1ha2VTaW1wbGVBY2Nlc3NvcihuYW1lLCB2YWwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY2Vzc29yc1tuYW1lXSA9IGFjY2Vzc29yXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gICAgICAgICR2bW9kZWwgPSBkZWZpbmVQcm9wZXJ0aWVzKCR2bW9kZWwsIGRlc2NyaXB0b3JGYWN0b3J5KGFjY2Vzc29ycyksIHNvdXJjZSkgLy/nlJ/miJDkuIDkuKrnqbrnmoRWaWV3TW9kZWxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBuYW1lc1tpXVxuICAgICAgICAgICAgaWYgKCFhY2Nlc3NvcnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAkdm1vZGVsW25hbWVdID0gc291cmNlW25hbWVdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy/mt7vliqAkaWQsICRtb2RlbCwgJGV2ZW50cywgJHdhdGNoLCAkdW53YXRjaCwgJGZpcmVcbiAgICAgICAgaGlkZVByb3BlcnR5KCR2bW9kZWwsIFwiJGlkXCIsIGdlbmVyYXRlSUQoKSlcbiAgICAgICAgaGlkZVByb3BlcnR5KCR2bW9kZWwsIFwiJG1vZGVsXCIsICRtb2RlbClcbiAgICAgICAgaGlkZVByb3BlcnR5KCR2bW9kZWwsIFwiJGV2ZW50c1wiLCAkZXZlbnRzKVxuICAgICAgICAvKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG4gICAgICAgIGlmIChjYW5IaWRlT3duKSB7XG4gICAgICAgICAgICBoaWRlUHJvcGVydHkoJHZtb2RlbCwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lIGluICR2bW9kZWwuJG1vZGVsXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHZtb2RlbC5oYXNPd25Qcm9wZXJ0eSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lIGluICR2bW9kZWwuJG1vZGVsKSAmJiAobmFtZSAhPT0gXCJoYXNPd25Qcm9wZXJ0eVwiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBpZ25vcmU6ZW5kICovXG4gICAgICAgIGZvciAoIGkgaW4gRXZlbnRCdXMpIHtcbiAgICAgICAgICAgIGhpZGVQcm9wZXJ0eSgkdm1vZGVsLCBpLCBFdmVudEJ1c1tpXS5iaW5kKCR2bW9kZWwpKVxuICAgICAgICB9XG5cbiAgICAgICAgJHZtb2RlbC4kcmVpbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29tcHV0ZWQuZm9yRWFjaChmdW5jdGlvbiAoYWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgYWNjZXNzb3IuX3ZhbHVlXG4gICAgICAgICAgICAgICAgZGVsZXRlIGFjY2Vzc29yLm9sZEFyZ3NcbiAgICAgICAgICAgICAgICBhY2Nlc3Nvci5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc29yLmNhbGwoJHZtb2RlbClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeURldGVjdGlvbi5iZWdpbih7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAodm0sIGRlcGVuZGVuY3kpIHsvL2RlcGVuZGVuY3nkuLrkuIDkuKphY2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBkZXBlbmRlbmN5Ll9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwZW5kZW5jeSAhPT0gYWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IHZtLiRldmVudHNbbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmplY3REZXBlbmRlbmN5KGxpc3QsIGFjY2Vzc29yLmRpZ2VzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3IuZ2V0LmNhbGwoJHZtb2RlbClcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5RGV0ZWN0aW9uLmVuZCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAkdm1vZGVsLiRyZWluaXRpYWxpemUoKVxuICAgICAgICByZXR1cm4gJHZtb2RlbFxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gaGlkZVByb3BlcnR5KGhvc3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmIChjYW5IaWRlT3duKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaG9zdCwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBob3N0W25hbWVdID0gdmFsdWVcbiAgICAgICAgfVxuICAgIH1cbi8v5Yib5bu65LiA5Liq566A5Y2V6K6/6Zeu5ZmoXG4gICAgZnVuY3Rpb24gbWFrZVNpbXBsZUFjY2Vzc29yKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFjY2Vzc29yKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBhY2Nlc3Nvci5fdmFsdWVcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghc3RvcFJlcGVhdEFzc2lnbiAmJiAhaXNFcXVhbCh2YWx1ZSwgb2xkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY2Vzc29yLnVwZGF0ZVZhbHVlKHRoaXMsIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBhY2Nlc3Nvci5ub3RpZnkodGhpcywgdmFsdWUsIG9sZFZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5RGV0ZWN0aW9uLmNvbGxlY3REZXBlbmRlbmN5KHRoaXMsIGFjY2Vzc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBvbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFjY2Vzc29yRmFjdG9yeShhY2Nlc3NvciwgbmFtZSlcbiAgICAgICAgYWNjZXNzb3IuX3ZhbHVlID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIGFjY2Vzc29yO1xuICAgIH1cblxuLy/liJvlu7rkuIDkuKrorqHnrpforr/pl67lmahcbiAgICBmdW5jdGlvbiBtYWtlQ29tcHV0ZWRBY2Nlc3NvcihuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFjY2Vzc29yKHZhbHVlKSB7Ly/orqHnrpflsZ7mgKdcbiAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IGFjY2Vzc29yLl92YWx1ZVxuICAgICAgICAgICAgdmFyIGluaXQgPSAoXCJfdmFsdWVcIiBpbiBhY2Nlc3NvcilcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wUmVwZWF0QXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWNjZXNzb3Iuc2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2Vzc29yLm9sZEFyZ3MgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3Nvci5vbGRBcmdzID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkZXZlbnRzID0gdGhpcy4kZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jayA9ICRldmVudHNbbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICRldmVudHNbbmFtZV0gPSBbXSAvL+a4heepuuWbnuiwg++8jOmYsuatouWGhemDqOWGkuazoeiAjOinpuWPkeWkmuasoSRmaXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3Nvci5zZXQuY2FsbCh0aGlzLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICRldmVudHNbbmFtZV0gPSBsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjY2Vzc29yLmdldC5jYWxsKHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3IudXBkYXRlVmFsdWUodGhpcywgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3Iubm90aWZ5KHRoaXMsIHZhbHVlLCBvbGRWYWx1ZSkgLy/op6blj5Ekd2F0Y2jlm57osINcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL+WwhuS+nei1luS6juiHquW3seeahOmrmOWxguiuv+mXruWZqOaIluinhuWbvuWIt+aWsOWHveaVsO+8iOS7pee7keWumuWvueixoeW9ouW8j++8ieaUvuWIsOiHquW3seeahOiuoumYheaVsOe7hOS4rVxuICAgICAgICAgICAgICAgIC8v5bCG6Ieq5bex5rOo5YWl5Yiw5L2O5bGC6K6/6Zeu5Zmo55qE6K6i6ZiF5pWw57uE5LitXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhY2Nlc3Nvci5nZXQuY2FsbCh0aGlzKVxuICAgICAgICAgICAgICAgIGFjY2Vzc29yLnVwZGF0ZVZhbHVlKHRoaXMsIHZhbHVlKVxuICAgICAgICAgICAgICAgIGlmIChpbml0ICYmIG9sZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhY2Nlc3Nvci5ub3RpZnkodGhpcywgdmFsdWUsIG9sZFZhbHVlKSAvL+inpuWPkSR3YXRjaOWbnuiwg1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY2Nlc3Nvci5zZXQgPSBvcHRpb25zLnNldFxuICAgICAgICBhY2Nlc3Nvci5nZXQgPSBvcHRpb25zLmdldFxuICAgICAgICBhY2Nlc3NvckZhY3RvcnkoYWNjZXNzb3IsIG5hbWUpXG4gICAgICAgIHJldHVybiBhY2Nlc3NvclxuICAgIH1cblxuLy/liJvlu7rkuIDkuKrlpI3mnYLorr/pl67lmahcbiAgICBmdW5jdGlvbiBtYWtlQ29tcGxleEFjY2Vzc29yKG5hbWUsIGluaXRWYWx1ZSwgdmFsdWVUeXBlLCBsaXN0LCBwYXJlbnRNb2RlbCkge1xuXG4gICAgICAgIGZ1bmN0aW9uIGFjY2Vzc29yKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSBhY2Nlc3Nvci5fdmFsdWVcblxuICAgICAgICAgICAgdmFyIHNvbiA9IGFjY2Vzc29yLl92bW9kZWxcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wUmVwZWF0QXNzaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHNvbiwgYiA9IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW4gPSBhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJuID0gYi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgYS4kbG9jayA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuID4gYm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc3BsaWNlKGJuLCBhbiAtIGJuKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJuID4gYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaC5hcHBseShhLCBiLnNsaWNlKGFuKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IE1hdGgubWluKGFuLCBibilcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEuc2V0KGksIGJbaV0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGEuJGxvY2tcbiAgICAgICAgICAgICAgICAgICAgYS5fZmlyZShcInNldFwiKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVUeXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuJG1vZGVsID8gdmFsdWUuJG1vZGVsIDogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ic2VydmVzID0gdGhpcy4kZXZlbnRzW25hbWVdIHx8IFtdXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdPYmplY3QgPSBhdmFsb24ubWl4KHRydWUsIHt9LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yKGkgaW4gc29uICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzb24uaGFzT3duUHJvcGVydHkoaSkgJiYgb2hhc093bi5jYWxsKG5ld09iamVjdCxpKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc29uW2ldID0gbmV3T2JqZWN0W2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc29uID0gYWNjZXNzb3IuX3Ztb2RlbCA9IG1vZGVsRmFjdG9yeSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc29uLiRldmVudHNbc3Vic2NyaWJlcnNdID0gb2JzZXJ2ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9ic2VydmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXMuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAvL+aVsOaNruacquWHhuWkh+WlveaXtuW/veeVpeabtOaWsFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5yb2xsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnJvbGxiYWNrKCkgLy/ov5jljp8gbXMtd2l0aCBtcy1vblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSGFuZGxlcnNbZGF0YS50eXBlXShkYXRhLCBkYXRhLnZtb2RlbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFjY2Vzc29yLnVwZGF0ZVZhbHVlKHRoaXMsIHNvbi4kbW9kZWwpXG4gICAgICAgICAgICAgICAgYWNjZXNzb3Iubm90aWZ5KHRoaXMsIHRoaXMuX3ZhbHVlLCBvbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmN5RGV0ZWN0aW9uLmNvbGxlY3REZXBlbmRlbmN5KHRoaXMsIGFjY2Vzc29yKVxuICAgICAgICAgICAgICAgIHJldHVybiBzb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhY2Nlc3NvckZhY3RvcnkoYWNjZXNzb3IsIG5hbWUpXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluaXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHBhcmVudE1vZGVsW25hbWVdID0gaW5pdFZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnRNb2RlbFtuYW1lXSA9IHBhcmVudE1vZGVsW25hbWVdIHx8IHt9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvbiA9IGFjY2Vzc29yLl92bW9kZWwgPSBtb2RlbEZhY3RvcnkoaW5pdFZhbHVlLCAwLCBwYXJlbnRNb2RlbFtuYW1lXSlcbiAgICAgICAgc29uLiRldmVudHNbc3Vic2NyaWJlcnNdID0gbGlzdFxuICAgICAgICByZXR1cm4gYWNjZXNzb3JcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnbG9iYWxVcGRhdGVWYWx1ZSh2bW9kZWwsIHZhbHVlKSB7XG4gICAgICAgIHZtb2RlbC4kbW9kZWxbdGhpcy5fbmFtZV0gPSB0aGlzLl92YWx1ZSA9IHZhbHVlXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2xvYmFsTm90aWZ5KHZtb2RlbCwgdmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5fbmFtZVxuICAgICAgICB2YXIgYXJyYXkgPSB2bW9kZWwuJGV2ZW50c1tuYW1lXSAvL+WIt+aWsOWAvFxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGZpcmVEZXBlbmRlbmNpZXMoYXJyYXkpIC8v5ZCM5q2l6KeG5Zu+XG4gICAgICAgICAgICBFdmVudEJ1cy4kZmlyZS5jYWxsKHZtb2RlbCwgbmFtZSwgdmFsdWUsIG9sZFZhbHVlKSAvL+inpuWPkSR3YXRjaOWbnuiwg1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWNjZXNzb3JGYWN0b3J5KGFjY2Vzc29yLCBuYW1lKSB7XG4gICAgICAgIGFjY2Vzc29yLl9uYW1lID0gbmFtZVxuICAgICAgICAvL+WQjOaXtuabtOaWsF92YWx1ZeS4jm1vZGVsXG4gICAgICAgIGFjY2Vzc29yLnVwZGF0ZVZhbHVlID0gZ2xvYmFsVXBkYXRlVmFsdWVcbiAgICAgICAgYWNjZXNzb3Iubm90aWZ5ID0gZ2xvYmFsTm90aWZ5XG4gICAgfVxuXG4vL+avlOi+g+S4pOS4quWAvOaYr+WQpuebuOetiVxuICAgIHZhciBpc0VxdWFsID0gT2JqZWN0LmlzIHx8IGZ1bmN0aW9uICh2MSwgdjIpIHtcbiAgICAgICAgICAgIGlmICh2MSA9PT0gMCAmJiB2MiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxIC8gdjEgPT09IDEgLyB2MlxuICAgICAgICAgICAgfSBlbHNlIGlmICh2MSAhPT0gdjEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjIgIT09IHYyXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB2MSA9PT0gdjJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYnNlcnZhYmxlKG5hbWUsIHZhbHVlLCAkc2tpcEFycmF5KSB7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCB2YWx1ZSAmJiB2YWx1ZS5ub2RlTmFtZSAmJiAodmFsdWUubm9kZVR5cGUgPiAwKSApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGlmICgkc2tpcEFycmF5LmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICB2YXIgJHNwZWNpYWwgPSAkc2tpcEFycmF5LiRzcGVjaWFsXG4gICAgICAgIGlmIChuYW1lICYmIG5hbWUuY2hhckF0KDApID09PSBcIiRcIiAmJiAhJHNwZWNpYWxbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGZ1bmN0aW9uIGtleXNWTShvYmopIHtcbiAgICAgICAgdmFyIGFyciA9IE9iamVjdC5rZXlzKG9iai4kbW9kZWwgPyBvYmouJG1vZGVsOiBvYmopXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJCRza2lwQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKCQkc2tpcEFycmF5W2ldKVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cbiAgICB2YXIgZGVzY3JpcHRvckZhY3RvcnkgPSBXM0MgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9ycyA9IHt9XG4gICAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBnZXQ6IG9ialtpXSxcbiAgICAgICAgICAgICAgICBzZXQ6IG9ialtpXSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9yc1xuICAgIH0gOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYVxuICAgIH1cblxuLy89PT09PT09PT09PT09PT09PT095L+u5aSN5rWP6KeI5Zmo5a+5T2JqZWN0LmRlZmluZVByb3BlcnRpZXPnmoTmlK/mjIE9PT09PT09PT09PT09PT09PVxuICAgIGlmICghY2FuSGlkZU93bikge1xuICAgICAgICBpZiAoXCJfX2RlZmluZUdldHRlcl9fXCIgaW4gYXZhbG9uKSB7XG4gICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIHByb3AsIGRlc2MpIHtcbiAgICAgICAgICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IGRlc2MudmFsdWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFwiZ2V0XCIgaW4gZGVzYykge1xuICAgICAgICAgICAgICAgICAgICBvYmouX19kZWZpbmVHZXR0ZXJfXyhwcm9wLCBkZXNjLmdldClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCdzZXQnIGluIGRlc2MpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLl9fZGVmaW5lU2V0dGVyX18ocHJvcCwgZGVzYy5zZXQpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAob2JqLCBkZXNjcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gZGVzY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2NzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIGRlc2NzW3Byb3BdKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvYmpcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoSUVWZXJzaW9uKSB7XG4gICAgICAgICAgICB2YXIgVkJDbGFzc1Bvb2wgPSB7fVxuICAgICAgICAgICAgd2luZG93LmV4ZWNTY3JpcHQoWy8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIFwiRnVuY3Rpb24gcGFyc2VWQihjb2RlKVwiLFxuICAgICAgICAgICAgICAgIFwiXFx0RXhlY3V0ZUdsb2JhbChjb2RlKVwiLFxuICAgICAgICAgICAgICAgIFwiRW5kIEZ1bmN0aW9uXCIgLy/ovazmjaLkuIDmrrXmlofmnKzkuLpWQuS7o+eggVxuICAgICAgICAgICAgXS5qb2luKFwiXFxuXCIpLCBcIlZCU2NyaXB0XCIpXG4gICAgICAgICAgICBmdW5jdGlvbiBWQk1lZGlhdG9yKGluc3RhbmNlLCBhY2Nlc3NvcnMsIG5hbWUsIHZhbHVlKSB7Ly8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgdmFyIGFjY2Vzc29yID0gYWNjZXNzb3JzW25hbWVdXG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjZXNzb3IuY2FsbChpbnN0YW5jZSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc29yLmNhbGwoaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChuYW1lLCBhY2Nlc3NvcnMsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyID0gW11cbiAgICAgICAgICAgICAgICBidWZmZXIucHVzaChcbiAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cXHRQcml2YXRlIFtfX2RhdGFfX10sIFtfX3Byb3h5X19dXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0UHVibGljIERlZmF1bHQgRnVuY3Rpb24gW19fY29uc3RfX10oZFwiK2V4cG9zZStcIiwgcFwiK2V4cG9zZStcIilcIixcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRcXHRTZXQgW19fZGF0YV9fXSA9IGRcIitleHBvc2UrXCI6IHNldCBbX19wcm94eV9fXSA9IHBcIitleHBvc2UsXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0XFx0U2V0IFtfX2NvbnN0X19dID0gTWVcIiwgLy/pk77lvI/osIPnlKhcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRFbmQgRnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAvL+a3u+WKoOaZrumAmuWxnuaApyzlm6DkuLpWQlNjcmlwdOWvueixoeS4jeiDveWDj0pT6YKj5qC36ZqP5oSP5aKe5Yig5bGe5oCn77yM5b+F6aG75Zyo6L+Z6YeM6aKE5YWI5a6a5LmJ5aW9XG4gICAgICAgICAgICAgICAgZm9yIChuYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2Nlc3NvcnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiXFx0UHVibGljIFtcIiArIG5hbWUgKyBcIl1cIilcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAkJHNraXBBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWNjZXNzb3JzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChcIlxcdFB1YmxpYyBbXCIgKyBuYW1lICsgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiXFx0UHVibGljIFtcIiArICdoYXNPd25Qcm9wZXJ0eScgKyBcIl1cIilcbiAgICAgICAgICAgICAgICAvL+a3u+WKoOiuv+mXruWZqOWxnuaAp1xuICAgICAgICAgICAgICAgIGZvciAobmFtZSBpbiBhY2Nlc3NvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+eUseS6juS4jeefpeWvueaWueS8muS8oOWFpeS7gOS5iCzlm6DmraRzZXQsIGxldOmDveeUqOS4ilxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRQdWJsaWMgUHJvcGVydHkgTGV0IFtcIiArIG5hbWUgKyBcIl0odmFsXCIgKyBleHBvc2UgKyBcIilcIiwgLy9zZXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0XFx0Q2FsbCBbX19wcm94eV9fXShNZSxbX19kYXRhX19dLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCB2YWxcIiArIGV4cG9zZSArIFwiKVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRFbmQgUHJvcGVydHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0UHVibGljIFByb3BlcnR5IFNldCBbXCIgKyBuYW1lICsgXCJdKHZhbFwiICsgZXhwb3NlICsgXCIpXCIsIC8vc2V0dGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFxcdENhbGwgW19fcHJveHlfX10oTWUsW19fZGF0YV9fXSwgXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgdmFsXCIgKyBleHBvc2UgKyBcIilcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0RW5kIFByb3BlcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFB1YmxpYyBQcm9wZXJ0eSBHZXQgW1wiICsgbmFtZSArIFwiXVwiLCAvL2dldHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRPbiBFcnJvciBSZXN1bWUgTmV4dFwiLCAvL+W/hemhu+S8mOWFiOS9v+eUqHNldOivreWPpSzlkKbliJnlroPkvJror6/lsIbmlbDnu4TlvZPlrZfnrKbkuLLov5Tlm55cbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0XFx0U2V0W1wiICsgbmFtZSArIFwiXSA9IFtfX3Byb3h5X19dKE1lLFtfX2RhdGFfX10sXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0SWYgRXJyLk51bWJlciA8PiAwIFRoZW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0XFx0W1wiICsgbmFtZSArIFwiXSA9IFtfX3Byb3h5X19dKE1lLFtfX2RhdGFfX10sXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0RW5kIElmXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdE9uIEVycm9yIEdvdG8gMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRFbmQgUHJvcGVydHlcIilcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiRW5kIENsYXNzXCIpXG4gICAgICAgICAgICAgICAgdmFyIGJvZHkgPSBidWZmZXIuam9pbihcIlxcclxcblwiKVxuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPVZCQ2xhc3NQb29sW2JvZHldXG4gICAgICAgICAgICAgICAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gZ2VuZXJhdGVJRChcIlZCQ2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnBhcnNlVkIoXCJDbGFzcyBcIiArIGNsYXNzTmFtZSArIGJvZHkpXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5wYXJzZVZCKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIkZhY3RvcnkoYSwgYilcIiwgLy/liJvlu7rlrp7kvovlubbkvKDlhaXkuKTkuKrlhbPplK7nmoTlj4LmlbBcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0RGltIG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0U2V0IG8gPSAoTmV3IFwiICsgY2xhc3NOYW1lICsgXCIpKGEsIGIpXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFNldCBcIiArIGNsYXNzTmFtZSArIFwiRmFjdG9yeSA9IG9cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiRW5kIEZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKFwiXFxyXFxuXCIpKVxuICAgICAgICAgICAgICAgICAgICBWQkNsYXNzUG9vbFtib2R5XSA9IGNsYXNzTmFtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmV0ID0gd2luZG93W2NsYXNzTmFtZSArIFwiRmFjdG9yeVwiXShhY2Nlc3NvcnMsIFZCTWVkaWF0b3IpIC8v5b6X5Yiw5YW25Lqn5ZOBXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldCAvL+W+l+WIsOWFtuS6p+WTgVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqICAgICAgICAgIOebkeaOp+aVsOe7hO+8iOS4jm1zLWVhY2gsIG1zLXJlcGVhdOmFjeWQiOS9v+eUqO+8iSAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGZ1bmN0aW9uIGFycmF5RmFjdG9yeShtb2RlbCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBbXVxuICAgICAgICBhcnJheS4kaWQgPSBnZW5lcmF0ZUlEKClcbiAgICAgICAgYXJyYXkuJG1vZGVsID0gbW9kZWwgLy/mlbDmja7mqKHlnotcbiAgICAgICAgYXJyYXkuJGV2ZW50cyA9IHt9XG4gICAgICAgIGFycmF5LiRldmVudHNbc3Vic2NyaWJlcnNdID0gW11cbiAgICAgICAgYXJyYXkuXyA9IG1vZGVsRmFjdG9yeSh7XG4gICAgICAgICAgICBsZW5ndGg6IG1vZGVsLmxlbmd0aFxuICAgICAgICB9KVxuICAgICAgICBhcnJheS5fLiR3YXRjaChcImxlbmd0aFwiLCBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgYXJyYXkuJGZpcmUoXCJsZW5ndGhcIiwgYSwgYilcbiAgICAgICAgfSlcbiAgICAgICAgZm9yICh2YXIgaSBpbiBFdmVudEJ1cykge1xuICAgICAgICAgICAgYXJyYXlbaV0gPSBFdmVudEJ1c1tpXVxuICAgICAgICB9XG4gICAgICAgIGF2YWxvbi5taXgoYXJyYXksIGFycmF5UHJvdG90eXBlKVxuICAgICAgICByZXR1cm4gYXJyYXlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtdXRhdGVBcnJheShtZXRob2QsIHBvcywgbiwgaW5kZXgsIG1ldGhvZDIsIHBvczIsIG4yKSB7XG4gICAgICAgIHZhciBvbGRMZW4gPSB0aGlzLmxlbmd0aCwgbG9vcCA9IDJcbiAgICAgICAgd2hpbGUgKC0tbG9vcCkge1xuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWRkXCI6XG4gICAgICAgICAgICAgICAgICAgIC8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gdGhpcy4kbW9kZWwuc2xpY2UocG9zLCBwb3MgKyBuKS5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmNvbXBsZXhUeXBlLnRlc3QoYXZhbG9uLnR5cGUoZWwpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbC4kaWQgPyBlbCA6IG1vZGVsRmFjdG9yeShlbCwgMCwgZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAvKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuICAgICAgICAgICAgICAgICAgICBfc3BsaWNlLmFwcGx5KHRoaXMsIFtwb3MsIDBdLmNvbmNhdChhcnJheSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoXCJhZGRcIiwgcG9zLCBuKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHRoaXMuX3NwbGljZShwb3MsIG4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoXCJkZWxcIiwgcG9zLCBuKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGhvZDIpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBtZXRob2QyXG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMlxuICAgICAgICAgICAgICAgIG4gPSBuMlxuICAgICAgICAgICAgICAgIGxvb3AgPSAyXG4gICAgICAgICAgICAgICAgbWV0aG9kMiA9IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXJlKFwiaW5kZXhcIiwgaW5kZXgpXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gb2xkTGVuKSB7XG4gICAgICAgICAgICB0aGlzLl8ubGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgdmFyIF9zcGxpY2UgPSBhcC5zcGxpY2VcbiAgICB2YXIgYXJyYXlQcm90b3R5cGUgPSB7XG4gICAgICAgIF9zcGxpY2U6IF9zcGxpY2UsXG4gICAgICAgIF9maXJlOiBmdW5jdGlvbiAobWV0aG9kLCBhLCBiKSB7XG4gICAgICAgICAgICBmaXJlRGVwZW5kZW5jaWVzKHRoaXMuJGV2ZW50c1tzdWJzY3JpYmVyc10sIG1ldGhvZCwgYSwgYilcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24gKCkgeyAvL+WPluW+l+aVsOe7hOmVv+W6pu+8jOi/meS4quWHveaVsOWPr+S7peWQjOatpeinhuWbvu+8jGxlbmd0aOS4jeiDvVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuXy5sZW5ndGhcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaEFycmF5OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBtID0gYXJyYXkubGVuZ3RoLCBuID0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgYXAucHVzaC5hcHBseSh0aGlzLiRtb2RlbCwgYXJyYXkpXG4gICAgICAgICAgICAgICAgbXV0YXRlQXJyYXkuY2FsbCh0aGlzLCBcImFkZFwiLCBuLCBtLCBNYXRoLm1heCgwLCBuIC0gMSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIG0gKyBuXG4gICAgICAgIH0sXG4gICAgICAgIHB1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gW11cbiAgICAgICAgICAgIHZhciBpLCBuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gYXJndW1lbnRzW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wdXNoQXJyYXkoYXJyYXkpXG4gICAgICAgIH0sXG4gICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBtID0gYXJndW1lbnRzLmxlbmd0aCwgbiA9IHRoaXMubGVuZ3RoXG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGFwLnVuc2hpZnQuYXBwbHkodGhpcy4kbW9kZWwsIGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICBtdXRhdGVBcnJheS5jYWxsKHRoaXMsIFwiYWRkXCIsIDAsIG0sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIG0gKyBuIC8vSUU2N+eahHVuc2hpZnTkuI3kvJrov5Tlm57plb/luqZcbiAgICAgICAgfSxcbiAgICAgICAgc2hpZnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IHRoaXMuJG1vZGVsLnNoaWZ0KClcbiAgICAgICAgICAgICAgICBtdXRhdGVBcnJheS5jYWxsKHRoaXMsIFwiZGVsXCIsIDAsIDEsIDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsIC8v6L+U5Zue6KKr56e76Zmk55qE5YWD57SgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmxlbmd0aFxuICAgICAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB0aGlzLiRtb2RlbC5wb3AoKVxuICAgICAgICAgICAgICAgIG11dGF0ZUFycmF5LmNhbGwodGhpcywgXCJkZWxcIiwgbiAtIDEsIDEsIE1hdGgubWF4KDAsIG4gLSAyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwgLy/ov5Tlm57ooqvnp7vpmaTnmoTlhYPntKBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3BsaWNlOiBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBtID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IFtdLCBjaGFuZ2VcbiAgICAgICAgICAgIHZhciByZW1vdmVkID0gX3NwbGljZS5hcHBseSh0aGlzLiRtb2RlbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoKSB7IC8v5aaC5p6c55So5oi35Yig5o6J5LqG5YWD57SgXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKFwiZGVsXCIsIHN0YXJ0LCByZW1vdmVkLmxlbmd0aCwgMClcbiAgICAgICAgICAgICAgICBjaGFuZ2UgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobSA+IDIpIHsgIC8v5aaC5p6c55So5oi35re75Yqg5LqG5YWD57SgXG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnNwbGljZSgzLCAxLCAwLCBcImFkZFwiLCBzdGFydCwgbSAtIDIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKFwiYWRkXCIsIHN0YXJ0LCBtIC0gMiwgMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYW5nZSkgeyAvL+i/lOWbnuiiq+enu+mZpOeahOWFg+e0oFxuICAgICAgICAgICAgICAgIHJldHVybiBtdXRhdGVBcnJheS5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uIChlbCkgeyAvL+WIpOWumuaYr+WQpuWMheWQq1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZihlbCkgIT09IC0xXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGVsKSB7IC8v56e76Zmk56ys5LiA5Liq562J5LqO57uZ5a6a5YC855qE5YWD57SgXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVBdCh0aGlzLmluZGV4T2YoZWwpKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVBdDogZnVuY3Rpb24gKGluZGV4KSB7IC8v56e76Zmk5oyH5a6a57Si5byV5LiK55qE5YWD57SgXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJG1vZGVsLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbXV0YXRlQXJyYXkuY2FsbCh0aGlzLCBcImRlbFwiLCBpbmRleCwgMSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAgW11cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJG1vZGVsLmxlbmd0aCA9IHRoaXMubGVuZ3RoID0gdGhpcy5fLmxlbmd0aCA9IDAgLy/muIXnqbrmlbDnu4RcbiAgICAgICAgICAgIHRoaXMuX2ZpcmUoXCJjbGVhclwiLCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlQWxsOiBmdW5jdGlvbiAoYWxsKSB7IC8v56e76ZmkTuS4quWFg+e0oFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWxsKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGwuaW5kZXhPZih0aGlzW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXQoaSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGFsbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZm9yICggaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsID0gdGhpc1tpXVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsKGVsLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdChpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5zdXJlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250YWlucyhlbCkpIHsgLy/lj6rmnInkuI3lrZjlnKjmiY1wdXNoXG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGVsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoaW5kZXgsIHZhbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4IDwgdGhpcy5sZW5ndGggJiYgaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSBhdmFsb24udHlwZSh2YWwpXG4gICAgICAgICAgICAgICAgaWYgKHZhbCAmJiB2YWwuJG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC4kbW9kZWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXNbaW5kZXhdXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlVHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IHZhbFtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2xlYXIoKS5wdXNoLmFwcGx5KHRhcmdldCwgdmFsKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpbmRleF0gPSB2YWxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbW9kZWxbaW5kZXhdID0gdmFsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoXCJzZXRcIiwgaW5kZXgsIHZhbClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgfVxuLy/nm7jlvZPkuo7ljp/mnaViaW5kaW5nRXhlY3V0b3JzLnJlcGVhdCDnmoRpbmRleOWIhuaUr1xuICAgIGZ1bmN0aW9uIHJlc2V0SW5kZXgoYXJyYXksIHBvcykge1xuICAgICAgICB2YXIgbGFzdCA9IGFycmF5Lmxlbmd0aCAtIDFcbiAgICAgICAgZm9yICh2YXIgZWw7IGVsID0gYXJyYXlbcG9zXTsgcG9zKyspIHtcbiAgICAgICAgICAgIGVsLiRpbmRleCA9IHBvc1xuICAgICAgICAgICAgZWwuJGZpcnN0ID0gcG9zID09PSAwXG4gICAgICAgICAgICBlbC4kbGFzdCA9IHBvcyA9PT0gbGFzdFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc29ydEJ5SW5kZXgoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGluZGV4ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBtYXBbaV0gPSBhcnJheVtpXSAvLyBwcmVzZXJ2ZVxuICAgICAgICAgICAgdmFyIGogPSBpbmRleGVzW2ldXG4gICAgICAgICAgICBpZiAoaiBpbiBtYXApIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IG1hcFtqXVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbal1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgXCJzb3J0LHJldmVyc2VcIi5yZXBsYWNlKHJ3b3JkLCBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIGFycmF5UHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbmV3QXJyYXkgPSB0aGlzLiRtb2RlbC8v6L+Z5piv6KaB5o6S5bqP55qE5paw5pWw57uEXG4gICAgICAgICAgICB2YXIgb2xkQXJyYXkgPSBuZXdBcnJheS5jb25jYXQoKSAvL+S/neaMgeWOn+adpeeKtuaAgeeahOaXp+aVsOe7hFxuICAgICAgICAgICAgdmFyIG1hc2sgPSBNYXRoLnJhbmRvbSgpXG4gICAgICAgICAgICB2YXIgaW5kZXhlcyA9IFtdXG4gICAgICAgICAgICB2YXIgaGFzU29ydFxuICAgICAgICAgICAgYXBbbWV0aG9kXS5hcHBseShuZXdBcnJheSwgYXJndW1lbnRzKSAvL+aOkuW6j1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvbGRBcnJheS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmVvID0gbmV3QXJyYXlbaV1cbiAgICAgICAgICAgICAgICB2YXIgb2xkID0gb2xkQXJyYXlbaV1cbiAgICAgICAgICAgICAgICBpZiAoaXNFcXVhbChuZW8sIG9sZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb2xkQXJyYXkuaW5kZXhPZihuZW8pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCkvL+W+l+WIsOaWsOaVsOe7hOeahOavj+S4quWFg+e0oOWcqOaXp+aVsOe7hOWvueW6lOeahOS9jee9rlxuICAgICAgICAgICAgICAgICAgICBvbGRBcnJheVtpbmRleF0gPSBtYXNrICAgIC8v5bGP6JS95bey57uP5om+6L+H55qE5YWD57SgXG4gICAgICAgICAgICAgICAgICAgIGhhc1NvcnQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1NvcnQpIHtcbiAgICAgICAgICAgICAgICBzb3J0QnlJbmRleCh0aGlzLCBpbmRleGVzKVxuICAgICAgICAgICAgICAgIC8vIHNvcnRCeUluZGV4KHRoaXMuJHByb3h5LCBpbmRleGVzKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpcmUoXCJtb3ZlXCIsIGluZGV4ZXMpXG4gICAgICAgICAgICAgICAgdGhpcy5fZmlyZShcImluZGV4XCIsIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9XG4gICAgfSlcblxuXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAg5L6d6LWW6LCD5bqm57O757ufICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vL+ajgOa1i+S4pOS4quWvueixoemXtOeahOS+nei1luWFs+ezu1xuICAgIHZhciBkZXBlbmRlbmN5RGV0ZWN0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dGVyRnJhbWVzID0gW11cbiAgICAgICAgdmFyIGN1cnJlbnRGcmFtZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmVnaW46IGZ1bmN0aW9uIChhY2Nlc3Nvck9iamVjdCkge1xuICAgICAgICAgICAgICAgIC8vYWNjZXNzb3JPYmplY3TkuLrkuIDkuKrmi6XmnIljYWxsYmFja+eahOWvueixoVxuICAgICAgICAgICAgICAgIG91dGVyRnJhbWVzLnB1c2goY3VycmVudEZyYW1lKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRGcmFtZSA9IGFjY2Vzc29yT2JqZWN0XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEZyYW1lID0gb3V0ZXJGcmFtZXMucG9wKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xsZWN0RGVwZW5kZW5jeTogZnVuY3Rpb24gKHZtb2RlbCwgYWNjZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8v6KKrZGVwZW5kZW5jeURldGVjdGlvbi5iZWdpbuiwg+eUqFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWUuY2FsbGJhY2sodm1vZGVsLCBhY2Nlc3Nvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pKClcbi8v5bCG57uR5a6a5a+56LGh5rOo5YWl5Yiw5YW25L6d6LWW6aG555qE6K6i6ZiF5pWw57uE5LitXG4gICAgdmFyIHJvbmR1cGxleCA9IC9eKGR1cGxleHxvbikkL1xuICAgIGF2YWxvbi5pbmplY3RCaW5kaW5nID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbHVlRm4gPSBkYXRhLmV2YWx1YXRvclxuICAgICAgICBpZiAodmFsdWVGbikgeyAvL+WmguaenOaYr+axguWAvOWHveaVsFxuICAgICAgICAgICAgZGVwZW5kZW5jeURldGVjdGlvbi5iZWdpbih7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uICh2bW9kZWwsIGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5qZWN0RGVwZW5kZW5jeSh2bW9kZWwuJGV2ZW50c1tkZXBlbmRlbmN5Ll9uYW1lXSwgZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSByb25kdXBsZXgudGVzdChkYXRhLnR5cGUpID8gZGF0YSA6IHZhbHVlRm4uYXBwbHkoMCwgZGF0YS5hcmdzKVxuICAgICAgICAgICAgICAgIGlmKHZhbHVlID09PSB2b2lkIDApe1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5ldmFsdWF0b3JcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmhhbmRsZXIodmFsdWUsIGRhdGEuZWxlbWVudCwgZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwid2FybmluZzpleGNlcHRpb24gdGhyb3dlZCBpbiBbYXZhbG9uLmluamVjdEJpbmRpbmddIFwiICwgZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YS5ldmFsdWF0b3JcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGRhdGEuZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2VybmVsLmNvbW1lbnRJbnRlcnBvbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChET0MuY3JlYXRlQ29tbWVudChkYXRhLnZhbHVlKSwgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IG9wZW5UYWcgKyAoZGF0YS5vbmVUaW1lID8gXCI6OlwiIDogXCJcIikgKyBkYXRhLnZhbHVlICsgY2xvc2VUYWdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jeURldGVjdGlvbi5lbmQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4vL+WwhuS+nei1lumhuSjmr5TlroPpq5jlsYLnmoTorr/pl67lmajmiJbmnoTlu7rop4blm77liLfmlrDlh73mlbDnmoTnu5Hlrprlr7nosaEp5rOo5YWl5Yiw6K6i6ZiF6ICF5pWw57uEXG4gICAgZnVuY3Rpb24gaW5qZWN0RGVwZW5kZW5jeShsaXN0LCBkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhLm9uZVRpbWUpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgaWYgKGxpc3QgJiYgYXZhbG9uLkFycmF5LmVuc3VyZShsaXN0LCBkYXRhKSAmJiBkYXRhLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluamVjdERpc3Bvc2VRdWV1ZShkYXRhLCBsaXN0KVxuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkgLSBiZWdpblRpbWUgPiA0NDQgKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0RGlzcG9zZVF1ZXVlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuLy/pgJrnn6Xkvp3otZbkuo7ov5nkuKrorr/pl67lmajnmoTorqLpmIXogIXmm7TmlrDoh6rouqtcbiAgICBmdW5jdGlvbiBmaXJlRGVwZW5kZW5jaWVzKGxpc3QpIHtcbiAgICAgICAgaWYgKGxpc3QgJiYgbGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpIC0gYmVnaW5UaW1lID4gNDQ0ICYmIHR5cGVvZiBsaXN0WzBdID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0RGlzcG9zZVF1ZXVlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhcmdzID0gYXNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoLCBmbjsgZm4gPSBsaXN0Wy0taV07ICkge1xuICAgICAgICAgICAgICAgIHZhciBlbCA9IGZuLmVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZWwgJiYgZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlRm4gPSBmbi5ldmFsdWF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbi4kcmVwZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uaGFuZGxlci5hcHBseShmbiwgYXJncykgLy/lpITnkIbnm5HmjqfmlbDnu4TnmoTmlrnms5VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGlmKFwiJHJlcGVhdFwiIGluIGZuIHx8ICF2YWx1ZUZuICl7Ly/lpoLmnpzmsqHmnIlldmFsLOWFiGV2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nSGFuZGxlcnNbZm4udHlwZV0oZm4sIGZuLnZtb2RlbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZuLnR5cGUgIT09IFwib25cIikgeyAvL+S6i+S7tue7keWumuWPquiDveeUseeUqOaIt+inpuWPkSzkuI3og73nlLHnqIvluo/op6blj5FcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUZuLmFwcGx5KDAsIGZuLmFyZ3MgfHwgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4uaGFuZGxlcih2YWx1ZSwgZWwsIGZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmFsb24ubG9nKGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICDlrprml7ZHQ+WbnuaUtuacuuWItiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIHZhciBkaXNwb3NlQ291bnQgPSAwXG4gICAgdmFyIGRpc3Bvc2VRdWV1ZSA9IGF2YWxvbi4kJHN1YnNjcmliZXJzID0gW11cbiAgICB2YXIgYmVnaW5UaW1lID0gbmV3IERhdGUoKVxuICAgIHZhciBvbGRJbmZvID0ge31cbi8vdmFyIHV1aWQyTm9kZSA9IHt9XG4gICAgZnVuY3Rpb24gZ2V0VWlkKGVsZW0sIG1ha2VJRCkgeyAvL0lFOSss5qCH5YeG5rWP6KeI5ZmoXG4gICAgICAgIGlmICghZWxlbS51dWlkICYmICFtYWtlSUQpIHtcbiAgICAgICAgICAgIGVsZW0udXVpZCA9ICsrZGlzcG9zZUNvdW50XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW0udXVpZFxuICAgIH1cblxuLy/mt7vliqDliLDlm57mlLbliJfpmJ/kuK1cbiAgICBmdW5jdGlvbiBpbmplY3REaXNwb3NlUXVldWUoZGF0YSwgbGlzdCkge1xuICAgICAgICB2YXIgZWxlbSA9IGRhdGEuZWxlbWVudFxuICAgICAgICBpZiAoIWRhdGEudXVpZCkge1xuICAgICAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnV1aWQgPSBkYXRhLnR5cGUgKyBnZXRVaWQoZWxlbS5wYXJlbnROb2RlKSsgXCItXCIrICgrK2Rpc3Bvc2VDb3VudClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS51dWlkID0gZGF0YS5uYW1lICsgXCItXCIgKyBnZXRVaWQoZWxlbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdHMgPSBkYXRhLmxpc3RzIHx8IChkYXRhLmxpc3RzID0gW10pXG4gICAgICAgIGF2YWxvbi5BcnJheS5lbnN1cmUobGlzdHMsIGxpc3QpXG4gICAgICAgIGxpc3QuJHV1aWQgPSBsaXN0LiR1dWlkIHx8IGdlbmVyYXRlSUQoKVxuICAgICAgICBpZiAoIWRpc3Bvc2VRdWV1ZVtkYXRhLnV1aWRdKSB7XG4gICAgICAgICAgICBkaXNwb3NlUXVldWVbZGF0YS51dWlkXSA9IDFcbiAgICAgICAgICAgIGRpc3Bvc2VRdWV1ZS5wdXNoKGRhdGEpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWplY3REaXNwb3NlUXVldWUoZGF0YSkge1xuICAgICAgICBpZiAoYXZhbG9uLm9wdGltaXplKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIHZhciBpID0gZGlzcG9zZVF1ZXVlLmxlbmd0aFxuICAgICAgICB2YXIgbiA9IGlcbiAgICAgICAgdmFyIGFsbFR5cGVzID0gW11cbiAgICAgICAgdmFyIGlmZmlzaFR5cGVzID0ge31cbiAgICAgICAgdmFyIG5ld0luZm8gPSB7fVxuICAgICAgICAvL+WvuemhtemdouS4iuaJgOaciee7keWumuWvueixoei/m+ihjOWIhumXqOWIq+exuywg5Y+q5qOA5rWL5Liq5pWw5Y+R55Sf5Y+Y5YyW55qE57G75Z6LXG4gICAgICAgIHdoaWxlIChkYXRhID0gZGlzcG9zZVF1ZXVlWy0taV0pIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlXG4gICAgICAgICAgICBpZiAobmV3SW5mb1t0eXBlXSkge1xuICAgICAgICAgICAgICAgIG5ld0luZm9bdHlwZV0rK1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdJbmZvW3R5cGVdID0gMVxuICAgICAgICAgICAgICAgIGFsbFR5cGVzLnB1c2godHlwZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlmZiA9IGZhbHNlXG4gICAgICAgIGFsbFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChvbGRJbmZvW3R5cGVdICE9PSBuZXdJbmZvW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgaWZmaXNoVHlwZXNbdHlwZV0gPSAxXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgaSA9IG5cbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIHdoaWxlIChkYXRhID0gZGlzcG9zZVF1ZXVlWy0taV0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5lbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VRdWV1ZS5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlmZmlzaFR5cGVzW2RhdGEudHlwZV0gJiYgc2hvdWxkRGlzcG9zZShkYXRhLmVsZW1lbnQpKSB7IC8v5aaC5p6c5a6D5rKh5pyJ5ZyoRE9N5qCRXG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VRdWV1ZS5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRpc3Bvc2VRdWV1ZVtkYXRhLnV1aWRdXG4gICAgICAgICAgICAgICAgICAgIC8vZGVsZXRlIHV1aWQyTm9kZVtkYXRhLmVsZW1lbnQudXVpZF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RzID0gZGF0YS5saXN0c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgbGlzdDsgbGlzdCA9IGxpc3RzW2srK107ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZhbG9uLkFycmF5LnJlbW92ZShsaXN0cywgbGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWxvbi5BcnJheS5yZW1vdmUobGlzdCwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkaXNwb3NlRGF0YShkYXRhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbGRJbmZvID0gbmV3SW5mb1xuICAgICAgICBiZWdpblRpbWUgPSBuZXcgRGF0ZSgpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlzcG9zZURhdGEoZGF0YSkge1xuICAgICAgICBkZWxldGUgZGlzcG9zZVF1ZXVlW2RhdGEudXVpZF0gLy8g5YWI5riF6Zmk77yM5LiN54S25peg5rOV5Zue5pS25LqGXG4gICAgICAgIGRhdGEuZWxlbWVudCA9IG51bGxcbiAgICAgICAgZGF0YS5yb2xsYmFjayAmJiBkYXRhLnJvbGxiYWNrKClcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGRhdGFba2V5XSA9IG51bGxcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3VsZERpc3Bvc2UoZWwpIHtcbiAgICAgICAgdHJ5IHsvL0lF5LiL77yM5aaC5p6c5paH5pys6IqC54K56ISx56a7RE9N5qCR77yM6K6/6ZeucGFyZW50Tm9kZeS8muaKpemUmVxuICAgICAgICAgICAgdmFyIGZpcmVFcnJvciA9IGVsLnBhcmVudE5vZGUubm9kZVR5cGVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwuaWZSZW1vdmUpIHtcbiAgICAgICAgICAgIC8vIOWmguaenOiKgueCueiiq+aUvuWIsGlmR3JvdXDvvIzmiY3np7vpmaRcbiAgICAgICAgICAgIGlmICghcm9vdC5jb250YWlucyhlbC5pZlJlbW92ZSkgJiYgKGlmR3JvdXAgPT09IGVsLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsLm1zUmV0YWluID8gMCA6IChlbC5ub2RlVHlwZSA9PT0gMSA/ICFyb290LmNvbnRhaW5zKGVsKSA6ICFhdmFsb24uY29udGFpbnMocm9vdCwgZWwpKVxuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiAgICAgICAgICAgIEhUTUzlpITnkIYocGFyc2VIVE1MLCBpbm5lckhUTUwsIGNsZWFySFRNTCkgICAgICAgICAgICAgICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MXG4gICAgdmFyIHRhZ0hvb2tzID0ge1xuICAgICAgICBhcmVhOiBbMSwgXCI8bWFwPlwiLCBcIjwvbWFwPlwiXSxcbiAgICAgICAgcGFyYW06IFsxLCBcIjxvYmplY3Q+XCIsIFwiPC9vYmplY3Q+XCJdLFxuICAgICAgICBjb2w6IFsyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiXSxcbiAgICAgICAgbGVnZW5kOiBbMSwgXCI8ZmllbGRzZXQ+XCIsIFwiPC9maWVsZHNldD5cIl0sXG4gICAgICAgIG9wdGlvbjogWzEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiXSxcbiAgICAgICAgdGhlYWQ6IFsxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgICAgICAgdHI6IFsyLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiXSxcbiAgICAgICAgdGQ6IFszLCBcIjx0YWJsZT48dHI+XCIsIFwiPC90cj48L3RhYmxlPlwiXSxcbiAgICAgICAgZzogWzEsICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB2ZXJzaW9uPVwiMS4xXCI+JywgJzwvc3ZnPiddLFxuICAgICAgICAvL0lFNi045Zyo55SoaW5uZXJIVE1M55Sf5oiQ6IqC54K55pe277yM5LiN6IO955u05o6l5Yib5bu6bm8tc2NvcGXlhYPntKDkuI5IVE1MNeeahOaWsOagh+etvlxuICAgICAgICBfZGVmYXVsdDogVzNDID8gWzAsIFwiXCIsIFwiXCJdIDogWzEsIFwiWDxkaXY+XCIsIFwiPC9kaXY+XCJdIC8vZGl25Y+v5Lul5LiN55So6Zet5ZCIXG4gICAgfVxuICAgIHRhZ0hvb2tzLnRoID0gdGFnSG9va3MudGRcbiAgICB0YWdIb29rcy5vcHRncm91cCA9IHRhZ0hvb2tzLm9wdGlvblxuICAgIHRhZ0hvb2tzLnRib2R5ID0gdGFnSG9va3MudGZvb3QgPSB0YWdIb29rcy5jb2xncm91cCA9IHRhZ0hvb2tzLmNhcHRpb24gPSB0YWdIb29rcy50aGVhZFxuICAgIFN0cmluZyhcImNpcmNsZSxkZWZzLGVsbGlwc2UsaW1hZ2UsbGluZSxwYXRoLHBvbHlnb24scG9seWxpbmUscmVjdCxzeW1ib2wsdGV4dCx1c2VcIikucmVwbGFjZShyd29yZCwgZnVuY3Rpb24gKHRhZykge1xuICAgICAgICB0YWdIb29rc1t0YWddID0gdGFnSG9va3MuZyAvL+WkhOeQhlNWR1xuICAgIH0pXG4gICAgdmFyIHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvICAvL+WPluW+l+WFtnRhZ05hbWVcbiAgICB2YXIgcnhodG1sID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2lnXG4gICAgdmFyIHJjcmVhdGUgPSBXM0MgPyAvW15cXGRcXERdLyA6IC8oPCg/OnNjcmlwdHxsaW5rfHN0eWxlfG1ldGF8bm9zY3JpcHQpKS9pZ1xuICAgIHZhciBzY3JpcHRUeXBlcyA9IG9uZU9iamVjdChbXCJcIiwgXCJ0ZXh0L2phdmFzY3JpcHRcIiwgXCJ0ZXh0L2VjbWFzY3JpcHRcIiwgXCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0XCIsIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiXSlcbiAgICB2YXIgcm5lc3QgPSAvPCg/OnRifHRkfHRmfHRofHRyfGNvbHxvcHR8bGVnfGNhcHxhcmVhKS8gLy/pnIDopoHlpITnkIblpZfltYzlhbPns7vnmoTmoIfnrb5cbiAgICB2YXIgc2NyaXB0ID0gRE9DLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIilcbiAgICB2YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy9cbiAgICBhdmFsb24ucGFyc2VIVE1MID0gZnVuY3Rpb24gKGh0bWwpIHtcbiAgICAgICAgdmFyIGZyYWdtZW50ID0gYXZhbG9uRnJhZ21lbnQuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgICBpZiAodHlwZW9mIGh0bWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudFxuICAgICAgICB9XG4gICAgICAgIGlmICghcmh0bWwudGVzdChodG1sKSkge1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoRE9DLmNyZWF0ZVRleHROb2RlKGh0bWwpKVxuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCA9IGh0bWwucmVwbGFjZShyeGh0bWwsIFwiPCQxPjwvJDI+XCIpLnRyaW0oKVxuICAgICAgICB2YXIgdGFnID0gKHJ0YWdOYW1lLmV4ZWMoaHRtbCkgfHwgW1wiXCIsIFwiXCJdKVsxXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAvL+WPluW+l+WFtuagh+etvuWQjVxuICAgICAgICAgICAgd3JhcCA9IHRhZ0hvb2tzW3RhZ10gfHwgdGFnSG9va3MuX2RlZmF1bHQsXG4gICAgICAgICAgICB3cmFwcGVyID0gY2luZXJhdG9yLFxuICAgICAgICAgICAgZmlyc3RDaGlsZCwgbmVvXG4gICAgICAgIGlmICghVzNDKSB7IC8vZml4IElFXG4gICAgICAgICAgICBodG1sID0gaHRtbC5yZXBsYWNlKHJjcmVhdGUsIFwiPGJyIGNsYXNzPW1zTm9TY29wZT4kMVwiKSAvL+WcqGxpbmsgc3R5bGUgc2NyaXB0562J5qCH562+5LmL5YmN5re75Yqg5LiA5Liq6KGl5LiBXG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSB3cmFwWzFdICsgaHRtbCArIHdyYXBbMl1cbiAgICAgICAgdmFyIGVscyA9IHdyYXBwZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIilcbiAgICAgICAgaWYgKGVscy5sZW5ndGgpIHsgLy/kvb/nlKhpbm5lckhUTUznlJ/miJDnmoRzY3JpcHToioLngrnkuI3kvJrlj5Hlh7ror7fmsYLkuI7miafooYx0ZXh05bGe5oCnXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgZWw7IGVsID0gZWxzW2krK107ICkge1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHRUeXBlc1tlbC50eXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAvL+S7peWBt+m+mei9rOWHpOaWueW8j+aBouWkjeaJp+ihjOiEmuacrOWKn+iDvVxuICAgICAgICAgICAgICAgICAgICBuZW8gPSBzY3JpcHQuY2xvbmVOb2RlKGZhbHNlKSAvL0ZG5LiN6IO955yB55Wl5Y+C5pWwXG4gICAgICAgICAgICAgICAgICAgIGFwLmZvckVhY2guY2FsbChlbC5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIgJiYgYXR0ci5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZW9bYXR0ci5uYW1lXSA9IGF0dHIudmFsdWUgLy/lpI3liLblhbblsZ7mgKdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZW8uc2V0QXR0cmlidXRlKGF0dHIubmFtZSwgYXR0ci52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgICAgICBuZW8udGV4dCA9IGVsLnRleHRcbiAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmVvLCBlbCkgLy/mm7/mjaLoioLngrlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFXM0MpIHsgLy9maXggSUVcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB3cmFwWzFdID09PSBcIlg8ZGl2PlwiID8gd3JhcHBlci5sYXN0Q2hpbGQuZmlyc3RDaGlsZCA6IHdyYXBwZXIubGFzdENoaWxkXG4gICAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lID09PSBcIlRBQkxFXCIgJiYgdGFnICE9PSBcInRib2R5XCIpIHtcbiAgICAgICAgICAgICAgICAvL0lFNi035aSE55CGIDx0aGVhZD4gLS0+IDx0aGVhZD4sPHRib2R5PlxuICAgICAgICAgICAgICAgIC8vPHRmb290PiAtLT4gPHRmb290Piw8dGJvZHk+XG4gICAgICAgICAgICAgICAgLy88dGFibGU+IC0tPiA8dGFibGU+PHRib2R5PjwvdGFibGU+XG4gICAgICAgICAgICAgICAgZm9yIChlbHMgPSB0YXJnZXQuY2hpbGROb2RlcywgaSA9IDA7IGVsID0gZWxzW2krK107ICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWwudGFnTmFtZSA9PT0gXCJUQk9EWVwiICYmICFlbC5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVDaGlsZChlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHMgPSB3cmFwcGVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYnJcIilcbiAgICAgICAgICAgIHZhciBuID0gZWxzLmxlbmd0aFxuICAgICAgICAgICAgd2hpbGUgKGVsID0gZWxzWy0tbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NOYW1lID09PSBcIm1zTm9TY29wZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChlbHMgPSB3cmFwcGVyLmFsbCwgaSA9IDA7IGVsID0gZWxzW2krK107ICkgeyAvL2ZpeCBWTUxcbiAgICAgICAgICAgICAgICBpZiAoaXNWTUwoZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpeFZNTChlbClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy/np7vpmaTmiJHku6zkuLrkuobnrKblkIjlpZfltYzlhbPns7vogIzmt7vliqDnmoTmoIfnrb5cbiAgICAgICAgZm9yIChpID0gd3JhcFswXTsgaS0tOyB3cmFwcGVyID0gd3JhcHBlci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZmlyc3RDaGlsZCA9IHdyYXBwZXIuZmlyc3RDaGlsZCkgeyAvLyDlsIZ3cmFwcGVy5LiK55qE6IqC54K56L2s56e75Yiw5paH5qGj56KO54mH5LiK77yBXG4gICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVk1MKHNyYykge1xuICAgICAgICB2YXIgbm9kZU5hbWUgPSBzcmMubm9kZU5hbWVcbiAgICAgICAgcmV0dXJuIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lICYmIHNyYy5zY29wZU5hbWUgJiYgc3JjLm91dGVyVGV4dCA9PT0gXCJcIlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeFZNTChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmN1cnJlbnRTdHlsZS5iZWhhdmlvciAhPT0gXCJ1cmwoI2RlZmF1bHQjVk1MKVwiKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmJlaGF2aW9yID0gXCJ1cmwoI2RlZmF1bHQjVk1MKVwiXG4gICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiXG4gICAgICAgICAgICBub2RlLnN0eWxlLnpvb20gPSAxIC8vaGFzTGF5b3V0XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXZhbG9uLmlubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgICAgIGlmICghVzNDICYmICghcmNyZWF0ZS50ZXN0KGh0bWwpICYmICFybmVzdC50ZXN0KGh0bWwpKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub2RlLmlubmVySFRNTCA9IGh0bWxcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYSA9IHRoaXMucGFyc2VIVE1MKGh0bWwpXG4gICAgICAgIHRoaXMuY2xlYXJIVE1MKG5vZGUpLmFwcGVuZENoaWxkKGEpXG4gICAgfVxuICAgIGF2YWxvbi5jbGVhckhUTUwgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLnRleHRDb250ZW50ID0gXCJcIlxuICAgICAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZVxuICAgIH1cblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiAgICAgICAgICAgICAgICAgIGF2YWxvbueahOWOn+Wei+aWueazleWumuS5ieWMuiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICBmdW5jdGlvbiBoeXBoZW4odGFyZ2V0KSB7XG4gICAgICAgIC8v6L2s5o2i5Li66L+e5a2X56ym57q/6aOO5qC8XG4gICAgICAgIHJldHVybiB0YXJnZXQucmVwbGFjZSgvKFthLXpcXGRdKShbQS1aXSspL2csIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbWVsaXplKHRhcmdldCkge1xuICAgICAgICAvL+aPkOWJjeWIpOaWre+8jOaPkOmrmGdldFN0eWxl562J55qE5pWI546HXG4gICAgICAgIGlmICghdGFyZ2V0IHx8IHRhcmdldC5pbmRleE9mKFwiLVwiKSA8IDAgJiYgdGFyZ2V0LmluZGV4T2YoXCJfXCIpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldFxuICAgICAgICB9XG4gICAgICAgIC8v6L2s5o2i5Li66am85bOw6aOO5qC8XG4gICAgICAgIHJldHVybiB0YXJnZXQucmVwbGFjZSgvWy1fXVteLV9dL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgdmFyIGZha2VDbGFzc0xpc3RNZXRob2RzID0ge1xuICAgICAgICBfdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlXG4gICAgICAgICAgICB2YXIgY2xzID0gbm9kZS5jbGFzc05hbWVcbiAgICAgICAgICAgIHZhciBzdHIgPSB0eXBlb2YgY2xzID09PSBcInN0cmluZ1wiID8gY2xzIDogY2xzLmJhc2VWYWxcbiAgICAgICAgICAgIHJldHVybiBzdHIuc3BsaXQoL1xccysvKS5qb2luKFwiIFwiKVxuICAgICAgICB9LFxuICAgICAgICBfY29udGFpbnM6IGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAoXCIgXCIgKyB0aGlzICsgXCIgXCIpLmluZGV4T2YoXCIgXCIgKyBjbHMgKyBcIiBcIikgPiAtMVxuICAgICAgICB9LFxuICAgICAgICBfYWRkOiBmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbnMoY2xzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldCh0aGlzICsgXCIgXCIgKyBjbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9yZW1vdmU6IGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldCgoXCIgXCIgKyB0aGlzICsgXCIgXCIpLnJlcGxhY2UoXCIgXCIgKyBjbHMgKyBcIiBcIiwgXCIgXCIpKVxuICAgICAgICB9LFxuICAgICAgICBfX3NldDogZnVuY3Rpb24gKGNscykge1xuICAgICAgICAgICAgY2xzID0gY2xzLnRyaW0oKVxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICAgICAgICAgIGlmIChyc3ZnLnRlc3Qobm9kZSkpIHtcbiAgICAgICAgICAgICAgICAvL1NWR+WFg+e0oOeahGNsYXNzTmFtZeaYr+S4gOS4quWvueixoSBTVkdBbmltYXRlZFN0cmluZyB7IGJhc2VWYWw9XCJcIiwgYW5pbVZhbD1cIlwife+8jOWPquiDvemAmui/h3NldC9nZXRBdHRyaWJ1dGXmk43kvZxcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIGNscylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSBjbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvL3RvZ2dsZeWtmOWcqOeJiOacrOW3ruW8gu+8jOWboOatpOS4jeS9v+eUqOWug1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZha2VDbGFzc0xpc3Qobm9kZSkge1xuICAgICAgICBpZiAoIShcImNsYXNzTGlzdFwiIGluIG5vZGUpKSB7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdCA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGZha2VDbGFzc0xpc3RNZXRob2RzKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3Rbay5zbGljZSgxKV0gPSBmYWtlQ2xhc3NMaXN0TWV0aG9kc1trXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdFxuICAgIH1cblxuXG4gICAgXCJhZGQscmVtb3ZlXCIucmVwbGFjZShyd29yZCwgZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICBhdmFsb24uZm5bbWV0aG9kICsgXCJDbGFzc1wiXSA9IGZ1bmN0aW9uIChjbHMpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IHRoaXNbMF1cbiAgICAgICAgICAgIC8vaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9Nb3ppbGxhL0ZpcmVmb3gvUmVsZWFzZXMvMjZcbiAgICAgICAgICAgIGlmIChjbHMgJiYgdHlwZW9mIGNscyA9PT0gXCJzdHJpbmdcIiAmJiBlbCAmJiBlbC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNscy5yZXBsYWNlKC9cXFMrL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgICAgIGZha2VDbGFzc0xpc3QoZWwpW21ldGhvZF0oYylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfVxuICAgIH0pXG4gICAgYXZhbG9uLmZuLm1peCh7XG4gICAgICAgIGhhc0NsYXNzOiBmdW5jdGlvbiAoY2xzKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzWzBdIHx8IHt9XG4gICAgICAgICAgICByZXR1cm4gZWwubm9kZVR5cGUgPT09IDEgJiYgZmFrZUNsYXNzTGlzdChlbCkuY29udGFpbnMoY2xzKVxuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVDbGFzczogZnVuY3Rpb24gKHZhbHVlLCBzdGF0ZVZhbCkge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSwgaSA9IDBcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWVzID0gU3RyaW5nKHZhbHVlKS5zcGxpdCgvXFxzKy8pXG4gICAgICAgICAgICB2YXIgaXNCb29sID0gdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIlxuICAgICAgICAgICAgd2hpbGUgKChjbGFzc05hbWUgPSBjbGFzc05hbWVzW2krK10pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXRlID0gaXNCb29sID8gc3RhdGVWYWwgOiAhdGhpcy5oYXNDbGFzcyhjbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgdGhpc1tzdGF0ZSA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oY2xhc3NOYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgIHRoaXNbMF0uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLmdldEF0dHJpYnV0ZShuYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkYXRhOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImRhdGEtXCIgKyBoeXBoZW4obmFtZSB8fCBcIlwiKVxuICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHIobmFtZSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpcy5hdHRyKG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZURhdGEodmFsKVxuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IHt9XG4gICAgICAgICAgICAgICAgICAgIGFwLmZvckVhY2guY2FsbCh0aGlzWzBdLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBhdHRyLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUuaW5kZXhPZihcImRhdGEtXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lLnNsaWNlKDUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRbbmFtZV0gPSBwYXJzZURhdGEoYXR0ci52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlRGF0YTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcImRhdGEtXCIgKyBoeXBoZW4obmFtZSlcbiAgICAgICAgICAgIHRoaXNbMF0ucmVtb3ZlQXR0cmlidXRlKG5hbWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9LFxuICAgICAgICBjc3M6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGF2YWxvbi5pc1BsYWluT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGF2YWxvbi5jc3ModGhpcywgaSwgbmFtZVtpXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBhdmFsb24uY3NzKHRoaXMsIG5hbWUsIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldCAhPT0gdm9pZCAwID8gcmV0IDogdGhpc1xuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldFBhcmVudCwgb2Zmc2V0LFxuICAgICAgICAgICAgICAgIGVsZW0gPSB0aGlzWzBdLFxuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jc3MoXCJwb3NpdGlvblwiKSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpIC8v5b6X5Yiw55yf5q2j55qEb2Zmc2V0UGFyZW50XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5vZmZzZXQoKSAvLyDlvpfliLDmraPnoa7nmoRvZmZzZXRQYXJlbnRcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0UGFyZW50WzBdLnRhZ05hbWUgIT09IFwiSFRNTFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IG9mZnNldFBhcmVudC5vZmZzZXQoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnRPZmZzZXQudG9wICs9IGF2YWxvbi5jc3Mob2Zmc2V0UGFyZW50WzBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUpXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0gYXZhbG9uLmNzcyhvZmZzZXRQYXJlbnRbMF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUpXG5cbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBvZmZzZXRQYXJlbnQgc2Nyb2xsIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgLT0gb2Zmc2V0UGFyZW50LnNjcm9sbFRvcCgpXG4gICAgICAgICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgLT0gb2Zmc2V0UGFyZW50LnNjcm9sbExlZnQoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0gYXZhbG9uLmNzcyhlbGVtLCBcIm1hcmdpblRvcFwiLCB0cnVlKSxcbiAgICAgICAgICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0gYXZhbG9uLmNzcyhlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb2Zmc2V0UGFyZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gdGhpc1swXS5vZmZzZXRQYXJlbnRcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgYXZhbG9uLmNzcyhvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIikgPT09IFwic3RhdGljXCIpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF2YWxvbihvZmZzZXRQYXJlbnQgfHwgcm9vdClcbiAgICAgICAgfSxcbiAgICAgICAgYmluZDogZnVuY3Rpb24gKHR5cGUsIGZuLCBwaGFzZSkge1xuICAgICAgICAgICAgaWYgKHRoaXNbMF0pIHsgLy/mraTmlrnms5XkuI3kvJrpk75cbiAgICAgICAgICAgICAgICByZXR1cm4gYXZhbG9uLmJpbmQodGhpc1swXSwgdHlwZSwgZm4sIHBoYXNlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bmJpbmQ6IGZ1bmN0aW9uICh0eXBlLCBmbiwgcGhhc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzWzBdKSB7XG4gICAgICAgICAgICAgICAgYXZhbG9uLnVuYmluZCh0aGlzWzBdLCB0eXBlLCBmbiwgcGhhc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9LFxuICAgICAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzWzBdXG4gICAgICAgICAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdldCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICB2YXIgYWNjZXNzID0gZ2V0ID8gXCI6Z2V0XCIgOiBcIjpzZXRcIlxuICAgICAgICAgICAgICAgIHZhciBmbiA9IHZhbEhvb2tzW2dldFZhbFR5cGUobm9kZSkgKyBhY2Nlc3NdXG4gICAgICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBmbihub2RlLCB2YWx1ZSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5vZGUudmFsdWUgfHwgXCJcIikucmVwbGFjZSgvXFxyL2csIFwiXCIpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldCA/IHZhbCA6IHRoaXNcbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBwYXJzZURhdGEoZGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhXG4gICAgICAgICAgICBkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcbiAgICAgICAgICAgICAgICBkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6ICtkYXRhICsgXCJcIiA9PT0gZGF0YSA/ICtkYXRhIDogcmJyYWNlLnRlc3QoZGF0YSkgPyBhdmFsb24ucGFyc2VKU09OKGRhdGEpIDogZGF0YVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG4gICAgdmFyIHJicmFjZSA9IC8oPzpcXHtbXFxzXFxTXSpcXH18XFxbW1xcc1xcU10qXFxdKSQvLFxuICAgICAgICBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvLFxuICAgICAgICBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2csXG4gICAgICAgIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1W1xcZGEtZkEtRl17NH0pL2csXG4gICAgICAgIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxyXFxuXSpcInx0cnVlfGZhbHNlfG51bGx8LT8oPzpcXGQrXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpL2dcbiAgICBhdmFsb24ucGFyc2VKU09OID0gd2luZG93LkpTT04gPyBKU09OLnBhcnNlIDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS50cmltKCk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsIFwiQFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCBcIl1cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgXCJcIikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiICsgZGF0YSkpKCkgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXZhbG9uLmVycm9yKFwiSW52YWxpZCBKU09OOiBcIiArIGRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGFcbiAgICB9XG4gICAgYXZhbG9uLmZpcmVEb20gPSBmdW5jdGlvbiAoZWxlbSwgdHlwZSwgb3B0cykge1xuICAgICAgICBpZiAoRE9DLmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFja0V2ZW50ID0gRE9DLmNyZWF0ZUV2ZW50KFwiRXZlbnRzXCIpO1xuICAgICAgICAgICAgaGFja0V2ZW50LmluaXRFdmVudCh0eXBlLCB0cnVlLCB0cnVlKVxuICAgICAgICAgICAgYXZhbG9uLm1peChoYWNrRXZlbnQsIG9wdHMpXG4gICAgICAgICAgICBlbGVtLmRpc3BhdGNoRXZlbnQoaGFja0V2ZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYWNrRXZlbnQgPSBET0MuY3JlYXRlRXZlbnRPYmplY3QoKVxuICAgICAgICAgICAgICAgIGF2YWxvbi5taXgoaGFja0V2ZW50LCBvcHRzKVxuICAgICAgICAgICAgICAgIGVsZW0uZmlyZUV2ZW50KFwib25cIiArIHR5cGUsIGhhY2tFdmVudClcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsvL0lFNi046Kem5Y+R5LqL5Lu25b+F6aG75L+d6K+B5ZyoRE9N5qCR5LitLOWQpuWImeaKpVwiU0NSSVBUMTYzODk6IOacquaMh+aYjueahOmUmeivr1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbi8v55Sf5oiQYXZhbG9uLmZuLnNjcm9sbExlZnQsIGF2YWxvbi5mbi5zY3JvbGxUb3Dmlrnms5VcbiAgICBhdmFsb24uZWFjaCh7XG4gICAgICAgIHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIixcbiAgICAgICAgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCJcbiAgICB9LCBmdW5jdGlvbiAobWV0aG9kLCBwcm9wKSB7XG4gICAgICAgIGF2YWxvbi5mblttZXRob2RdID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzWzBdIHx8IHt9LCB3aW4gPSBnZXRXaW5kb3cobm9kZSksXG4gICAgICAgICAgICAgICAgdG9wID0gbWV0aG9kID09PSBcInNjcm9sbFRvcFwiXG4gICAgICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luID8gKHByb3AgaW4gd2luKSA/IHdpbltwcm9wXSA6IHJvb3RbbWV0aG9kXSA6IG5vZGVbbWV0aG9kXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAod2luKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbi5zY3JvbGxUbyghdG9wID8gdmFsIDogYXZhbG9uKHdpbikuc2Nyb2xsTGVmdCgpLCB0b3AgPyB2YWwgOiBhdmFsb24od2luKS5zY3JvbGxUb3AoKSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlW21ldGhvZF0gPSB2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUud2luZG93ICYmIG5vZGUuZG9jdW1lbnQgPyBub2RlIDogbm9kZS5ub2RlVHlwZSA9PT0gOSA/IG5vZGUuZGVmYXVsdFZpZXcgfHwgbm9kZS5wYXJlbnRXaW5kb3cgOiBmYWxzZTtcbiAgICB9XG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09Y3Nz55u45YWzPT09PT09PT09PT09PT09PT09PT09PT1cbiAgICB2YXIgY3NzSG9va3MgPSBhdmFsb24uY3NzSG9va3MgPSB7fVxuICAgIHZhciBwcmVmaXhlcyA9IFtcIlwiLCBcIi13ZWJraXQtXCIsIFwiLW8tXCIsIFwiLW1vei1cIiwgXCItbXMtXCJdXG4gICAgdmFyIGNzc01hcCA9IHtcbiAgICAgICAgXCJmbG9hdFwiOiBXM0MgPyBcImNzc0Zsb2F0XCIgOiBcInN0eWxlRmxvYXRcIlxuICAgIH1cbiAgICBhdmFsb24uY3NzTnVtYmVyID0gb25lT2JqZWN0KFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQsY29sdW1uQ291bnQsb3JkZXIsZmxleCxmbGV4R3JvdyxmbGV4U2hyaW5rLGZpbGxPcGFjaXR5LGZvbnRXZWlnaHQsbGluZUhlaWdodCxvcGFjaXR5LG9ycGhhbnMsd2lkb3dzLHpJbmRleCx6b29tXCIpXG5cbiAgICBhdmFsb24uY3NzTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBob3N0LCBjYW1lbENhc2UpIHtcbiAgICAgICAgaWYgKGNzc01hcFtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIGNzc01hcFtuYW1lXVxuICAgICAgICB9XG4gICAgICAgIGhvc3QgPSBob3N0IHx8IHJvb3Quc3R5bGVcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBwcmVmaXhlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIGNhbWVsQ2FzZSA9IGNhbWVsaXplKHByZWZpeGVzW2ldICsgbmFtZSlcbiAgICAgICAgICAgIGlmIChjYW1lbENhc2UgaW4gaG9zdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3NzTWFwW25hbWVdID0gY2FtZWxDYXNlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGNzc0hvb2tzW1wiQDpzZXRcIl0gPSBmdW5jdGlvbiAobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHsgLy9ub2RlLnN0eWxlLndpZHRoID0gTmFOO25vZGUuc3R5bGUud2lkdGggPSBcInh4eHh4eHhcIjtub2RlLnN0eWxlLndpZHRoID0gdW5kZWZpbmUg5Zyo5pen5byPSUXkuIvkvJrmipvlvILluLhcbiAgICAgICAgICAgIG5vZGUuc3R5bGVbbmFtZV0gPSB2YWx1ZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgIGNzc0hvb2tzW1wiQDpnZXRcIl0gPSBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8ICFub2RlLnN0eWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0Q29tcHV0ZWRTdHlsZeimgeaxguS8oOWFpeS4gOS4quiKgueCuSBcIiArIG5vZGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmV0LCBzdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpXG4gICAgICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gbmFtZSA9PT0gXCJmaWx0ZXJcIiA/IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpIDogc3R5bGVzW25hbWVdXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBub2RlLnN0eWxlW25hbWVdIC8v5YW25LuW5rWP6KeI5Zmo6ZyA6KaB5oiR5Lus5omL5Yqo5Y+W5YaF6IGU5qC35byPXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICB9XG4gICAgICAgIGNzc0hvb2tzW1wib3BhY2l0eTpnZXRcIl0gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHJldCA9IGNzc0hvb2tzW1wiQDpnZXRcIl0obm9kZSwgXCJvcGFjaXR5XCIpXG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXRcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBybnVtbm9ucHggPSAvXi0/KD86XFxkKlxcLik/XFxkKyg/IXB4KVteXFxkXFxzXSskL2lcbiAgICAgICAgdmFyIHJwb3NpdGlvbiA9IC9eKHRvcHxyaWdodHxib3R0b218bGVmdCkkL1xuICAgICAgICB2YXIgcmFscGhhID0gL2FscGhhXFwoW14pXSpcXCkvaVxuICAgICAgICB2YXIgaWU4ID0gISF3aW5kb3cuWERvbWFpblJlcXVlc3RcbiAgICAgICAgdmFyIHNhbHBoYSA9IFwiRFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuQWxwaGFcIlxuICAgICAgICB2YXIgYm9yZGVyID0ge1xuICAgICAgICAgICAgdGhpbjogaWU4ID8gJzFweCcgOiAnMnB4JyxcbiAgICAgICAgICAgIG1lZGl1bTogaWU4ID8gJzNweCcgOiAnNHB4JyxcbiAgICAgICAgICAgIHRoaWNrOiBpZTggPyAnNXB4JyA6ICc2cHgnXG4gICAgICAgIH1cbiAgICAgICAgY3NzSG9va3NbXCJAOmdldFwiXSA9IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICAgICAgICAvL+WPluW+l+eyvuehruWAvO+8jOS4jei/h+Wug+acieWPr+iDveaYr+W4pmVtLHBjLG1tLHB0LCXnrYnljZXkvY1cbiAgICAgICAgICAgIHZhciBjdXJyZW50U3R5bGUgPSBub2RlLmN1cnJlbnRTdHlsZVxuICAgICAgICAgICAgdmFyIHJldCA9IGN1cnJlbnRTdHlsZVtuYW1lXVxuICAgICAgICAgICAgaWYgKChybnVtbm9ucHgudGVzdChyZXQpICYmICFycG9zaXRpb24udGVzdChyZXQpKSkge1xuICAgICAgICAgICAgICAgIC8v4pGg77yM5L+d5a2Y5Y6f5pyJ55qEc3R5bGUubGVmdCwgcnVudGltZVN0eWxlLmxlZnQsXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHN0eWxlLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJzTGVmdCA9IG5vZGUucnVudGltZVN0eWxlLmxlZnRcbiAgICAgICAgICAgICAgICAvL+KRoeeUseS6juKRouWkhOeahHN0eWxlLmxlZnQgPSB4eHjkvJrlvbHlk43liLBjdXJyZW50U3R5bGUubGVmdO+8jFxuICAgICAgICAgICAgICAgIC8v5Zug5q2k5oqK5a6DY3VycmVudFN0eWxlLmxlZnTmlL7liLBydW50aW1lU3R5bGUubGVmdO+8jFxuICAgICAgICAgICAgICAgIC8vcnVudGltZVN0eWxlLmxlZnTmi6XmnInmnIDpq5jkvJjlhYjnuqfvvIzkuI3kvJpzdHlsZS5sZWZ05b2x5ZONXG4gICAgICAgICAgICAgICAgbm9kZS5ydW50aW1lU3R5bGUubGVmdCA9IGN1cnJlbnRTdHlsZS5sZWZ0XG4gICAgICAgICAgICAgICAgLy/ikaLlsIbnsr7noa7lgLzotYvnu5nliLBzdHlsZS5sZWZ077yM54S25ZCO6YCa6L+HSUXnmoTlj6bkuIDkuKrnp4HmnInlsZ7mgKcgc3R5bGUucGl4ZWxMZWZ0XG4gICAgICAgICAgICAgICAgLy/lvpfliLDljZXkvY3kuLpweOeahOe7k+aenO+8m2ZvbnRTaXpl55qE5YiG5pSv6KeBaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNzYwXG4gICAgICAgICAgICAgICAgc3R5bGUubGVmdCA9IG5hbWUgPT09ICdmb250U2l6ZScgPyAnMWVtJyA6IChyZXQgfHwgMClcbiAgICAgICAgICAgICAgICByZXQgPSBzdHlsZS5waXhlbExlZnQgKyBcInB4XCJcbiAgICAgICAgICAgICAgICAvL+KRo+i/mOWOnyBzdHlsZS5sZWZ077yMcnVudGltZVN0eWxlLmxlZnRcbiAgICAgICAgICAgICAgICBzdHlsZS5sZWZ0ID0gbGVmdFxuICAgICAgICAgICAgICAgIG5vZGUucnVudGltZVN0eWxlLmxlZnQgPSByc0xlZnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXQgPT09IFwibWVkaXVtXCIpIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKFwiV2lkdGhcIiwgXCJTdHlsZVwiKVxuICAgICAgICAgICAgICAgIC8vYm9yZGVyIHdpZHRoIOm7mOiupOWAvOS4um1lZGl1be+8jOWNs+S9v+WFtuS4ujBcIlxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U3R5bGVbbmFtZV0gPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCA9IFwiMHB4XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0ID09PSBcIlwiID8gXCJhdXRvXCIgOiBib3JkZXJbcmV0XSB8fCByZXRcbiAgICAgICAgfVxuICAgICAgICBjc3NIb29rc1tcIm9wYWNpdHk6c2V0XCJdID0gZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlXG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IGlzRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA8PSAxID8gXCJhbHBoYShvcGFjaXR5PVwiICsgdmFsdWUgKiAxMDAgKyBcIilcIiA6IFwiXCJcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBzdHlsZS5maWx0ZXIgfHwgXCJcIjtcbiAgICAgICAgICAgIHN0eWxlLnpvb20gPSAxXG4gICAgICAgICAgICAvL+S4jeiDveS9v+eUqOS7peS4i+aWueW8j+iuvue9rumAj+aYjuW6plxuICAgICAgICAgICAgLy9ub2RlLmZpbHRlcnMuYWxwaGEub3BhY2l0eSA9IHZhbHVlICogMTAwXG4gICAgICAgICAgICBzdHlsZS5maWx0ZXIgPSAocmFscGhhLnRlc3QoZmlsdGVyKSA/XG4gICAgICAgICAgICAgICAgZmlsdGVyLnJlcGxhY2UocmFscGhhLCBvcGFjaXR5KSA6XG4gICAgICAgICAgICBmaWx0ZXIgKyBcIiBcIiArIG9wYWNpdHkpLnRyaW0oKVxuICAgICAgICAgICAgaWYgKCFzdHlsZS5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBzdHlsZS5yZW1vdmVBdHRyaWJ1dGUoXCJmaWx0ZXJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjc3NIb29rc1tcIm9wYWNpdHk6Z2V0XCJdID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIC8v6L+Z5piv5pyA5b+r55qE6I635Y+WSUXpgI/mmI7lgLznmoTmlrnlvI/vvIzkuI3pnIDopoHliqjnlKjmraPliJnkuobvvIFcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IG5vZGUuZmlsdGVycy5hbHBoYSB8fCBub2RlLmZpbHRlcnNbc2FscGhhXSxcbiAgICAgICAgICAgICAgICBvcCA9IGFscGhhICYmIGFscGhhLmVuYWJsZWQgPyBhbHBoYS5vcGFjaXR5IDogMTAwXG4gICAgICAgICAgICByZXR1cm4gKG9wIC8gMTAwKSArIFwiXCIgLy/noa7kv53ov5Tlm57nmoTmmK/lrZfnrKbkuLJcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFwidG9wLGxlZnRcIi5yZXBsYWNlKHJ3b3JkLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBjc3NIb29rc1tuYW1lICsgXCI6Z2V0XCJdID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBjb21wdXRlZCA9IGNzc0hvb2tzW1wiQDpnZXRcIl0obm9kZSwgbmFtZSlcbiAgICAgICAgICAgIHJldHVybiAvcHgkLy50ZXN0KGNvbXB1dGVkKSA/IGNvbXB1dGVkIDpcbiAgICAgICAgICAgIGF2YWxvbihub2RlKS5wb3NpdGlvbigpW25hbWVdICsgXCJweFwiXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgdmFyIGNzc1Nob3cgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsXG4gICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICAgIH1cblxuICAgIHZhciByZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS9cblxuICAgIGZ1bmN0aW9uIHNob3dIaWRkZW4obm9kZSwgYXJyYXkpIHtcbiAgICAgICAgLy9odHRwOi8vd3d3LmNuYmxvZ3MuY29tL3J1Ynlsb3V2cmUvYXJjaGl2ZS8yMDEyLzEwLzI3LzI3NDI1MjkuaHRtbFxuICAgICAgICBpZiAobm9kZS5vZmZzZXRXaWR0aCA8PSAwKSB7IC8vb3BlcmEub2Zmc2V0V2lkdGjlj6/og73lsI/kuo4wXG4gICAgICAgICAgICBpZiAocmRpc3BsYXlzd2FwLnRlc3QoY3NzSG9va3NbXCJAOmdldFwiXShub2RlLCBcImRpc3BsYXlcIikpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuYW1lIGluIGNzc1Nob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqW25hbWVdID0gbm9kZS5zdHlsZVtuYW1lXVxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlW25hbWVdID0gY3NzU2hvd1tuYW1lXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKG9iailcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGVcbiAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2hvd0hpZGRlbihwYXJlbnQsIGFycmF5KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFwiV2lkdGgsSGVpZ2h0XCIucmVwbGFjZShyd29yZCwgZnVuY3Rpb24gKG5hbWUpIHsgLy9maXggNDgxXG4gICAgICAgIHZhciBtZXRob2QgPSBuYW1lLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBjbGllbnRQcm9wID0gXCJjbGllbnRcIiArIG5hbWUsXG4gICAgICAgICAgICBzY3JvbGxQcm9wID0gXCJzY3JvbGxcIiArIG5hbWUsXG4gICAgICAgICAgICBvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIG5hbWVcbiAgICAgICAgY3NzSG9va3NbbWV0aG9kICsgXCI6Z2V0XCJdID0gZnVuY3Rpb24gKG5vZGUsIHdoaWNoLCBvdmVycmlkZSkge1xuICAgICAgICAgICAgdmFyIGJveFNpemluZyA9IC00XG4gICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgYm94U2l6aW5nID0gb3ZlcnJpZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWNoID0gbmFtZSA9PT0gXCJXaWR0aFwiID8gW1wiTGVmdFwiLCBcIlJpZ2h0XCJdIDogW1wiVG9wXCIsIFwiQm90dG9tXCJdXG4gICAgICAgICAgICB2YXIgcmV0ID0gbm9kZVtvZmZzZXRQcm9wXSAvLyBib3JkZXItYm94IDBcbiAgICAgICAgICAgIGlmIChib3hTaXppbmcgPT09IDIpIHsgLy8gbWFyZ2luLWJveCAyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldCArIGF2YWxvbi5jc3Mobm9kZSwgXCJtYXJnaW5cIiArIHdoaWNoWzBdLCB0cnVlKSArIGF2YWxvbi5jc3Mobm9kZSwgXCJtYXJnaW5cIiArIHdoaWNoWzFdLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJveFNpemluZyA8IDApIHsgLy8gcGFkZGluZy1ib3ggIC0yXG4gICAgICAgICAgICAgICAgcmV0ID0gcmV0IC0gYXZhbG9uLmNzcyhub2RlLCBcImJvcmRlclwiICsgd2hpY2hbMF0gKyBcIldpZHRoXCIsIHRydWUpIC0gYXZhbG9uLmNzcyhub2RlLCBcImJvcmRlclwiICsgd2hpY2hbMV0gKyBcIldpZHRoXCIsIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYm94U2l6aW5nID09PSAtNCkgeyAvLyBjb250ZW50LWJveCAtNFxuICAgICAgICAgICAgICAgIHJldCA9IHJldCAtIGF2YWxvbi5jc3Mobm9kZSwgXCJwYWRkaW5nXCIgKyB3aGljaFswXSwgdHJ1ZSkgLSBhdmFsb24uY3NzKG5vZGUsIFwicGFkZGluZ1wiICsgd2hpY2hbMV0sIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgIH1cbiAgICAgICAgY3NzSG9va3NbbWV0aG9kICsgXCImZ2V0XCJdID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBoaWRkZW4gPSBbXTtcbiAgICAgICAgICAgIHNob3dIaWRkZW4obm9kZSwgaGlkZGVuKTtcbiAgICAgICAgICAgIHZhciB2YWwgPSBjc3NIb29rc1ttZXRob2QgKyBcIjpnZXRcIl0obm9kZSlcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvYmo7IG9iaiA9IGhpZGRlbltpKytdOyApIHtcbiAgICAgICAgICAgICAgICBub2RlID0gb2JqLm5vZGVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBuIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtuXSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZVtuXSA9IG9ialtuXVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgICAgICBhdmFsb24uZm5bbWV0aG9kXSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyAvL+S8muW/veinhuWFtmRpc3BsYXlcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpc1swXVxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zZXRUaW1lb3V0KSB7IC8v5Y+W5b6X56qX5Y+j5bC65a+4LElFOeWQjuWPr+S7peeUqG5vZGUuaW5uZXJXaWR0aCAvaW5uZXJIZWlnaHTku6Pmm79cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVbXCJpbm5lclwiICsgbmFtZV0gfHwgbm9kZS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbY2xpZW50UHJvcF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZG9jdW1lbnQuYm9keVtjbGllbnRQcm9wXS8vSUU25LiL5YmN5Lik5Liq5YiG5Yir5Li6dW5kZWZpbmUsMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOSkgeyAvL+WPluW+l+mhtemdouWwuuWvuFxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gbm9kZS5kb2N1bWVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgLy9GRiBjaHJvbWUgICAgaHRtbC5zY3JvbGxIZWlnaHQ8IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vSUUg5qCH5YeG5qih5byPIDogaHRtbC5zY3JvbGxIZWlnaHQ+IGJvZHkuc2Nyb2xsSGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgIC8vSUUg5oCq5byC5qih5byPIDogaHRtbC5zY3JvbGxIZWlnaHQg5pyA5aSn562J5LqO5Y+v6KeG56qX5Y+j5aSa5LiA54K577yfXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChub2RlLmJvZHlbc2Nyb2xsUHJvcF0sIGRvY1tzY3JvbGxQcm9wXSwgbm9kZS5ib2R5W29mZnNldFByb3BdLCBkb2Nbb2Zmc2V0UHJvcF0sIGRvY1tjbGllbnRQcm9wXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNzc0hvb2tzW21ldGhvZCArIFwiJmdldFwiXShub2RlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jc3MobWV0aG9kLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdmFsb24uZm5bXCJpbm5lclwiICsgbmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3NzSG9va3NbbWV0aG9kICsgXCI6Z2V0XCJdKHRoaXNbMF0sIHZvaWQgMCwgLTIpXG4gICAgICAgIH1cbiAgICAgICAgYXZhbG9uLmZuW1wib3V0ZXJcIiArIG5hbWVdID0gZnVuY3Rpb24gKGluY2x1ZGVNYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjc3NIb29rc1ttZXRob2QgKyBcIjpnZXRcIl0odGhpc1swXSwgdm9pZCAwLCBpbmNsdWRlTWFyZ2luID09PSB0cnVlID8gMiA6IDApXG4gICAgICAgIH1cbiAgICB9KVxuICAgIGF2YWxvbi5mbi5vZmZzZXQgPSBmdW5jdGlvbiAoKSB7IC8v5Y+W5b6X6Led56a76aG16Z2i5bem5Y+z6KeS55qE5Z2Q5qCHXG4gICAgICAgIHZhciBub2RlID0gdGhpc1swXSxcbiAgICAgICAgICAgIGJveCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoIW5vZGUgfHwgIW5vZGUudGFnTmFtZSB8fCAhbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYm94XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIGJvZHkgPSBkb2MuYm9keSxcbiAgICAgICAgICAgIHJvb3QgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3dcbiAgICAgICAgaWYgKCFhdmFsb24uY29udGFpbnMocm9vdCwgbm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBib3hcbiAgICAgICAgfVxuICAgICAgICAvL2h0dHA6Ly9oa29tLmJsb2cxLmZjMi5jb20vP21vZGU9bSZubz03NTAgYm9keeeahOWBj+enu+mHj+aYr+S4jeWMheWQq21hcmdpbueahFxuICAgICAgICAvL+aIkeS7rOWPr+S7pemAmui/h2dldEJvdW5kaW5nQ2xpZW50UmVjdOadpeiOt+W+l+WFg+e0oOebuOWvueS6jmNsaWVudOeahHJlY3QuXG4gICAgICAgIC8vaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDMzLmFzcHhcbiAgICAgICAgaWYgKG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgICAgICAgICBib3ggPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSlcbiAgICAgICAgfVxuICAgICAgICAvL2Nocm9tZS9JRTY6IGJvZHkuc2Nyb2xsVG9wLCBmaXJlZm94L290aGVyOiByb290LnNjcm9sbFRvcFxuICAgICAgICB2YXIgY2xpZW50VG9wID0gcm9vdC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AsXG4gICAgICAgICAgICBjbGllbnRMZWZ0ID0gcm9vdC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCxcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IE1hdGgubWF4KHdpbi5wYWdlWU9mZnNldCB8fCAwLCByb290LnNjcm9sbFRvcCwgYm9keS5zY3JvbGxUb3ApLFxuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IE1hdGgubWF4KHdpbi5wYWdlWE9mZnNldCB8fCAwLCByb290LnNjcm9sbExlZnQsIGJvZHkuc2Nyb2xsTGVmdClcbiAgICAgICAgLy8g5oqK5rua5Yqo6Led56a75Yqg5YiwbGVmdCx0b3DkuK3ljrvjgIJcbiAgICAgICAgLy8gSUXkuIDkupvniYjmnKzkuK3kvJroh6rliqjkuLpIVE1M5YWD57Sg5Yqg5LiKMnB455qEYm9yZGVy77yM5oiR5Lus6ZyA6KaB5Y675o6J5a6DXG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMzU2NChWUy44NSkuYXNweFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9wOiBib3gudG9wICsgc2Nyb2xsVG9wIC0gY2xpZW50VG9wLFxuICAgICAgICAgICAgbGVmdDogYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdFxuICAgICAgICB9XG4gICAgfVxuXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT12YWznm7jlhbM9PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBmdW5jdGlvbiBnZXRWYWxUeXBlKGVsZW0pIHtcbiAgICAgICAgdmFyIHJldCA9IGVsZW0udGFnTmFtZS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIHJldHVybiByZXQgPT09IFwiaW5wdXRcIiAmJiAvY2hlY2tib3h8cmFkaW8vLnRlc3QoZWxlbS50eXBlKSA/IFwiY2hlY2tlZFwiIDogcmV0XG4gICAgfVxuICAgIHZhciByb3B0aW9uID0gL148b3B0aW9uKD86XFxzK1xcdysoPzpcXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHM+XSspKT8pKlxccyt2YWx1ZVtcXHM9XS9pXG4gICAgdmFyIHZhbEhvb2tzID0ge1xuICAgICAgICBcIm9wdGlvbjpnZXRcIjogSUVWZXJzaW9uID8gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIC8v5ZyoSUUxMeWPilczQ++8jOWmguaenOayoeacieaMh+WumnZhbHVl77yM6YKj5LmIbm9kZS52YWx1Zem7mOiupOS4um5vZGUudGV4dO+8iOWtmOWcqHRyaW3kvZzvvInvvIzkvYZJRTktMTDliJnmmK/lj5Zpbm5lckhUTUwo5rKhdHJpbeaTjeS9nClcbiAgICAgICAgICAgIC8vc3BlY2lmaWVk5bm25LiN5Y+v6Z2g77yM5Zug5q2k6YCa6L+H5YiG5p6Qb3V0ZXJIVE1M5Yik5a6a55So5oi35pyJ5rKh5pyJ5pi+56S65a6a5LmJdmFsdWVcbiAgICAgICAgICAgIHJldHVybiByb3B0aW9uLnRlc3Qobm9kZS5vdXRlckhUTUwpID8gbm9kZS52YWx1ZSA6IG5vZGUudGV4dC50cmltKClcbiAgICAgICAgfSA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS52YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBcInNlbGVjdDpnZXRcIjogZnVuY3Rpb24gKG5vZGUsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uLCBvcHRpb25zID0gbm9kZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGluZGV4ID0gbm9kZS5zZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgICAgIGdldHRlciA9IHZhbEhvb2tzW1wib3B0aW9uOmdldFwiXSxcbiAgICAgICAgICAgICAgICBvbmUgPSBub2RlLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiIHx8IGluZGV4IDwgMCxcbiAgICAgICAgICAgICAgICB2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG4gICAgICAgICAgICAgICAgbWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaSA9IGluZGV4IDwgMCA/IG1heCA6IG9uZSA/IGluZGV4IDogMFxuICAgICAgICAgICAgZm9yICg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbnNbaV1cbiAgICAgICAgICAgICAgICAvL+aXp+W8j0lF5ZyocmVzZXTlkI7kuI3kvJrmlLnlj5hzZWxlY3RlZO+8jOmcgOimgeaUueeUqGkgPT09IGluZGV45Yik5a6aXG4gICAgICAgICAgICAgICAgLy/miJHku6zov4fmu6TmiYDmnIlkaXNhYmxlZOeahG9wdGlvbuWFg+e0oO+8jOS9huWcqHNhZmFyaTXkuIvvvIzlpoLmnpzorr7nva5zZWxlY3TkuLpkaXNhYmxl77yM6YKj5LmI5YW25omA5pyJ5a2p5a2Q6YO9ZGlzYWJsZVxuICAgICAgICAgICAgICAgIC8v5Zug5q2k5b2T5LiA5Liq5YWD57Sg5Li6ZGlzYWJsZe+8jOmcgOimgeajgOa1i+WFtuaYr+WQpuaYvuW8j+iuvue9ruS6hmRpc2FibGXlj4rlhbbniLboioLngrnnmoRkaXNhYmxl5oOF5Ya1XG4gICAgICAgICAgICAgICAgaWYgKChvcHRpb24uc2VsZWN0ZWQgfHwgaSA9PT0gaW5kZXgpICYmICFvcHRpb24uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXR0ZXIob3B0aW9uKVxuICAgICAgICAgICAgICAgICAgICBpZiAob25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL+aUtumbhuaJgOaciXNlbGVjdGVk5YC857uE5oiQ5pWw57uE6L+U5ZueXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgfSxcbiAgICAgICAgXCJzZWxlY3Q6c2V0XCI6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZXMsIG9wdGlvblNldCkge1xuICAgICAgICAgICAgdmFsdWVzID0gW10uY29uY2F0KHZhbHVlcykgLy/lvLrliLbovazmjaLkuLrmlbDnu4RcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSB2YWxIb29rc1tcIm9wdGlvbjpnZXRcIl1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlbDsgZWwgPSBub2RlLm9wdGlvbnNbaSsrXTsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKChlbC5zZWxlY3RlZCA9IHZhbHVlcy5pbmRleE9mKGdldHRlcihlbCkpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvblNldCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvblNldCkge1xuICAgICAgICAgICAgICAgIG5vZGUuc2VsZWN0ZWRJbmRleCA9IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIOe8luivkeezu+e7nyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIG1ldGEgPSB7XG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJzogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgIH1cbiAgICB2YXIgcXVvdGUgPSB3aW5kb3cuSlNPTiAmJiBKU09OLnN0cmluZ2lmeSB8fCBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCInICsgc3RyLnJlcGxhY2UoL1tcXFxcXFxcIlxceDAwLVxceDFmXS9nLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgICAgICAgICB9KSArICdcIidcbiAgICAgICAgfVxuXG4gICAgdmFyIGtleXdvcmRzID0gW1xuICAgICAgICBcImJyZWFrLGNhc2UsY2F0Y2gsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCxkZWxldGUsZG8sZWxzZSxmYWxzZVwiLFxuICAgICAgICBcImZpbmFsbHksZm9yLGZ1bmN0aW9uLGlmLGluLGluc3RhbmNlb2YsbmV3LG51bGwscmV0dXJuLHN3aXRjaCx0aGlzXCIsXG4gICAgICAgIFwidGhyb3csdHJ1ZSx0cnksdHlwZW9mLHZhcix2b2lkLHdoaWxlLHdpdGhcIiwgLyog5YWz6ZSu5a2XKi9cbiAgICAgICAgXCJhYnN0cmFjdCxib29sZWFuLGJ5dGUsY2hhcixjbGFzcyxjb25zdCxkb3VibGUsZW51bSxleHBvcnQsZXh0ZW5kc1wiLFxuICAgICAgICBcImZpbmFsLGZsb2F0LGdvdG8saW1wbGVtZW50cyxpbXBvcnQsaW50LGludGVyZmFjZSxsb25nLG5hdGl2ZVwiLFxuICAgICAgICBcInBhY2thZ2UscHJpdmF0ZSxwcm90ZWN0ZWQscHVibGljLHNob3J0LHN0YXRpYyxzdXBlcixzeW5jaHJvbml6ZWRcIixcbiAgICAgICAgXCJ0aHJvd3MsdHJhbnNpZW50LHZvbGF0aWxlXCIsIC8q5L+d55WZ5a2XKi9cbiAgICAgICAgXCJhcmd1bWVudHMsbGV0LHlpZWxkLHVuZGVmaW5lZFwiIC8qIEVDTUEgNSAtIHVzZSBzdHJpY3QqL10uam9pbihcIixcIilcbiAgICB2YXIgcnJleHBzdHIgPSAvXFwvXFwqW1xcd1xcV10qP1xcKlxcL3xcXC9cXC9bXlxcbl0qXFxufFxcL1xcL1teXFxuXSokfFwiKD86W15cIlxcXFxdfFxcXFxbXFx3XFxXXSkqXCJ8Jyg/OlteJ1xcXFxdfFxcXFxbXFx3XFxXXSkqJ3xbXFxzXFx0XFxuXSpcXC5bXFxzXFx0XFxuXSpbJFxcd1xcLl0rL2dcbiAgICB2YXIgcnNwbGl0ID0gL1teXFx3JF0rL2dcbiAgICB2YXIgcmtleXdvcmRzID0gbmV3IFJlZ0V4cChbXCJcXFxcYlwiICsga2V5d29yZHMucmVwbGFjZSgvLC9nLCAnXFxcXGJ8XFxcXGInKSArIFwiXFxcXGJcIl0uam9pbignfCcpLCAnZycpXG4gICAgdmFyIHJudW1iZXIgPSAvXFxiXFxkW14sXSovZ1xuICAgIHZhciByY29tbWEgPSAvXiwrfCwrJC9nXG4gICAgdmFyIHZhcmlhYmxlUG9vbCA9IG5ldyBDYWNoZSg1MTIpXG4gICAgdmFyIGdldFZhcmlhYmxlcyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICAgIHZhciBrZXkgPSBcIixcIiArIGNvZGUudHJpbSgpXG4gICAgICAgIHZhciByZXQgPSB2YXJpYWJsZVBvb2wuZ2V0KGtleSlcbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IGNvZGVcbiAgICAgICAgICAgIC5yZXBsYWNlKHJyZXhwc3RyLCBcIlwiKVxuICAgICAgICAgICAgLnJlcGxhY2UocnNwbGl0LCBcIixcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKHJrZXl3b3JkcywgXCJcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKHJudW1iZXIsIFwiXCIpXG4gICAgICAgICAgICAucmVwbGFjZShyY29tbWEsIFwiXCIpXG4gICAgICAgICAgICAuc3BsaXQoL14kfCwrLylcbiAgICAgICAgcmV0dXJuIHZhcmlhYmxlUG9vbC5wdXQoa2V5LCB1bmlxU2V0KG1hdGNoKSlcbiAgICB9XG4gICAgLyrmt7vliqDotYvlgLzor63lj6UqL1xuXG4gICAgZnVuY3Rpb24gYWRkQXNzaWduKHZhcnMsIHNjb3BlLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciByZXQgPSBbXSxcbiAgICAgICAgICAgIHByZWZpeCA9IFwiID0gXCIgKyBuYW1lICsgXCIuXCJcbiAgICAgICAgZm9yICh2YXIgaSA9IHZhcnMubGVuZ3RoLCBwcm9wOyBwcm9wID0gdmFyc1stLWldOyApIHtcbiAgICAgICAgICAgIGlmIChzY29wZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKHByb3AgKyBwcmVmaXggKyBwcm9wKVxuICAgICAgICAgICAgICAgIGRhdGEudmFycy5wdXNoKHByb3ApXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gXCJkdXBsZXhcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXJzLmdldCA9IG5hbWUgKyBcIi5cIiArIHByb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFycy5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5pcVNldChhcnJheSkge1xuICAgICAgICB2YXIgcmV0ID0gW10sXG4gICAgICAgICAgICB1bmlxdWUgPSB7fVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBhcnJheVtpXVxuICAgICAgICAgICAgdmFyIGlkID0gZWwgJiYgdHlwZW9mIGVsLiRpZCA9PT0gXCJzdHJpbmdcIiA/IGVsLiRpZCA6IGVsXG4gICAgICAgICAgICBpZiAoIXVuaXF1ZVtpZF0pIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVbaWRdID0gcmV0LnB1c2goZWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgIH1cbi8v57yT5a2Y5rGC5YC85Ye95pWw77yM5Lul5L6/5aSa5qyh5Yip55SoXG4gICAgdmFyIGV2YWx1YXRvclBvb2wgPSBuZXcgQ2FjaGUoMTI4KVxuLy/lj5blvpfmsYLlgLzlh73mlbDlj4rlhbbkvKDlj4JcbiAgICB2YXIgcmR1cGxleCA9IC9cXHdcXFsuKlxcXXxcXHdcXC5cXHcvXG4gICAgdmFyIHJwcm94eSA9IC8oXFwkcHJveHlcXCRbYS16XSspXFxkKyQvXG4gICAgdmFyIHJ0aGltUmlnaHRQYXJlbnRoZXNlcyA9IC9cXClcXHMqJC9cbiAgICB2YXIgcnRoaW1PdGhlclBhcmVudGhlc2VzID0gL1xcKVxccypcXHwvZ1xuICAgIHZhciBycXVvdGVGaWx0ZXJOYW1lID0gL1xcfFxccyooWyRcXHddKykvZ1xuICAgIHZhciBycGF0Y2hCcmFja2V0ID0gL1wiXFxzKlxcW1wiL2dcbiAgICB2YXIgcnRoaW1MZWZ0UGFyZW50aGVzZXMgPSAvXCJcXHMqXFwoL2dcbiAgICBmdW5jdGlvbiBwYXJzZUZpbHRlcih2YWwsIGZpbHRlcnMpIHtcbiAgICAgICAgZmlsdGVycyA9IGZpbHRlcnNcbiAgICAgICAgICAgIC5yZXBsYWNlKHJ0aGltUmlnaHRQYXJlbnRoZXNlcywgXCJcIikvL+WkhOeQhuacgOWQjueahOWwj+aLrOWPt1xuICAgICAgICAgICAgLnJlcGxhY2UocnRoaW1PdGhlclBhcmVudGhlc2VzLCBmdW5jdGlvbiAoKSB7Ly/lpITnkIblhbbku5blsI/mi6zlj7dcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJdLHxcIlxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKHJxdW90ZUZpbHRlck5hbWUsIGZ1bmN0aW9uIChhLCBiKSB7IC8v5aSE55CGfOWPiuWug+WQjumdoueahOi/h+a7pOWZqOeahOWQjeWtl1xuICAgICAgICAgICAgICAgIHJldHVybiBcIltcIiArIHF1b3RlKGIpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UocnBhdGNoQnJhY2tldCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXCJdLFtcIidcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZShydGhpbUxlZnRQYXJlbnRoZXNlcywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnXCIsJ1xuICAgICAgICAgICAgfSkgKyBcIl1cIlxuICAgICAgICByZXR1cm4gIFwicmV0dXJuIHRoaXMuZmlsdGVycy4kZmlsdGVyKFwiICsgdmFsICsgXCIsIFwiICsgZmlsdGVycyArIFwiKVwiXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHByKGNvZGUsIHNjb3BlcywgZGF0YSkge1xuICAgICAgICB2YXIgZGF0YVR5cGUgPSBkYXRhLnR5cGVcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBkYXRhLmZpbHRlcnMgfHwgXCJcIlxuICAgICAgICB2YXIgZXhwcklkID0gc2NvcGVzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKGVsLiRpZCkucmVwbGFjZShycHJveHksIFwiJDFcIilcbiAgICAgICAgICAgIH0pICsgY29kZSArIGRhdGFUeXBlICsgZmlsdGVyc1xuICAgICAgICB2YXIgdmFycyA9IGdldFZhcmlhYmxlcyhjb2RlKS5jb25jYXQoKSxcbiAgICAgICAgICAgIGFzc2lnbnMgPSBbXSxcbiAgICAgICAgICAgIG5hbWVzID0gW10sXG4gICAgICAgICAgICBhcmdzID0gW10sXG4gICAgICAgICAgICBwcmVmaXggPSBcIlwiXG4gICAgICAgIC8vYXJncyDmmK/kuIDkuKrlr7nosaHmlbDnu4TvvIwgbmFtZXMg5piv5bCG6KaB55Sf5oiQ55qE5rGC5YC85Ye95pWw55qE5Y+C5pWwXG4gICAgICAgIHNjb3BlcyA9IHVuaXFTZXQoc2NvcGVzKVxuICAgICAgICBkYXRhLnZhcnMgPSBbXVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgc24gPSBzY29wZXMubGVuZ3RoOyBpIDwgc247IGkrKykge1xuICAgICAgICAgICAgaWYgKHZhcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBcInZtXCIgKyBleHBvc2UgKyBcIl9cIiArIGlcbiAgICAgICAgICAgICAgICBuYW1lcy5wdXNoKG5hbWUpXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKHNjb3Blc1tpXSlcbiAgICAgICAgICAgICAgICBhc3NpZ25zLnB1c2guYXBwbHkoYXNzaWducywgYWRkQXNzaWduKHZhcnMsIHNjb3Blc1tpXSwgbmFtZSwgZGF0YSkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhc3NpZ25zLmxlbmd0aCAmJiBkYXRhVHlwZSA9PT0gXCJkdXBsZXhcIikge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFUeXBlICE9PSBcImR1cGxleFwiICYmIChjb2RlLmluZGV4T2YoXCJ8fFwiKSA+IC0xIHx8IGNvZGUuaW5kZXhPZihcIiYmXCIpID4gLTEpKSB7XG4gICAgICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9SdWJ5TG91dnJlL2F2YWxvbi9pc3N1ZXMvNTgzXG4gICAgICAgICAgICBkYXRhLnZhcnMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiXFxcXGJcIiArIHYgKyBcIig/OlxcXFwuXFxcXHcrfFxcXFxbXFxcXHcrXFxcXF0pK1wiLCBcImlnXCIpXG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZWcsIGZ1bmN0aW9uIChfLCBjYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBfLmNoYXJBdCh2Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgLy92YXIgciA9IElFVmVyc2lvbiA/IGNvZGUuc2xpY2UoYXJndW1lbnRzWzFdICsgXy5sZW5ndGgpIDogUmVnRXhwLnJpZ2h0Q29udGV4dFxuICAgICAgICAgICAgICAgICAgICAvL2h0dHBzOi8vZ2l0aHViLmNvbS9SdWJ5TG91dnJlL2F2YWxvbi9pc3N1ZXMvOTY2XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gY29kZS5zbGljZShjYXAgKyBfLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IC9eXFxzKlxcKC8udGVzdChyKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gXCIuXCIgfHwgYyA9PT0gXCJbXCIgfHwgbWV0aG9kKSB7Ly/mr5TlpoJ25Li6YWEs5oiR5Lus5Y+q5Yy56YWNYWEuYmIsYWFbY2NdLOS4jeWMuemFjWFhYS54eHhcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gXCJ2YXJcIiArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9eMFxcLi8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7Ly9hcnJheS5zaXplKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBfLnNwbGl0KFwiLlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJheS5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gYXJyYXkucG9wKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzaWducy5wdXNoKG5hbWUgKyBcIiA9IFwiICsgYXJyYXkuam9pbihcIi5cIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lICsgXCIuXCIgKyBsYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhc3NpZ25zLnB1c2gobmFtZSArIFwiID0gXCIgKyBfKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLWFyZ3MtLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGRhdGEuYXJncyA9IGFyZ3NcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS1jYWNoZS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgZGVsZXRlIGRhdGEudmFyc1xuICAgICAgICB2YXIgZm4gPSBldmFsdWF0b3JQb29sLmdldChleHBySWQpIC8v55u05o6l5LuO57yT5a2Y77yM5YWN5b6X6YeN5aSN55Sf5oiQXG4gICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgZGF0YS5ldmFsdWF0b3IgPSBmblxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gYXNzaWducy5qb2luKFwiLCBcIilcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgcHJlZml4ID0gXCJ2YXIgXCIgKyBwcmVmaXhcbiAgICAgICAgfVxuICAgICAgICBpZiAoL1xcUy8udGVzdChmaWx0ZXJzKSkgeyAvL+aWh+acrOe7keWumu+8jOWPjOW3pee7keWumuaJjeaciei/h+a7pOWZqFxuICAgICAgICAgICAgaWYgKCEvdGV4dHxodG1sLy50ZXN0KGRhdGEudHlwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm1zLVwiICsgZGF0YS50eXBlICsgXCLkuI3mlK/mjIHov4fmu6TlmahcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvZGUgPSBcIlxcbnZhciByZXRcIiArIGV4cG9zZSArIFwiID0gXCIgKyBjb2RlICsgXCI7XFxyXFxuXCJcbiAgICAgICAgICAgIGNvZGUgKz0gcGFyc2VGaWx0ZXIoXCJyZXRcIiArIGV4cG9zZSwgZmlsdGVycylcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm4gPSBGdW5jdGlvbi5hcHBseShub29wLCBuYW1lcy5jb25jYXQoXCIndXNlIHN0cmljdCc7XFxuXCIgKyBwcmVmaXggKyBjb2RlKSlcbiAgICAgICAgICAgICAgICBkYXRhLmV2YWx1YXRvciA9IGV2YWx1YXRvclBvb2wucHV0KGV4cHJJZCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShhdmFsb24sIGFyZ3VtZW50cykvL+ehruS/neWPr+S7peWcqOe8luivkeS7o+eggeS4reS9v+eUqHRoaXPojrflj5ZhdmFsb27lr7nosaFcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZyhcImRlYnVnOiBwYXJzZSBlcnJvcixcIiArIGUubWVzc2FnZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcnMgPSBhc3NpZ25zID0gbmFtZXMgPSBudWxsIC8v6YeK5pS+5YaF5a2YXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZSA9PT0gXCJkdXBsZXhcIikgeyAvL+WPjOW3pee7keWumlxuICAgICAgICAgICAgdmFyIF9ib2R5ID0gXCIndXNlIHN0cmljdCc7XFxucmV0dXJuIGZ1bmN0aW9uKHZ2dil7XFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgIHByZWZpeCArXG4gICAgICAgICAgICAgICAgXCI7XFxuXFx0aWYoIWFyZ3VtZW50cy5sZW5ndGgpe1xcblxcdFxcdHJldHVybiBcIiArXG4gICAgICAgICAgICAgICAgY29kZSArXG4gICAgICAgICAgICAgICAgXCJcXG5cXHR9XFxuXFx0XCIgKyAoIXJkdXBsZXgudGVzdChjb2RlKSA/IHZhcnMuZ2V0IDogY29kZSkgK1xuICAgICAgICAgICAgICAgIFwiPSB2dnY7XFxufSBcIlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmbiA9IEZ1bmN0aW9uLmFwcGx5KG5vb3AsIG5hbWVzLmNvbmNhdChfYm9keSkpXG4gICAgICAgICAgICAgICAgZGF0YS5ldmFsdWF0b3IgPSBldmFsdWF0b3JQb29sLnB1dChleHBySWQsIGZuKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZyhcImRlYnVnOiBwYXJzZSBlcnJvcixcIiArIGUubWVzc2FnZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhcnMgPSBhc3NpZ25zID0gbmFtZXMgPSBudWxsIC8v6YeK5pS+5YaF5a2YXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBlbHNlIGlmIChkYXRhVHlwZSA9PT0gXCJvblwiKSB7IC8v5LqL5Lu257uR5a6aXG4gICAgICAgICAgICBpZiAoY29kZS5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb2RlICs9IFwiLmNhbGwodGhpcywgJGV2ZW50KVwiXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UoXCIoXCIsIFwiLmNhbGwodGhpcyxcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5hbWVzLnB1c2goXCIkZXZlbnRcIilcbiAgICAgICAgICAgIGNvZGUgPSBcIlxcbnJldHVybiBcIiArIGNvZGUgKyBcIjtcIiAvL0lF5YWo5a62IEZ1bmN0aW9uKFwicmV0dXJuIFwiKeWHuumUme+8jOmcgOimgUZ1bmN0aW9uKFwicmV0dXJuIDtcIilcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSBjb2RlLmxhc3RJbmRleE9mKFwiXFxucmV0dXJuXCIpXG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gY29kZS5zbGljZSgwLCBsYXN0SW5kZXgpXG4gICAgICAgICAgICB2YXIgZm9vdGVyID0gY29kZS5zbGljZShsYXN0SW5kZXgpXG4gICAgICAgICAgICBjb2RlID0gaGVhZGVyICsgXCJcXG5cIiArIGZvb3RlclxuICAgICAgICB9IGVsc2UgeyAvL+WFtuS7lue7keWumlxuICAgICAgICAgICAgY29kZSA9IFwiXFxucmV0dXJuIFwiICsgY29kZSArIFwiO1wiIC8vSUXlhajlrrYgRnVuY3Rpb24oXCJyZXR1cm4gXCIp5Ye66ZSZ77yM6ZyA6KaBRnVuY3Rpb24oXCJyZXR1cm4gO1wiKVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmbiA9IEZ1bmN0aW9uLmFwcGx5KG5vb3AsIG5hbWVzLmNvbmNhdChcIid1c2Ugc3RyaWN0JztcXG5cIiArIHByZWZpeCArIGNvZGUpKVxuICAgICAgICAgICAgZGF0YS5ldmFsdWF0b3IgPSBldmFsdWF0b3JQb29sLnB1dChleHBySWQsIGZuKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2coXCJkZWJ1ZzogcGFyc2UgZXJyb3IsXCIgKyBlLm1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgICAgdmFycyA9IGFzc2lnbnMgPSBuYW1lcyA9IG51bGwgLy/ph4rmlL7lhoXlrZhcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RyaW5naWZ5RXhwcihjb2RlKSB7XG4gICAgICAgIHZhciBoYXNFeHByID0gcmV4cHIudGVzdChjb2RlKSAvL+avlOWmgm1zLWNsYXNzPVwid2lkdGh7e3d9fVwi55qE5oOF5Ya1XG4gICAgICAgIGlmIChoYXNFeHByKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBzY2FuRXhwcihjb2RlKVxuICAgICAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVswXS52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWwuZXhwciA/IFwiKFwiICsgZWwudmFsdWUgKyBcIilcIiA6IHF1b3RlKGVsLnZhbHVlKVxuICAgICAgICAgICAgfSkuam9pbihcIiArIFwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVcbiAgICAgICAgfVxuICAgIH1cbi8vcGFyc2VFeHBy55qE5pm66IO95byV55So5Luj55CGXG5cbiAgICBmdW5jdGlvbiBwYXJzZUV4cHJQcm94eShjb2RlLCBzY29wZXMsIGRhdGEsIG5vUmVnaXN0ZXIpIHtcbiAgICAgICAgY29kZSA9IGNvZGUgfHwgXCJcIiAvL2NvZGUg5Y+v6IO95pyq5a6a5LmJXG4gICAgICAgIHBhcnNlRXhwcihjb2RlLCBzY29wZXMsIGRhdGEpXG4gICAgICAgIGlmIChkYXRhLmV2YWx1YXRvciAmJiAhbm9SZWdpc3Rlcikge1xuICAgICAgICAgICAgZGF0YS5oYW5kbGVyID0gYmluZGluZ0V4ZWN1dG9yc1tkYXRhLmhhbmRsZXJOYW1lIHx8IGRhdGEudHlwZV1cbiAgICAgICAgICAgIC8v5pa55L6/6LCD6K+VXG4gICAgICAgICAgICAvL+i/memHjOmdnuW4uOmHjeimgSzmiJHku6zpgJrov4fliKTlrprop4blm77liLfmlrDlh73mlbDnmoRlbGVtZW505piv5ZCm5ZyoRE9N5qCR5Yaz5a6aXG4gICAgICAgICAgICAvL+WwhuWug+enu+WHuuiuoumYheiAheWIl+ihqFxuICAgICAgICAgICAgYXZhbG9uLmluamVjdEJpbmRpbmcoZGF0YSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBhdmFsb24ucGFyc2VFeHByUHJveHkgPSBwYXJzZUV4cHJQcm94eVxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIOaJq+aPj+ezu+e7nyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgIGF2YWxvbi5zY2FuID0gZnVuY3Rpb24oZWxlbSwgdm1vZGVsKSB7XG4gICAgICAgIGVsZW0gPSBlbGVtIHx8IHJvb3RcbiAgICAgICAgdmFyIHZtb2RlbHMgPSB2bW9kZWwgPyBbXS5jb25jYXQodm1vZGVsKSA6IFtdXG4gICAgICAgIHNjYW5UYWcoZWxlbSwgdm1vZGVscylcbiAgICB9XG5cbi8vaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjdm9pZC1lbGVtZW50c1xuICAgIHZhciBzdG9wU2NhbiA9IG9uZU9iamVjdChcImFyZWEsYmFzZSxiYXNlZm9udCxicixjb2wsY29tbWFuZCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnIsbm9zY3JpcHQsc2NyaXB0LHN0eWxlLHRleHRhcmVhXCIudG9VcHBlckNhc2UoKSlcblxuICAgIGZ1bmN0aW9uIGNoZWNrU2NhbihlbGVtLCBjYWxsYmFjaywgaW5uZXJIVE1MKSB7XG4gICAgICAgIHZhciBpZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY3VyckhUTUwgPSBlbGVtLmlubmVySFRNTFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGlkKVxuICAgICAgICAgICAgaWYgKGN1cnJIVE1MID09PSBpbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoZWNrU2NhbihlbGVtLCBjYWxsYmFjaywgY3VyckhUTUwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVTaWduYWxUb3dlcihlbGVtLCB2bW9kZWwpIHtcbiAgICAgICAgdmFyIGlkID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJhdmFsb25jdHJsXCIpIHx8IHZtb2RlbC4kaWRcbiAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoXCJhdmFsb25jdHJsXCIsIGlkKVxuICAgICAgICB2bW9kZWwuJGV2ZW50cy5leHByID0gZWxlbS50YWdOYW1lICsgJ1thdmFsb25jdHJsPVwiJyArIGlkICsgJ1wiXSdcbiAgICB9XG5cbiAgICB2YXIgZ2V0QmluZGluZ0NhbGxiYWNrID0gZnVuY3Rpb24oZWxlbSwgbmFtZSwgdm1vZGVscykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBlbGVtLmdldEF0dHJpYnV0ZShuYW1lKVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB2bTsgdm0gPSB2bW9kZWxzW2krK107ICkge1xuICAgICAgICAgICAgICAgIGlmICh2bS5oYXNPd25Qcm9wZXJ0eShjYWxsYmFjaykgJiYgdHlwZW9mIHZtW2NhbGxiYWNrXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2bVtjYWxsYmFja11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGVjdXRlQmluZGluZ3MoYmluZGluZ3MsIHZtb2RlbHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGRhdGE7IGRhdGEgPSBiaW5kaW5nc1tpKytdOyApIHtcbiAgICAgICAgICAgIGRhdGEudm1vZGVscyA9IHZtb2RlbHNcbiAgICAgICAgICAgIGJpbmRpbmdIYW5kbGVyc1tkYXRhLnR5cGVdKGRhdGEsIHZtb2RlbHMpXG4gICAgICAgICAgICBpZiAoZGF0YS5ldmFsdWF0b3IgJiYgZGF0YS5lbGVtZW50ICYmIGRhdGEuZWxlbWVudC5ub2RlVHlwZSA9PT0gMSkgeyAvL+enu+mZpOaVsOaNrue7keWumu+8jOmYsuatouiiq+S6jOasoeino+aekFxuICAgICAgICAgICAgICAgIC8vY2hyb21l5L2/55SocmVtb3ZlQXR0cmlidXRlTm9kZeenu+mZpOS4jeWtmOWcqOeahOeJueaAp+iKgueCueaXtuS8muaKpemUmSBodHRwczovL2dpdGh1Yi5jb20vUnVieUxvdXZyZS9hdmFsb24vaXNzdWVzLzk5XG4gICAgICAgICAgICAgICAgZGF0YS5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShkYXRhLm5hbWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZ3MubGVuZ3RoID0gMFxuICAgIH1cblxuLy9odHRwczovL2dpdGh1Yi5jb20vUnVieUxvdXZyZS9hdmFsb24vaXNzdWVzLzYzNlxuICAgIHZhciBtZXJnZVRleHROb2RlcyA9IElFVmVyc2lvbiAmJiB3aW5kb3cuTXV0YXRpb25PYnNlcnZlciA/IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgIHZhciBub2RlID0gZWxlbS5maXJzdENoaWxkLCB0ZXh0XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgYWFhID0gbm9kZS5uZXh0U2libGluZ1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Lm5vZGVWYWx1ZSArPSBub2RlLm5vZGVWYWx1ZVxuICAgICAgICAgICAgICAgICAgICBlbGVtLnJlbW92ZUNoaWxkKG5vZGUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IG5vZGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gYWFhXG4gICAgICAgIH1cbiAgICB9IDogMFxuICAgIHZhciByb25lVGltZSA9IC9eXFxzKjo6L1xuICAgIHZhciBybXNBdHRyID0gL21zLShcXHcrKS0/KC4qKS9cbiAgICB2YXIgcHJpb3JpdHlNYXAgPSB7XG4gICAgICAgIFwiaWZcIjogMTAsXG4gICAgICAgIFwicmVwZWF0XCI6IDkwLFxuICAgICAgICBcImRhdGFcIjogMTAwLFxuICAgICAgICBcIndpZGdldFwiOiAxMTAsXG4gICAgICAgIFwiZWFjaFwiOiAxNDAwLFxuICAgICAgICBcIndpdGhcIjogMTUwMCxcbiAgICAgICAgXCJkdXBsZXhcIjogMjAwMCxcbiAgICAgICAgXCJvblwiOiAzMDAwXG4gICAgfVxuXG4gICAgdmFyIGV2ZW50cyA9IG9uZU9iamVjdChcImFuaW1hdGlvbmVuZCxibHVyLGNoYW5nZSxpbnB1dCxjbGljayxkYmxjbGljayxmb2N1cyxrZXlkb3duLGtleXByZXNzLGtleXVwLG1vdXNlZG93bixtb3VzZWVudGVyLG1vdXNlbGVhdmUsbW91c2Vtb3ZlLG1vdXNlb3V0LG1vdXNlb3Zlcixtb3VzZXVwLHNjYW4sc2Nyb2xsLHN1Ym1pdFwiKVxuICAgIHZhciBvYnNvbGV0ZUF0dHJzID0gb25lT2JqZWN0KFwidmFsdWUsdGl0bGUsYWx0LGNoZWNrZWQsc2VsZWN0ZWQsZGlzYWJsZWQscmVhZG9ubHksZW5hYmxlZFwiKVxuICAgIGZ1bmN0aW9uIGJpbmRpbmdTb3J0ZXIoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuQXR0cihlbGVtLCB2bW9kZWxzLCBtYXRjaCkge1xuICAgICAgICB2YXIgc2Nhbk5vZGUgPSB0cnVlXG4gICAgICAgIGlmICh2bW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzID8gZ2V0QXR0cmlidXRlcyhlbGVtKSA6IGVsZW0uYXR0cmlidXRlc1xuICAgICAgICAgICAgdmFyIGJpbmRpbmdzID0gW11cbiAgICAgICAgICAgIHZhciBmaXhBdHRycyA9IFtdXG4gICAgICAgICAgICB2YXIgbXNEYXRhID0ge31cbiAgICAgICAgICAgIHZhciB1bmlxID0ge31cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBhdHRyOyBhdHRyID0gYXR0cmlidXRlc1tpKytdOyApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5zcGVjaWZpZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID0gYXR0ci5uYW1lLm1hdGNoKHJtc0F0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL+WmguaenOaYr+S7peaMh+WumuWJjee8gOWRveWQjeeahFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gbWF0Y2hbMl0gfHwgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBhdHRyLm5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bmlxW25hbWVdKSB7Ly9JRTjkuIttcy1yZXBlYXQsbXMtd2l0aCBCVUdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5pcVtuYW1lXSA9IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbSA9IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9ic29sZXRlQXR0cnNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJlbmFibGVkXCIpIHsvL+WQg+aOiW1zLWVuYWJsZWTnu5Hlrpos55SobXMtZGlzYWJsZWTku6Pmm79cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwid2FybmluZyFtcy1lbmFibGVk5oiWbXMtYXR0ci1lbmFibGVk5bey57uP6KKr5bqf5byDXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImRpc2FibGVkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBcIiEoXCIgKyB2YWx1ZSArIFwiKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtID0gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImF0dHJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcIm1zLVwiICsgdHlwZSArIFwiLVwiICsgcGFyYW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXhBdHRycy5wdXNoKFthdHRyLm5hbWUsIG5hbWUsIHZhbHVlXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1zRGF0YVtuYW1lXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJpbmRpbmdIYW5kbGVyc1t0eXBlXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWUucmVwbGFjZShyb25lVGltZSwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb25lVGltZSA9IHZhbHVlICE9PSBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbTogcGFyYW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lVGltZTogb25lVGltZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXVpZDogbmFtZSArIFwiLVwiICsgZ2V0VWlkKGVsZW0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Nocm9tZeS4jmZpcmVmb3jkuItOdW1iZXIocGFyYW0p5b6X5Yiw55qE5YC85LiN5LiA5qC3ICM4NTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IChwcmlvcml0eU1hcFt0eXBlXSB8fCB0eXBlLmNoYXJDb2RlQXQoMCkgKiAxMCkgKyAoTnVtYmVyKHBhcmFtLnJlcGxhY2UoL1xcRC9nLCBcIlwiKSkgfHwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiaHRtbFwiIHx8IHR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IGdldFRva2VuKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmFsb24ubWl4KGJpbmRpbmcsIHRva2VuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nLmZpbHRlcnMgPSBiaW5kaW5nLmZpbHRlcnMucmVwbGFjZShyaGFzSHRtbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZy50eXBlID0gXCJodG1sXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmcuZ3JvdXAgPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkdXBsZXhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaGFzRHVwbGV4ID0gbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJtcy1pZi1sb29wXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZy5wcmlvcml0eSArPSAxMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ3MucHVzaChiaW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIndpZGdldFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0ubXNEYXRhID0gZWxlbS5tc0RhdGEgfHwgbXNEYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJpbmRpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzLnNvcnQoYmluZGluZ1NvcnRlcilcbiAgICAgICAgICAgICAgICBmaXhBdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwid2FybmluZyHor7fmlLnnlKhcIiArIGFyclsxXSArIFwi5Luj5pu/XCIgKyBhcnJbMF0gKyBcIiFcIilcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoYXJyWzBdKVxuICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShhcnJbMV0sIGFyclsyXSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNzA3MVxuICAgICAgICAgICAgICAgIC8v5ZyoSUXkuIvlr7lWTUzor7vlj5Z0eXBl5bGe5oCnLOS8muiuqeatpOWFg+e0oOaJgOacieWxnuaAp+mDveWPmOaIkDxGYWlsZWQ+XG4gICAgICAgICAgICAgICAgaWYgKGhhc0R1cGxleCAmJiBtc0RhdGFbXCJtcy1hdHRyLXZhbHVlXCJdICYmICFlbGVtLnNjb3BlTmFtZSAmJiBlbGVtLnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIndhcm5pbmch5LiA5Liq5o6n5Lu25LiN6IO95ZCM5pe25a6a5LmJbXMtYXR0ci12YWx1ZeS4jlwiICsgaGFzRHVwbGV4KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBiaW5kaW5nID0gYmluZGluZ3NbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gYmluZGluZy50eXBlXG4gICAgICAgICAgICAgICAgICAgIGlmIChybm9zY2FuQXR0ckJpbmRpbmcudGVzdCh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVCaW5kaW5ncyhiaW5kaW5ncy5zbGljZSgwLCBpICsgMSksIHZtb2RlbHMpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2Nhbk5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5Ob2RlID0gIXJub3NjYW5Ob2RlQmluZGluZy50ZXN0KHR5cGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZXhlY3V0ZUJpbmRpbmdzKGJpbmRpbmdzLCB2bW9kZWxzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FuTm9kZSAmJiAhc3RvcFNjYW5bZWxlbS50YWdOYW1lXSAmJiByYmluZC50ZXN0KGVsZW0uaW5uZXJIVE1MLnJlcGxhY2Uocmx0LCBcIjxcIikucmVwbGFjZShyZ3QsIFwiPlwiKSkpIHtcbiAgICAgICAgICAgIG1lcmdlVGV4dE5vZGVzICYmIG1lcmdlVGV4dE5vZGVzKGVsZW0pXG4gICAgICAgICAgICBzY2FuTm9kZUxpc3QoZWxlbSwgdm1vZGVscykgLy/miavmj4/lrZDlrZnlhYPntKBcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcm5vc2NhbkF0dHJCaW5kaW5nID0gL15pZnx3aWRnZXR8cmVwZWF0JC9cbiAgICB2YXIgcm5vc2Nhbk5vZGVCaW5kaW5nID0gL15lYWNofHdpdGh8aHRtbHxpbmNsdWRlJC9cbi8vSUU2N+S4i++8jOWcqOW+queOr+e7keWumuS4re+8jOS4gOS4quiKgueCueWmguaenOaYr+mAmui/h2Nsb25lTm9kZeW+l+WIsO+8jOiHquWumuS5ieWxnuaAp+eahHNwZWNpZmllZOS4umZhbHNl77yM5peg5rOV6L+b5YWl6YeM6Z2i55qE5YiG5pSv77yMXG4vL+S9huWmguaenOaIkeS7rOWOu+aOiXNjYW5BdHRy5Lit55qEYXR0ci5zcGVjaWZpZWTmo4DmtYvvvIzkuIDkuKrlhYPntKDkvJrmnIk4MCvkuKrnibnmgKfoioLngrnvvIjlm6DkuLrlroPkuI3ljLrliIblm7rmnInlsZ7mgKfkuI7oh6rlrprkuYnlsZ7mgKfvvInvvIzlvojlrrnmmJPljaHmrbvpobXpnaJcbiAgICBpZiAoIVczQykge1xuICAgICAgICB2YXIgYXR0clBvb2wgPSBuZXcgQ2FjaGUoNTEyKVxuICAgICAgICB2YXIgcmF0dHJzID0gL1xccysobXMtW149XFxzXSspKD86PShcIlteXCJdKlwifCdbXiddKid8W15cXHM+XSspKT8vZyxcbiAgICAgICAgICAgIHJxdW90ZSA9IC9eWydcIl0vLFxuICAgICAgICAgICAgcnRhZyA9IC88XFx3K1xcYig/OihbXCInXSlbXlwiXSo/KFxcMSl8W14+XSkqPi9pLFxuICAgICAgICAgICAgcmFtcCA9IC8mYW1wOy9nXG4gICAgICAgIC8vSUU2LTjop6PmnpBIVE1MNeaWsOagh+etvu+8jOS8muWwhuWug+WIhuino+S4pOS4quWFg+e0oOiKgueCueS4juS4gOS4quaWh+acrOiKgueCuVxuICAgICAgICAvLzxib2R5PjxzZWN0aW9uPmRkZDwvc2VjdGlvbj48L2JvZHk+XG4gICAgICAgIC8vICAgICAgICB3aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5XG4gICAgICAgIC8vICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVsOyBlbCA9IGJvZHkuY2hpbGRyZW5baSsrXTsgKSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgIGF2YWxvbi5sb2coZWwub3V0ZXJIVE1MKVxuICAgICAgICAvLyAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgIH1cbiAgICAgICAgLy/kvp3mrKHovpPlh7o8U0VDVElPTj4sIDwvU0VDVElPTj5cbiAgICAgICAgdmFyIGdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBlbGVtLm91dGVySFRNTFxuICAgICAgICAgICAgLy/lpITnkIZJRTYtOOino+aekEhUTUw15paw5qCH562+55qE5oOF5Ya177yM5Y+KPGJyPuetieWNiumXreWQiOagh+etvm91dGVySFRNTOS4uuepuueahOaDheWGtVxuICAgICAgICAgICAgaWYgKGh0bWwuc2xpY2UoMCwgMikgPT09IFwiPC9cIiB8fCAhaHRtbC50cmltKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHIgPSBodG1sLm1hdGNoKHJ0YWcpWzBdXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IFtdLFxuICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgIGssIHZcbiAgICAgICAgICAgIHZhciByZXQgPSBhdHRyUG9vbC5nZXQoc3RyKVxuICAgICAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChrID0gcmF0dHJzLmV4ZWMoc3RyKSkge1xuICAgICAgICAgICAgICAgIHYgPSBrWzJdXG4gICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IChycXVvdGUudGVzdCh2KSA/IHYuc2xpY2UoMSwgLTEpIDogdikucmVwbGFjZShyYW1wLCBcIiZcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBrWzFdLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG5hbWUubWF0Y2gocm1zQXR0cilcbiAgICAgICAgICAgICAgICB2YXIgYmluZGluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdiB8fCBcIlwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChiaW5kaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF0dHJQb29sLnB1dChzdHIsIGF0dHJpYnV0ZXMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuTm9kZUxpc3QocGFyZW50LCB2bW9kZWxzKSB7XG4gICAgICAgIHZhciBub2RlcyA9IGF2YWxvbi5zbGljZShwYXJlbnQuY2hpbGROb2RlcylcbiAgICAgICAgc2Nhbk5vZGVBcnJheShub2Rlcywgdm1vZGVscylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY2FuTm9kZUFycmF5KG5vZGVzLCB2bW9kZWxzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBub2RlOyBub2RlID0gbm9kZXNbaSsrXTspIHtcbiAgICAgICAgICAgIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgc2NhblRhZyhub2RlLCB2bW9kZWxzKSAvL+aJq+aPj+WFg+e0oOiKgueCuVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5tc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1zQ2FsbGJhY2soKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tc0NhbGxiYWNrID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIGlmKHJleHByLnRlc3Qobm9kZS5ub2RlVmFsdWUpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5UZXh0KG5vZGUsIHZtb2RlbHMsIGkpIC8v5omr5o+P5paH5pys6IqC54K5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gc2NhblRhZyhlbGVtLCB2bW9kZWxzLCBub2RlKSB7XG4gICAgICAgIC8v5omr5o+P6aG65bqPICBtcy1za2lwKDApIC0tPiBtcy1pbXBvcnRhbnQoMSkgLS0+IG1zLWNvbnRyb2xsZXIoMikgLS0+IG1zLWlmKDEwKSAtLT4gbXMtcmVwZWF0KDEwMClcbiAgICAgICAgLy8tLT4gbXMtaWYtbG9vcCgxMTApIC0tPiBtcy1hdHRyKDk3MCkgLi4uLS0+IG1zLWVhY2goMTQwMCktLT5tcy13aXRoKDE1MDApLS3jgIltcy1kdXBsZXgoMjAwMCnlnqvlkI5cbiAgICAgICAgdmFyIGEgPSBlbGVtLmdldEF0dHJpYnV0ZShcIm1zLXNraXBcIilcbiAgICAgICAgLy8jMzYwIOWcqOaXp+W8j0lF5LitIE9iamVjdOagh+etvuWcqOW8leWFpUZsYXNo562J6LWE5rqQ5pe2LOWPr+iDveWHuueOsOayoeaciWdldEF0dHJpYnV0ZU5vZGUsaW5uZXJIVE1M55qE5oOF5b2iXG4gICAgICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nKFwid2FybmluZyBcIiArIGVsZW0udGFnTmFtZSArIFwiIG5vIGdldEF0dHJpYnV0ZU5vZGUgbWV0aG9kXCIpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJtcy1pbXBvcnRhbnRcIilcbiAgICAgICAgdmFyIGMgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJtcy1jb250cm9sbGVyXCIpXG4gICAgICAgIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gZWxzZSBpZiAobm9kZSA9IGIgfHwgYykge1xuICAgICAgICAgICAgdmFyIG5ld1Ztb2RlbCA9IGF2YWxvbi52bW9kZWxzW25vZGUudmFsdWVdXG4gICAgICAgICAgICBpZiAoIW5ld1Ztb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9tcy1pbXBvcnRhbnTkuI3ljIXlkKvniLZWTe+8jG1zLWNvbnRyb2xsZXLnm7jlj41cbiAgICAgICAgICAgIHZtb2RlbHMgPSBub2RlID09PSBiID8gW25ld1Ztb2RlbF0gOiBbbmV3Vm1vZGVsXS5jb25jYXQodm1vZGVscylcbiAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5uYW1lXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSAvL3JlbW92ZUF0dHJpYnV0ZU5vZGXkuI3kvJrliLfmlrBbbXMtY29udHJvbGxlcl3moLflvI/op4TliJlcbiAgICAgICAgICAgIGF2YWxvbihlbGVtKS5yZW1vdmVDbGFzcyhuYW1lKVxuICAgICAgICAgICAgY3JlYXRlU2lnbmFsVG93ZXIoZWxlbSwgbmV3Vm1vZGVsKVxuICAgICAgICB9XG4gICAgICAgIHNjYW5BdHRyKGVsZW0sIHZtb2RlbHMpIC8v5omr5o+P54m55oCn6IqC54K5XG4gICAgfVxuICAgIHZhciByaGFzSHRtbCA9IC9cXHxcXHMqaHRtbCg/OlxcYnwkKS8sXG4gICAgICAgIHIxMWEgPSAvXFx8XFx8L2csXG4gICAgICAgIHJsdCA9IC8mbHQ7L2csXG4gICAgICAgIHJndCA9IC8mZ3Q7L2csXG4gICAgICAgIHJzdHJpbmdMaXRlcmFsID0gLyhbJ1wiXSkoXFxcXFxcMXwuKSs/XFwxL2dcbiAgICBmdW5jdGlvbiBnZXRUb2tlbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUuaW5kZXhPZihcInxcIikgPiAwKSB7XG4gICAgICAgICAgICB2YXIgc2NhcGVnb2F0ID0gdmFsdWUucmVwbGFjZShyc3RyaW5nTGl0ZXJhbCwgZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkoXy5sZW5ndGggKyAxKS5qb2luKFwiMVwiKS8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHNjYXBlZ29hdC5yZXBsYWNlKHIxMWEsIFwiXFx1MTEyMlxcdTMzNDRcIikuaW5kZXhPZihcInxcIikgLy/lubLmjonmiYDmnInnn63ot6/miJZcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyczogdmFsdWUuc2xpY2UoaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICBleHByOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBmaWx0ZXJzOiBcIlwiLFxuICAgICAgICAgICAgZXhwcjogdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbkV4cHIoc3RyKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBbXSxcbiAgICAgICAgICAgIHZhbHVlLCBzdGFydCA9IDAsXG4gICAgICAgICAgICBzdG9wXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHN0b3AgPSBzdHIuaW5kZXhPZihvcGVuVGFnLCBzdGFydClcbiAgICAgICAgICAgIGlmIChzdG9wID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IHN0ci5zbGljZShzdGFydCwgc3RvcClcbiAgICAgICAgICAgIGlmICh2YWx1ZSkgeyAvLyB7eyDlt6bovrnnmoTmlofmnKxcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyczogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwcjogZmFsc2VcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSBzdG9wICsgb3BlblRhZy5sZW5ndGhcbiAgICAgICAgICAgIHN0b3AgPSBzdHIuaW5kZXhPZihjbG9zZVRhZywgc3RhcnQpXG4gICAgICAgICAgICBpZiAoc3RvcCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBzdHIuc2xpY2Uoc3RhcnQsIHN0b3ApXG4gICAgICAgICAgICBpZiAodmFsdWUpIHsgLy/lpITnkIZ7eyB9feaPkuWAvOihqOi+vuW8j1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGdldFRva2VuKHZhbHVlKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXJ0ID0gc3RvcCArIGNsb3NlVGFnLmxlbmd0aFxuICAgICAgICB9IHdoaWxlICgxKVxuICAgICAgICB2YWx1ZSA9IHN0ci5zbGljZShzdGFydClcbiAgICAgICAgaWYgKHZhbHVlKSB7IC8vfX0g5Y+z6L6555qE5paH5pysXG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGV4cHI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGZpbHRlcnM6IFwiXCJcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2Vuc1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjYW5UZXh0KHRleHROb2RlLCB2bW9kZWxzKSB7XG4gICAgICAgIHZhciBiaW5kaW5ncyA9IFtdLCB0b2tlbnMgPSBzY2FuRXhwcih0ZXh0Tm9kZS5kYXRhKVxuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHRva2VuOyB0b2tlbiA9IHRva2Vuc1tpKytdOyApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IERPQy5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSkgLy/lsIbmlofmnKzovazmjaLkuLrmlofmnKzoioLngrnvvIzlubbmm7/mjaLljp/mnaXnmoTmlofmnKzoioLngrlcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZXhwcikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi52YWx1ZSA9IHRva2VuLnZhbHVlLnJlcGxhY2Uocm9uZVRpbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLm9uZVRpbWUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgICAgICAgICAgICAgICB9KS8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi50eXBlID0gXCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZWxlbWVudCA9IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZmlsdGVycyA9IHRva2VuLmZpbHRlcnMucmVwbGFjZShyaGFzSHRtbCwgZnVuY3Rpb24gKGEsIGIsYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udHlwZSA9IFwiaHRtbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJcIlxuICAgICAgICAgICAgICAgICAgICB9KS8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgICAgICBiaW5kaW5ncy5wdXNoKHRva2VuKSAvL+aUtumbhuW4puacieaPkuWAvOihqOi+vuW8j+eahOaWh+acrFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmFsb25GcmFnbWVudC5hcHBlbmRDaGlsZChub2RlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dE5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoYXZhbG9uRnJhZ21lbnQsIHRleHROb2RlKVxuICAgICAgICAgICAgaWYgKGJpbmRpbmdzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBleGVjdXRlQmluZGluZ3MoYmluZGluZ3MsIHZtb2RlbHMpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYm9vbHMgPSBbXCJhdXRvZm9jdXMsYXV0b3BsYXksYXN5bmMsYWxsb3dUcmFuc3BhcmVuY3ksY2hlY2tlZCxjb250cm9sc1wiLFxuICAgICAgICBcImRlY2xhcmUsZGlzYWJsZWQsZGVmZXIsZGVmYXVsdENoZWNrZWQsZGVmYXVsdFNlbGVjdGVkXCIsXG4gICAgICAgIFwiY29udGVudEVkaXRhYmxlLGlzTWFwLGxvb3AsbXVsdGlwbGUsbm9IcmVmLG5vUmVzaXplLG5vU2hhZGVcIixcbiAgICAgICAgXCJvcGVuLHJlYWRPbmx5LHNlbGVjdGVkXCJcbiAgICBdLmpvaW4oXCIsXCIpXG4gICAgdmFyIGJvb2xNYXAgPSB7fVxuICAgIGJvb2xzLnJlcGxhY2UocndvcmQsIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGJvb2xNYXBbbmFtZS50b0xvd2VyQ2FzZSgpXSA9IG5hbWVcbiAgICB9KVxuXG4gICAgdmFyIHByb3BNYXAgPSB7Ly/lsZ7mgKflkI3mmKDlsIRcbiAgICAgICAgXCJhY2NlcHQtY2hhcnNldFwiOiBcImFjY2VwdENoYXJzZXRcIixcbiAgICAgICAgXCJjaGFyXCI6IFwiY2hcIixcbiAgICAgICAgXCJjaGFyb2ZmXCI6IFwiY2hPZmZcIixcbiAgICAgICAgXCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiLFxuICAgICAgICBcImZvclwiOiBcImh0bWxGb3JcIixcbiAgICAgICAgXCJodHRwLWVxdWl2XCI6IFwiaHR0cEVxdWl2XCJcbiAgICB9XG5cbiAgICB2YXIgYW5vbWFseSA9IFtcImFjY2Vzc0tleSxiZ0NvbG9yLGNlbGxQYWRkaW5nLGNlbGxTcGFjaW5nLGNvZGVCYXNlLGNvZGVUeXBlLGNvbFNwYW5cIixcbiAgICAgICAgXCJkYXRlVGltZSxkZWZhdWx0VmFsdWUsZnJhbWVCb3JkZXIsbG9uZ0Rlc2MsbWF4TGVuZ3RoLG1hcmdpbldpZHRoLG1hcmdpbkhlaWdodFwiLFxuICAgICAgICBcInJvd1NwYW4sdGFiSW5kZXgsdXNlTWFwLHZTcGFjZSx2YWx1ZVR5cGUsdkFsaWduXCJcbiAgICBdLmpvaW4oXCIsXCIpXG4gICAgYW5vbWFseS5yZXBsYWNlKHJ3b3JkLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBwcm9wTWFwW25hbWUudG9Mb3dlckNhc2UoKV0gPSBuYW1lXG4gICAgfSlcblxuICAgIHZhciBybm9zY3JpcHRzID0gLzxub3NjcmlwdC4qPz4oPzpbXFxzXFxTXSs/KTxcXC9ub3NjcmlwdD4vaW1nXG4gICAgdmFyIHJub3NjcmlwdFRleHQgPSAvPG5vc2NyaXB0Lio/PihbXFxzXFxTXSs/KTxcXC9ub3NjcmlwdD4vaW1cblxuICAgIHZhciBnZXRYSFIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBBY3RpdmVYT2JqZWN0KShcIk1pY3Jvc29mdC5YTUxIVFRQXCIpIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZVBvb2wgPSBhdmFsb24udGVtcGxhdGVDYWNoZSA9IHt9XG5cbiAgICBiaW5kaW5nSGFuZGxlcnMuYXR0ciA9IGZ1bmN0aW9uIChkYXRhLCB2bW9kZWxzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHN0cmluZ2lmeUV4cHIoZGF0YS52YWx1ZS50cmltKCkpXG4gICAgICAgIGlmIChkYXRhLnR5cGUgPT09IFwiaW5jbHVkZVwiKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IGRhdGEuZWxlbWVudFxuICAgICAgICAgICAgZGF0YS5pbmNsdWRlUmVuZGVyZWQgPSBnZXRCaW5kaW5nQ2FsbGJhY2soZWxlbSwgXCJkYXRhLWluY2x1ZGUtcmVuZGVyZWRcIiwgdm1vZGVscylcbiAgICAgICAgICAgIGRhdGEuaW5jbHVkZUxvYWRlZCA9IGdldEJpbmRpbmdDYWxsYmFjayhlbGVtLCBcImRhdGEtaW5jbHVkZS1sb2FkZWRcIiwgdm1vZGVscylcbiAgICAgICAgICAgIHZhciBvdXRlciA9IGRhdGEuaW5jbHVkZVJlcGxhY2UgPSAhIWF2YWxvbihlbGVtKS5kYXRhKFwiaW5jbHVkZVJlcGxhY2VcIilcbiAgICAgICAgICAgIGlmIChhdmFsb24oZWxlbSkuZGF0YShcImluY2x1ZGVDYWNoZVwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGEudGVtcGxhdGVDYWNoZSA9IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnN0YXJ0SW5jbHVkZSA9IERPQy5jcmVhdGVDb21tZW50KFwibXMtaW5jbHVkZVwiKVxuICAgICAgICAgICAgZGF0YS5lbmRJbmNsdWRlID0gRE9DLmNyZWF0ZUNvbW1lbnQoXCJtcy1pbmNsdWRlLWVuZFwiKVxuICAgICAgICAgICAgaWYgKG91dGVyKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5lbGVtZW50ID0gZGF0YS5zdGFydEluY2x1ZGVcbiAgICAgICAgICAgICAgICBlbGVtLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRhdGEuc3RhcnRJbmNsdWRlLCBlbGVtKVxuICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZGF0YS5lbmRJbmNsdWRlLCBlbGVtLm5leHRTaWJsaW5nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtLmluc2VydEJlZm9yZShkYXRhLnN0YXJ0SW5jbHVkZSwgZWxlbS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoZGF0YS5lbmRJbmNsdWRlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGEuaGFuZGxlck5hbWUgPSBcImF0dHJcIiAvL2hhbmRsZU5hbWXnlKjkuo7lpITnkIblpJrnp43nu5HlrprlhbHnlKjlkIzkuIDnp41iaW5kaW5nRXhlY3V0b3LnmoTmg4XlhrVcbiAgICAgICAgcGFyc2VFeHByUHJveHkodmFsdWUsIHZtb2RlbHMsIGRhdGEpXG4gICAgfVxuXG4gICAgYmluZGluZ0V4ZWN1dG9ycy5hdHRyID0gZnVuY3Rpb24gKHZhbCwgZWxlbSwgZGF0YSkge1xuICAgICAgICB2YXIgbWV0aG9kID0gZGF0YS50eXBlLFxuICAgICAgICAgICAgYXR0ck5hbWUgPSBkYXRhLnBhcmFtXG4gICAgICAgIGlmIChtZXRob2QgPT09IFwiY3NzXCIpIHtcbiAgICAgICAgICAgIGF2YWxvbihlbGVtKS5jc3MoYXR0ck5hbWUsIHZhbClcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwiYXR0clwiKSB7XG5cbiAgICAgICAgICAgIC8vIG1zLWF0dHItY2xhc3M9XCJ4eHhcIiB2bS54eHg9XCJhYWEgYmJiIGNjY1wi5bCG5YWD57Sg55qEY2xhc3NOYW1l6K6+572u5Li6YWFhIGJiYiBjY2NcbiAgICAgICAgICAgIC8vIG1zLWF0dHItY2xhc3M9XCJ4eHhcIiB2bS54eHg9ZmFsc2UgIOa4heepuuWFg+e0oOeahOaJgOacieexu+WQjVxuICAgICAgICAgICAgLy8gbXMtYXR0ci1uYW1lPVwieXl5XCIgIHZtLnl5eT1cIm9vb1wiIOS4uuWFg+e0oOiuvue9rm5hbWXlsZ7mgKdcbiAgICAgICAgICAgIHZhciB0b1JlbW92ZSA9ICh2YWwgPT09IGZhbHNlKSB8fCAodmFsID09PSBudWxsKSB8fCAodmFsID09PSB2b2lkIDApXG5cbiAgICAgICAgICAgIGlmICghVzNDICYmIHByb3BNYXBbYXR0ck5hbWVdKSB7IC8v5pen5byPSUXkuIvpnIDopoHov5vooYzlkI3lrZfmmKDlsIRcbiAgICAgICAgICAgICAgICBhdHRyTmFtZSA9IHByb3BNYXBbYXR0ck5hbWVdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYm9vbCA9IGJvb2xNYXBbYXR0ck5hbWVdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVsZW1bYm9vbF0gPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgZWxlbVtib29sXSA9ICEhdmFsIC8v5biD5bCU5bGe5oCn5b+F6aG75L2/55SoZWwueHh4ID0gdHJ1ZXxmYWxzZeaWueW8j+iuvuWAvFxuICAgICAgICAgICAgICAgIGlmICghdmFsKSB7IC8v5aaC5p6c5Li6ZmFsc2UsIElF5YWo57O75YiX5LiL55u45b2T5LqOc2V0QXR0cmlidXRlKHh4eCwnJyks5Lya5b2x5ZON5Yiw5qC35byPLOmcgOimgei/m+S4gOatpeWkhOeQhlxuICAgICAgICAgICAgICAgICAgICB0b1JlbW92ZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9SZW1vdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbS5yZW1vdmVBdHRyaWJ1dGUoYXR0ck5hbWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1NWR+WPquiDveS9v+eUqHNldEF0dHJpYnV0ZSh4eHgsIHl5eSksIFZNTOWPquiDveS9v+eUqGVsZW0ueHh4ID0geXl5ICxIVE1M55qE5Zu65pyJ5bGe5oCn5b+F6aG7ZWxlbS54eHggPSB5eXlcbiAgICAgICAgICAgIHZhciBpc0lubmF0ZSA9IHJzdmcudGVzdChlbGVtKSA/IGZhbHNlIDogKERPQy5uYW1lc3BhY2VzICYmIGlzVk1MKGVsZW0pKSA/IHRydWUgOiBhdHRyTmFtZSBpbiBlbGVtLmNsb25lTm9kZShmYWxzZSlcbiAgICAgICAgICAgIGlmIChpc0lubmF0ZSkge1xuICAgICAgICAgICAgICAgIGVsZW1bYXR0ck5hbWVdID0gdmFsICsgXCJcIlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgdmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJpbmNsdWRlXCIgJiYgdmFsKSB7XG4gICAgICAgICAgICB2YXIgdm1vZGVscyA9IGRhdGEudm1vZGVsc1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkID0gZGF0YS5pbmNsdWRlUmVuZGVyZWRcbiAgICAgICAgICAgIHZhciBsb2FkZWQgPSBkYXRhLmluY2x1ZGVMb2FkZWRcbiAgICAgICAgICAgIHZhciByZXBsYWNlID0gZGF0YS5pbmNsdWRlUmVwbGFjZVxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHJlcGxhY2UgPyBlbGVtLnBhcmVudE5vZGUgOiBlbGVtXG4gICAgICAgICAgICB2YXIgc2NhblRlbXBsYXRlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS52bW9kZWxzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1RleHQgPSBsb2FkZWQuYXBwbHkodGFyZ2V0LCBbdGV4dF0uY29uY2F0KHZtb2RlbHMpKVxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gbmV3VGV4dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tTY2FuKHRhcmdldCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQuY2FsbCh0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIH0sIE5hTilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RJRCA9IGRhdGEuaW5jbHVkZUxhc3RJRFxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnRlbXBsYXRlQ2FjaGUgJiYgbGFzdElEICYmIGxhc3RJRCAhPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0VGVtcGxhdGUgPSBkYXRhLnRlbXBsYXRlQ2FjaGVbbGFzdElEXVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxhc3RUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRlbXBsYXRlID0gZGF0YS50ZW1wbGF0ZUNhY2hlW2xhc3RJRF0gPSBET0MuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWZHcm91cC5hcHBlbmRDaGlsZChsYXN0VGVtcGxhdGUpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5pbmNsdWRlTGFzdElEID0gdmFsXG4gICAgICAgICAgICAgICAgd2hpbGUgKGRhdGEuc3RhcnRJbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gZGF0YS5zdGFydEluY2x1ZGUubmV4dFNpYmxpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZSAhPT0gZGF0YS5lbmRJbmNsdWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlQ2hpbGQobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0VGVtcGxhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFRlbXBsYXRlLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkb20gPSBnZXRUZW1wbGF0ZU5vZGVzKGRhdGEsIHZhbCwgdGV4dClcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBhdmFsb24uc2xpY2UoZG9tLmNoaWxkTm9kZXMpXG4gICAgICAgICAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZShkb20sIGRhdGEuZW5kSW5jbHVkZSlcbiAgICAgICAgICAgICAgICBzY2FuTm9kZUFycmF5KG5vZGVzLCB2bW9kZWxzKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YS5wYXJhbSA9PT0gXCJzcmNcIikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGVQb29sW3ZhbF0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXZhbG9uLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5UZW1wbGF0ZSh0ZW1wbGF0ZVBvb2xbdmFsXSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGVtcGxhdGVQb29sW3ZhbF0pKSB7IC8vIzgwNSDpmLLmraLlnKjlvqrnjq/nu5HlrprkuK3lj5Hlh7rorrjlpJrnm7jlkIznmoTor7fmsYJcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQb29sW3ZhbF0ucHVzaChzY2FuVGVtcGxhdGUpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhociA9IGdldFhIUigpXG4gICAgICAgICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IHhoci5zdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA+PSAyMDAgJiYgcyA8IDMwMCB8fCBzID09PSAzMDQgfHwgcyA9PT0gMTIyMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHhoci5yZXNwb25zZVRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZiA9IDAsIGZuOyBmbiA9IHRlbXBsYXRlUG9vbFt2YWxdW2YrK107ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm4odGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVBvb2xbdmFsXSA9IHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQb29sW3ZhbF0gPSBbc2NhblRlbXBsYXRlXVxuICAgICAgICAgICAgICAgICAgICB4aHIub3BlbihcIkdFVFwiLCB2YWwsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChcIndpdGhDcmVkZW50aWFsc1wiIGluIHhocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlgtUmVxdWVzdGVkLVdpdGhcIiwgXCJYTUxIdHRwUmVxdWVzdFwiKVxuICAgICAgICAgICAgICAgICAgICB4aHIuc2VuZChudWxsKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9JReezu+WIl+S4juWkn+aWsOeahOagh+WHhua1j+iniOWZqOaUr+aMgemAmui/h0lE5Y+W5b6X5YWD57Sg77yIZmlyZWZveDE0K++8iVxuICAgICAgICAgICAgICAgIC8vaHR0cDovL3RqdmFudG9sbC5jb20vMjAxMi8wNy8xOS9kb20tZWxlbWVudC1yZWZlcmVuY2VzLWFzLWdsb2JhbC12YXJpYWJsZXMvXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gdmFsICYmIHZhbC5ub2RlVHlwZSA9PT0gMSA/IHZhbCA6IERPQy5nZXRFbGVtZW50QnlJZCh2YWwpXG4gICAgICAgICAgICAgICAgaWYgKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC50YWdOYW1lID09PSBcIk5PU0NSSVBUXCIgJiYgIShlbC5pbm5lckhUTUwgfHwgZWwuZml4SUU3OCkpIHsgLy9JRTctOCBpbm5lclRleHQsaW5uZXJIVE1M6YO95peg5rOV5Y+W5b6X5YW25YaF5a6577yMSUU26IO95Y+W5b6X5YW2aW5uZXJIVE1MXG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIgPSBnZXRYSFIoKSAvL0lFOS0xMeS4jmNocm9tZeeahGlubmVySFRNTOS8muW+l+WIsOi9rOS5ieeahOWGheWuue+8jOWug+S7rOeahGlubmVyVGV4dOWPr+S7pVxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgbG9jYXRpb24sIGZhbHNlKSAvL+iwouiwok5vZGVqcyDkubHngpbnvqQg5rex5ZyzLee6r+WxnuiZmuaehFxuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQobnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cDovL2Jicy5jc2RuLm5ldC90b3BpY3MvMzkwMzQ5MDQ2P3BhZ2U9MSNwb3N0LTM5MzQ5MjY1M1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vc2NyaXB0cyA9IERPQy5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm5vc2NyaXB0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSAoeGhyLnJlc3BvbnNlVGV4dCB8fCBcIlwiKS5tYXRjaChybm9zY3JpcHRzKSB8fCBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBhcnJheS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9IG5vc2NyaXB0c1tpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWcpIHsgLy9JRTYtOOS4rW5vc2NyaXB05qCH562+55qEaW5uZXJIVE1MLGlubmVyVGV4dOaYr+WPquivu+eahFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiIC8vaHR0cDovL2hhc2xheW91dC5uZXQvY3NzL25vc2NyaXB0LUdob3N0LUJ1Z1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcuZml4SUU3OCA9IChhcnJheVtpXS5tYXRjaChybm9zY3JpcHRUZXh0KSB8fCBbXCJcIiwgXCImbmJzcDtcIl0pWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF2YWxvbi5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuVGVtcGxhdGUoZWwuZml4SUU3OCB8fCBlbC52YWx1ZSB8fCBlbC5pbm5lclRleHQgfHwgZWwuaW5uZXJIVE1MKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcm9vdC5oYXNBdHRyaWJ1dGUgJiYgdHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiAmJiAobWV0aG9kID09PSBcInNyY1wiIHx8IG1ldGhvZCA9PT0gXCJocmVmXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gdmFsLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKSAvL+WkhOeQhklFNjfoh6rliqjovazkuYnnmoTpl67pophcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1bbWV0aG9kXSA9IHZhbFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5jaHJvbWUgJiYgZWxlbS50YWdOYW1lID09PSBcIkVNQkVEXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlIC8vIzUyNSAgY2hyb21lMS0zN+S4i2VtYmVk5qCH562+5Yqo5oCB6K6+572uc3Jj5LiN6IO95Y+R55Sf6K+35rGCXG4gICAgICAgICAgICAgICAgdmFyIGNvbW1lbnQgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwibXMtc3JjXCIpXG4gICAgICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChjb21tZW50LCBlbGVtKVxuICAgICAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlQ2hpbGQoZWxlbSwgY29tbWVudClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFRlbXBsYXRlTm9kZXMoZGF0YSwgaWQsIHRleHQpIHtcbiAgICAgICAgdmFyIGRpdiA9IGRhdGEudGVtcGxhdGVDYWNoZSAmJiBkYXRhLnRlbXBsYXRlQ2FjaGVbaWRdXG4gICAgICAgIGlmIChkaXYpIHtcbiAgICAgICAgICAgIHZhciBkb20gPSBET0MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuICAgICAgICAgICAgICAgIGZpcnN0Q2hpbGRcbiAgICAgICAgICAgIHdoaWxlIChmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoZmlyc3RDaGlsZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkb21cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXZhbG9uLnBhcnNlSFRNTCh0ZXh0KVxuICAgIH1cblxuLy/ov5nlh6DkuKrmjIfku6Tpg73lj6/ku6Xkvb/nlKjmj5LlgLzooajovr7lvI/vvIzlpoJtcy1zcmM9XCJhYWEve3tifX0ve3tjfX0uaHRtbFwiXG4gICAgXCJ0aXRsZSxhbHQsc3JjLHZhbHVlLGNzcyxpbmNsdWRlLGhyZWZcIi5yZXBsYWNlKHJ3b3JkLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBiaW5kaW5nSGFuZGxlcnNbbmFtZV0gPSBiaW5kaW5nSGFuZGxlcnMuYXR0clxuICAgIH0pXG4vL+agueaNrlZN55qE5bGe5oCn5YC85oiW6KGo6L6+5byP55qE5YC85YiH5o2i57G75ZCN77yMbXMtY2xhc3M9XCJ4eHggeXl5IHp6ejpmbGFnXCJcbi8vaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9ydWJ5bG91dnJlL2FyY2hpdmUvMjAxMi8xMi8xNy8yODE4NTQwLmh0bWxcbiAgICBiaW5kaW5nSGFuZGxlcnNbXCJjbGFzc1wiXSA9IGZ1bmN0aW9uIChiaW5kaW5nLCB2bW9kZWxzKSB7XG4gICAgICAgIHZhciBvbGRTdHlsZSA9IGJpbmRpbmcucGFyYW0sXG4gICAgICAgICAgICB0ZXh0ID0gYmluZGluZy52YWx1ZSxcbiAgICAgICAgICAgIHJpZ2h0RXhwclxuICAgICAgICBiaW5kaW5nLmhhbmRsZXJOYW1lID0gXCJjbGFzc1wiXG4gICAgICAgIGlmICghb2xkU3R5bGUgfHwgaXNGaW5pdGUob2xkU3R5bGUpKSB7XG4gICAgICAgICAgICBiaW5kaW5nLnBhcmFtID0gXCJcIiAvL+WOu+aOieaVsOWtl1xuICAgICAgICAgICAgdmFyIGNvbG9uSW5kZXggPSB0ZXh0LnJlcGxhY2UocmV4cHJnLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJlcGxhY2UoLy4vZywgXCIwXCIpXG4gICAgICAgICAgICB9KS5pbmRleE9mKFwiOlwiKSAvL+WPluW+l+esrOS4gOS4quWGkuWPt+eahOS9jee9rlxuICAgICAgICAgICAgaWYgKGNvbG9uSW5kZXggPT09IC0xKSB7IC8vIOavlOWmgiBtcy1jbGFzcz1cImFhYSBiYmIgY2NjXCIg55qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRleHRcbiAgICAgICAgICAgICAgICByaWdodEV4cHIgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyDmr5TlpoIgbXMtY2xhc3MtMT1cInVpLXN0YXRlLWFjdGl2ZTpjaGVja2VkXCIg55qE5oOF5Ya1XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lID0gdGV4dC5zbGljZSgwLCBjb2xvbkluZGV4KVxuICAgICAgICAgICAgICAgIHJpZ2h0RXhwciA9IHRleHQuc2xpY2UoY29sb25JbmRleCArIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJleHByLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWUgPSBxdW90ZShjbGFzc05hbWUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZSA9IHN0cmluZ2lmeUV4cHIoY2xhc3NOYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZGluZy5leHByID0gXCJbXCIgKyBjbGFzc05hbWUgKyBcIixcIiArIHJpZ2h0RXhwciArIFwiXVwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaW5kaW5nLmV4cHIgPSAnWycgKyBxdW90ZShvbGRTdHlsZSkgKyBcIixcIiArIHRleHQgKyBcIl1cIlxuICAgICAgICAgICAgYmluZGluZy5vbGRTdHlsZSA9IG9sZFN0eWxlXG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGhvZCA9IGJpbmRpbmcudHlwZVxuICAgICAgICBpZiAobWV0aG9kID09PSBcImhvdmVyXCIgfHwgbWV0aG9kID09PSBcImFjdGl2ZVwiKSB7IC8v56Gu5L+d5Y+q57uR5a6a5LiA5qyhXG4gICAgICAgICAgICBpZiAoIWJpbmRpbmcuaGFzQmluZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBiaW5kaW5nLmVsZW1lbnRcbiAgICAgICAgICAgICAgICB2YXIgJGVsZW0gPSBhdmFsb24oZWxlbSlcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZhdGUgPSBcIm1vdXNlZW50ZXJcIiAvL+WcqOenu+WHuuenu+WFpeaXtuWIh+aNouexu+WQjVxuICAgICAgICAgICAgICAgIHZhciBhYmFuZG9uID0gXCJtb3VzZWxlYXZlXCJcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImFjdGl2ZVwiKSB7IC8v5Zyo6IGa54Sm5aSx54Sm5Lit5YiH5o2i57G75ZCNXG4gICAgICAgICAgICAgICAgICAgIGVsZW0udGFiSW5kZXggPSBlbGVtLnRhYkluZGV4IHx8IC0xXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2YXRlID0gXCJtb3VzZWRvd25cIlxuICAgICAgICAgICAgICAgICAgICBhYmFuZG9uID0gXCJtb3VzZXVwXCJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuMCA9ICRlbGVtLmJpbmQoXCJtb3VzZWxlYXZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRpbmcudG9nZ2xlQ2xhc3MgJiYgJGVsZW0ucmVtb3ZlQ2xhc3MoYmluZGluZy5uZXdDbGFzcylcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmbjEgPSAkZWxlbS5iaW5kKGFjdGl2YXRlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYmluZGluZy50b2dnbGVDbGFzcyAmJiAkZWxlbS5hZGRDbGFzcyhiaW5kaW5nLm5ld0NsYXNzKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHZhciBmbjIgPSAkZWxlbS5iaW5kKGFiYW5kb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nLnRvZ2dsZUNsYXNzICYmICRlbGVtLnJlbW92ZUNsYXNzKGJpbmRpbmcubmV3Q2xhc3MpXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgYmluZGluZy5yb2xsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAkZWxlbS51bmJpbmQoXCJtb3VzZWxlYXZlXCIsIGZuMClcbiAgICAgICAgICAgICAgICAkZWxlbS51bmJpbmQoYWN0aXZhdGUsIGZuMSlcbiAgICAgICAgICAgICAgICAkZWxlbS51bmJpbmQoYWJhbmRvbiwgZm4yKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmluZGluZy5oYXNCaW5kRXZlbnQgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VFeHByUHJveHkoYmluZGluZy5leHByLCB2bW9kZWxzLCBiaW5kaW5nKVxuICAgIH1cblxuICAgIGJpbmRpbmdFeGVjdXRvcnNbXCJjbGFzc1wiXSA9IGZ1bmN0aW9uIChhcnIsIGVsZW0sIGJpbmRpbmcpIHtcbiAgICAgICAgdmFyICRlbGVtID0gYXZhbG9uKGVsZW0pXG4gICAgICAgIGJpbmRpbmcubmV3Q2xhc3MgPSBhcnJbMF1cbiAgICAgICAgYmluZGluZy50b2dnbGVDbGFzcyA9ICEhYXJyWzFdXG4gICAgICAgIGlmIChiaW5kaW5nLm9sZENsYXNzICYmIGJpbmRpbmcubmV3Q2xhc3MgIT09IGJpbmRpbmcub2xkQ2xhc3MpIHtcbiAgICAgICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKGJpbmRpbmcub2xkQ2xhc3MpXG4gICAgICAgIH1cbiAgICAgICAgYmluZGluZy5vbGRDbGFzcyA9IGJpbmRpbmcubmV3Q2xhc3NcbiAgICAgICAgaWYgKGJpbmRpbmcudHlwZSA9PT0gXCJjbGFzc1wiKSB7XG4gICAgICAgICAgICBpZiAoYmluZGluZy5vbGRTdHlsZSkge1xuICAgICAgICAgICAgICAgICRlbGVtLnRvZ2dsZUNsYXNzKGJpbmRpbmcub2xkU3R5bGUsICEhYXJyWzFdKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkZWxlbS50b2dnbGVDbGFzcyhiaW5kaW5nLm5ld0NsYXNzLCBiaW5kaW5nLnRvZ2dsZUNsYXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBcImhvdmVyLGFjdGl2ZVwiLnJlcGxhY2UocndvcmQsIGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgYmluZGluZ0hhbmRsZXJzW21ldGhvZF0gPSBiaW5kaW5nSGFuZGxlcnNbXCJjbGFzc1wiXVxuICAgIH0pXG4vL21zLWNvbnRyb2xsZXLnu5Hlrprlt7Lnu4/lnKhzY2FuVGFnIOaWueazleS4reWunueOsFxuLy9tcy1jc3Pnu5Hlrprlt7LnlLFtcy1hdHRy57uR5a6a5a6e546wXG5cblxuLy8gYmluZGluZ0hhbmRsZXJzLmRhdGEg5a6a5LmJ5ZyoaWYuanNcbiAgICBiaW5kaW5nRXhlY3V0b3JzLmRhdGEgPSBmdW5jdGlvbih2YWwsIGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdmFyIGtleSA9IFwiZGF0YS1cIiArIGRhdGEucGFyYW1cbiAgICAgICAgaWYgKHZhbCAmJiB0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBlbGVtW2tleV0gPSB2YWxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGtleSwgU3RyaW5nKHZhbCkpXG4gICAgICAgIH1cbiAgICB9XG4vL+WPjOW3pee7keWumlxuICAgIHZhciBkdXBsZXhCaW5kaW5nID0gYmluZGluZ0hhbmRsZXJzLmR1cGxleCA9IGZ1bmN0aW9uKGRhdGEsIHZtb2RlbHMpIHtcbiAgICAgICAgdmFyIGVsZW0gPSBkYXRhLmVsZW1lbnQsXG4gICAgICAgICAgICBoYXNDYXN0XG4gICAgICAgIHBhcnNlRXhwclByb3h5KGRhdGEudmFsdWUsIHZtb2RlbHMsIGRhdGEsIDEpXG5cbiAgICAgICAgZGF0YS5jaGFuZ2VkID0gZ2V0QmluZGluZ0NhbGxiYWNrKGVsZW0sIFwiZGF0YS1kdXBsZXgtY2hhbmdlZFwiLCB2bW9kZWxzKSB8fCBub29wXG4gICAgICAgIGlmIChkYXRhLmV2YWx1YXRvciAmJiBkYXRhLmFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXVxuICAgICAgICAgICAgdmFyIGNhc3RpbmcgPSBvbmVPYmplY3QoXCJzdHJpbmcsbnVtYmVyLGJvb2xlYW4sY2hlY2tlZFwiKVxuICAgICAgICAgICAgaWYgKGVsZW0udHlwZSA9PT0gXCJyYWRpb1wiICYmIGRhdGEucGFyYW0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnBhcmFtID0gXCJjaGVja2VkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLm1zRGF0YSkge1xuICAgICAgICAgICAgICAgIGVsZW0ubXNEYXRhW1wibXMtZHVwbGV4XCJdID0gZGF0YS52YWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5wYXJhbS5yZXBsYWNlKC9cXHcrL2csIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoL14oY2hlY2tib3h8cmFkaW8pJC8udGVzdChlbGVtLnR5cGUpICYmIC9eKHJhZGlvfGNoZWNrZWQpJC8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJyYWRpb1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwibXMtZHVwbGV4LXJhZGlv5bey57uP5pu05ZCN5Li6bXMtZHVwbGV4LWNoZWNrZWRcIilcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiY2hlY2tlZFwiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuaXNDaGVja2VkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJib29sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiYm9vbGVhblwiXG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIm1zLWR1cGxleC1ib29s5bey57uP5pu05ZCN5Li6bXMtZHVwbGV4LWJvb2xlYW5cIilcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIm1zLWR1cGxleC10ZXh05bey57uP5pu05ZCN5Li6bXMtZHVwbGV4LXN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2FzdGluZ1tuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNDYXN0ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdmFsb24uQXJyYXkuZW5zdXJlKHBhcmFtcywgbmFtZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBpZiAoIWhhc0Nhc3QpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaChcInN0cmluZ1wiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5wYXJhbSA9IHBhcmFtcy5qb2luKFwiLVwiKVxuICAgICAgICAgICAgZGF0YS5ib3VuZCA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW0uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2ssIGZhbHNlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoXCJvblwiICsgdHlwZSwgY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBvbGQgPSBkYXRhLnJvbGxiYWNrXG4gICAgICAgICAgICAgICAgZGF0YS5yb2xsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtLmF2YWxvblNldHRlciA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgYXZhbG9uLnVuYmluZChlbGVtLCB0eXBlLCBjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgb2xkICYmIG9sZCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBhdmFsb24udm1vZGVscykge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gYXZhbG9uLnZtb2RlbHNbaV1cbiAgICAgICAgICAgICAgICB2LiRmaXJlKFwiYXZhbG9uLW1zLWR1cGxleC1pbml0XCIsIGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3BpcGUgPSBkYXRhLnBpcGUgfHwgKGRhdGEucGlwZSA9IHBpcGUpXG4gICAgICAgICAgICBjcGlwZShudWxsLCBkYXRhLCBcImluaXRcIilcbiAgICAgICAgICAgIHZhciB0YWdOYW1lID0gZWxlbS50YWdOYW1lXG4gICAgICAgICAgICBkdXBsZXhCaW5kaW5nW3RhZ05hbWVdICYmIGR1cGxleEJpbmRpbmdbdGFnTmFtZV0oZWxlbSwgZGF0YS5ldmFsdWF0b3IuYXBwbHkobnVsbCwgZGF0YS5hcmdzKSwgZGF0YSlcbiAgICAgICAgfVxuICAgIH1cbi8v5LiN5a2Y5ZyoIGJpbmRpbmdFeGVjdXRvcnMuZHVwbGV4XG5cbiAgICBmdW5jdGlvbiBmaXhOdWxsKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsID09IG51bGwgPyBcIlwiIDogdmFsXG4gICAgfVxuICAgIGF2YWxvbi5kdXBsZXhIb29rcyA9IHtcbiAgICAgICAgY2hlY2tlZDoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih2YWwsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWRhdGEuZWxlbWVudC5vbGRWYWx1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24odmFsKSB7IC8v5ZCM5q2l5YiwVk1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmaXhOdWxsXG4gICAgICAgIH0sXG4gICAgICAgIFwiYm9vbGVhblwiOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwgPT09IFwidHJ1ZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmaXhOdWxsXG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjoge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbih2YWwsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtYmVyID0gcGFyc2VGbG9hdCh2YWwpXG4gICAgICAgICAgICAgICAgaWYgKC12YWwgPT09IC1udW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJyID0gL3N0cm9uZ3xtZWRpdW18d2Vhay8uZXhlYyhkYXRhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1kdXBsZXgtbnVtYmVyXCIpKSB8fCBbXCJtZWRpdW1cIl1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGFyclswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3Ryb25nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMFxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsID09PSBcIlwiID8gXCJcIiA6IDBcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIndlYWtcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmaXhOdWxsXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwaXBlKHZhbCwgZGF0YSwgYWN0aW9uLCBlKSB7XG4gICAgICAgIGRhdGEucGFyYW0ucmVwbGFjZSgvXFx3Ky9nLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICB2YXIgaG9vayA9IGF2YWxvbi5kdXBsZXhIb29rc1tuYW1lXVxuICAgICAgICAgICAgaWYgKGhvb2sgJiYgdHlwZW9mIGhvb2tbYWN0aW9uXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gaG9va1thY3Rpb25dKHZhbCwgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHZhbFxuICAgIH1cblxuICAgIHZhciBUaW1lcklELCByaWJib24gPSBbXVxuXG4gICAgYXZhbG9uLnRpY2sgPSBmdW5jdGlvbihmbikge1xuICAgICAgICBpZiAocmliYm9uLnB1c2goZm4pID09PSAxKSB7XG4gICAgICAgICAgICBUaW1lcklEID0gc2V0SW50ZXJ2YWwodGlja2VyLCA2MClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRpY2tlcigpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IHJpYmJvbi5sZW5ndGggLSAxOyBuID49IDA7IG4tLSkge1xuICAgICAgICAgICAgdmFyIGVsID0gcmliYm9uW25dXG4gICAgICAgICAgICBpZiAoZWwoKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByaWJib24uc3BsaWNlKG4sIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyaWJib24ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKFRpbWVySUQpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgd2F0Y2hWYWx1ZUluVGltZXIgPSBub29wXG4gICAgbmV3IGZ1bmN0aW9uKCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgdHJ5IHsgLy8jMjcyIElFOS1JRTExLCBmaXJlZm94XG4gICAgICAgICAgICB2YXIgc2V0dGVycyA9IHt9XG4gICAgICAgICAgICB2YXIgYXByb3RvID0gSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGVcbiAgICAgICAgICAgIHZhciBicHJvdG8gPSBIVE1MVGV4dEFyZWFFbGVtZW50LnByb3RvdHlwZVxuICAgICAgICAgICAgZnVuY3Rpb24gbmV3U2V0dGVyKHZhbHVlKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgICAgICAgIHNldHRlcnNbdGhpcy50YWdOYW1lXS5jYWxsKHRoaXMsIHZhbHVlKVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5tc0ZvY3VzICYmIHRoaXMuYXZhbG9uU2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXZhbG9uU2V0dGVyKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5wdXRQcm90byA9IEhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlXG4gICAgICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbnB1dFByb3RvKSAvL+aVheaEj+W8leWPkUlFNi04562J5rWP6KeI5Zmo5oql6ZSZXG4gICAgICAgICAgICBzZXR0ZXJzW1wiSU5QVVRcIl0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFwcm90bywgXCJ2YWx1ZVwiKS5zZXRcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFwcm90bywgXCJ2YWx1ZVwiLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBuZXdTZXR0ZXJcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzZXR0ZXJzW1wiVEVYVEFSRUFcIl0gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJwcm90bywgXCJ2YWx1ZVwiKS5zZXRcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShicHJvdG8sIFwidmFsdWVcIiwge1xuICAgICAgICAgICAgICAgIHNldDogbmV3U2V0dGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvL+WcqGNocm9tZSA0M+S4rSBtcy1kdXBsZXjnu4jkuo7kuI3pnIDopoHkvb/nlKjlrprml7blmajlrp7njrDlj4zlkJHnu5HlrprkuoZcbiAgICAgICAgICAgIC8vIGh0dHA6Ly91cGRhdGVzLmh0bWw1cm9ja3MuY29tLzIwMTUvMDQvRE9NLWF0dHJpYnV0ZXMtbm93LW9uLXRoZS1wcm90b3R5cGVcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL2RvY3VtZW50L2QvMWp3QThtdENsd3hJLVFKdUhUNzg3MlowcHhwWno4UEJrZjJiR0Fic1V0cXMvZWRpdD9wbGk9MVxuICAgICAgICAgICAgd2F0Y2hWYWx1ZUluVGltZXIgPSBhdmFsb24udGlja1xuICAgICAgICB9XG4gICAgfSAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICBpZiAoSUVWZXJzaW9uKSB7XG4gICAgICAgIGF2YWxvbi5iaW5kKERPQywgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBlbCA9IERPQy5hY3RpdmVFbGVtZW50IHx8IHt9XG4gICAgICAgICAgICBpZiAoIWVsLm1zRm9jdXMgJiYgZWwuYXZhbG9uU2V0dGVyKSB7XG4gICAgICAgICAgICAgICAgZWwuYXZhbG9uU2V0dGVyKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gICAgdmFyIHJub2R1cGxleCA9IC9eKGZpbGV8YnV0dG9ufHJlc2V0fHN1Ym1pdHxjaGVja2JveHxyYWRpb3xyYW5nZSkkL1xuLy/lpITnkIZyYWRpbywgY2hlY2tib3gsIHRleHQsIHRleHRhcmVhLCBwYXNzd29yZFxuICAgIGR1cGxleEJpbmRpbmcuSU5QVVQgPSBmdW5jdGlvbiAoZWxlbSwgZXZhbHVhdG9yLCBkYXRhKSB7XG4gICAgICAgIHZhciAkdHlwZSA9IGVsZW0udHlwZSxcbiAgICAgICAgICAgIGJvdW5kID0gZGF0YS5ib3VuZCxcbiAgICAgICAgICAgICRlbGVtID0gYXZhbG9uKGVsZW0pLFxuICAgICAgICAgICAgY29tcG9zaW5nID0gZmFsc2VcblxuICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayh2YWx1ZSkge1xuICAgICAgICAgICAgZGF0YS5jaGFuZ2VkLmNhbGwodGhpcywgdmFsdWUsIGRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wb3NpdGlvblN0YXJ0KCkge1xuICAgICAgICAgICAgY29tcG9zaW5nID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcG9zaXRpb25FbmQoKSB7XG4gICAgICAgICAgICBjb21wb3NpbmcgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHZhciBJRTlWYWx1ZVxuICAgICAgICAvL+W9k3ZhbHVl5Y+Y5YyW5pe25pS55Y+YbW9kZWznmoTlgLxcbiAgICAgICAgdmFyIHVwZGF0ZVZNb2RlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBlbGVtLnZhbHVlIC8v6Ziy5q2i6YCS5b2S6LCD55So5b2i5oiQ5q275b6q546vXG4gICAgICAgICAgICBpZiAoY29tcG9zaW5nIHx8IHZhbCA9PT0gSUU5VmFsdWUpIC8v5aSE55CG5Lit5paH6L6T5YWl5rOV5ZyobWlubGVuZ2jkuIvlvJXlj5HnmoRCVUdcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIHZhciBsYXN0VmFsdWUgPSBkYXRhLnBpcGUodmFsLCBkYXRhLCBcImdldFwiKVxuICAgICAgICAgICAgaWYgKCRlbGVtLmRhdGEoXCJkdXBsZXhPYnNlcnZlXCIpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIElFOVZhbHVlID0gdmFsXG4gICAgICAgICAgICAgICAgZXZhbHVhdG9yKGxhc3RWYWx1ZSlcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGVsZW0sIGxhc3RWYWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL+W9k21vZGVs5Y+Y5YyW5pe2LOWug+WwseS8muaUueWPmHZhbHVl55qE5YC8XG4gICAgICAgIGRhdGEuaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhLnBpcGUoZXZhbHVhdG9yKCksIGRhdGEsIFwic2V0XCIpICAvL2ZpeCAjNjczICMxMTA2XG4gICAgICAgICAgICBpZiAodmFsICE9PSBJRTlWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBmaXhDYXJldCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYgKGVsZW0ubXNGb2N1cykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGdldENhcmV0KGVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zLnN0YXJ0ID09PSBwb3MuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zLnN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4Q2FyZXQgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtLnZhbHVlID0gSUU5VmFsdWUgPSB2YWxcbiAgICAgICAgICAgICAgICBpZiAoZml4Q2FyZXQgJiYgIWVsZW0ucmVhZHlPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldENhcmV0KGVsZW0sIHBvcywgcG9zKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5pc0NoZWNrZWQgfHwgJHR5cGUgPT09IFwicmFkaW9cIikge1xuICAgICAgICAgICAgdmFyIElFNiA9IElFVmVyc2lvbiA9PT0gNlxuICAgICAgICAgICAgdXBkYXRlVk1vZGVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICgkZWxlbS5kYXRhKFwiZHVwbGV4T2JzZXJ2ZVwiKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IGRhdGEucGlwZShlbGVtLnZhbHVlLCBkYXRhLCBcImdldFwiKVxuICAgICAgICAgICAgICAgICAgICBldmFsdWF0b3IobGFzdFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGVsZW0sIGxhc3RWYWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLmhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGV2YWx1YXRvcigpXG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrZWQgPSBkYXRhLmlzQ2hlY2tlZCA/ICEhdmFsIDogdmFsICsgXCJcIiA9PT0gZWxlbS52YWx1ZVxuICAgICAgICAgICAgICAgIGVsZW0ub2xkVmFsdWUgPSBjaGVja2VkXG4gICAgICAgICAgICAgICAgaWYgKElFNikge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSUU4IGNoZWNrYm94LCByYWRpb+aYr+S9v+eUqGRlZmF1bHRDaGVja2Vk5o6n5Yi26YCJ5Lit54q25oCB77yMXG4gICAgICAgICAgICAgICAgICAgICAgICAvL+W5tuS4lOimgeWFiOiuvue9rmRlZmF1bHRDaGVja2Vk5ZCO6K6+572uY2hlY2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy/lubbkuJTlv4Xpobvorr7nva7lu7bov59cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoZWNrZWQgPSBjaGVja2VkXG4gICAgICAgICAgICAgICAgICAgIH0sIDMxKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW0uY2hlY2tlZCA9IGNoZWNrZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3VuZChcImNsaWNrXCIsIHVwZGF0ZVZNb2RlbClcbiAgICAgICAgfSBlbHNlIGlmICgkdHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICAgICAgICB1cGRhdGVWTW9kZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCRlbGVtLmRhdGEoXCJkdXBsZXhPYnNlcnZlXCIpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gZWxlbS5jaGVja2VkID8gXCJlbnN1cmVcIiA6IFwicmVtb3ZlXCJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gZXZhbHVhdG9yKClcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nKFwibXMtZHVwbGV45bqU55So5LqOY2hlY2tib3jkuIropoHlr7nlupTkuIDkuKrmlbDnu4RcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5ID0gW2FycmF5XVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhLnBpcGUoZWxlbS52YWx1ZSwgZGF0YSwgXCJnZXRcIilcbiAgICAgICAgICAgICAgICAgICAgYXZhbG9uLkFycmF5W21ldGhvZF0oYXJyYXksIHZhbClcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChlbGVtLCBhcnJheSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEuaGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBbXS5jb25jYXQoZXZhbHVhdG9yKCkpIC8v5by65Yi26L2s5o2i5Li65pWw57uEXG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGRhdGEucGlwZShlbGVtLnZhbHVlLCBkYXRhLCBcImdldFwiKVxuICAgICAgICAgICAgICAgIGVsZW0uY2hlY2tlZCA9IGFycmF5LmluZGV4T2YodmFsKSA+IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBib3VuZChXM0MgPyBcImNoYW5nZVwiIDogXCJjbGlja1wiLCB1cGRhdGVWTW9kZWwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRzID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWR1cGxleC1ldmVudFwiKSB8fCBcImlucHV0XCJcbiAgICAgICAgICAgIGlmIChlbGVtLmF0dHJpYnV0ZXNbXCJkYXRhLWV2ZW50XCJdKSB7XG4gICAgICAgICAgICAgICAgbG9nKFwiZGF0YS1ldmVudOaMh+S7pOW3sue7j+W6n+W8g++8jOivt+aUueeUqGRhdGEtZHVwbGV4LWV2ZW50XCIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGRlbGF5KGUpIHsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZNb2RlbChlKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudHMucmVwbGFjZShyd29yZCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIUlFVmVyc2lvbikgeyAvLyBXM0NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZChcImlucHV0XCIsIHVwZGF0ZVZNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL+mdnklF5rWP6KeI5Zmo5omN55So6L+Z5LiqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQoXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGNvbXBvc2l0aW9uU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQoXCJjb21wb3NpdGlvbmVuZFwiLCBjb21wb3NpdGlvbkVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZChcIkRPTUF1dG9Db21wbGV0ZVwiLCB1cGRhdGVWTW9kZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElF5LiL6YCa6L+Hc2VsZWN0aW9uY2hhbmdl5LqL5Lu255uR5ZCsSUU5K+eCueWHu2lucHV05Y+z6L6555qEWOeahOa4heepuuihjOS4uu+8jOWPiueymOi0tO+8jOWJquWIh++8jOWIoOmZpOihjOS4ulxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChJRVZlcnNpb24gPiA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElFVmVyc2lvbiA9PT0gOSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lFOeWIoOmZpOWtl+espuWQjuWGjeWkseWOu+eEpueCueS4jeS8muWQjOatpSAjMTE2N1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQoXCJrZXl1cFwiLCB1cGRhdGVWTW9kZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JRTnkvb/nlKhwcm9wZXJ0eWNoYW5nZeaXoOazleebkeWQrOS4reaWh+i+k+WFpeaUueWKqFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZChcImlucHV0XCIsIHVwZGF0ZVZNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL29ucHJvcGVydHljaGFuZ2Xkuovku7bml6Dms5XljLrliIbmmK/nqIvluo/op6blj5Hov5jmmK/nlKjmiLfop6blj5FcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JRTYtOOS4i+esrOS4gOasoeS/ruaUueaXtuS4jeS8muinpuWPkSzpnIDopoHkvb/nlKhrZXlkb3du5oiWc2VsZWN0aW9uY2hhbmdl5L+u5q2jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kKFwicHJvcGVydHljaGFuZ2VcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnByb3BlcnR5TmFtZSA9PT0gXCJ2YWx1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVk1vZGVsKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm91bmQoXCJkcmFnZW5kXCIsIGRlbGF5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vaHR0cDovL3d3dy5jbmJsb2dzLmNvbS9ydWJ5bG91dnJlL2FyY2hpdmUvMjAxMy8wMi8xNy8yOTE0NjA0Lmh0bWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2h0dHA6Ly93d3cubWF0dHM0MTEuY29tL3Bvc3QvaW50ZXJuZXQtZXhwbG9yZXItOS1vbmlucHV0L1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kKG5hbWUsIHVwZGF0ZVZNb2RlbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuXG4gICAgICAgICAgICBpZiAoIXJub2R1cGxleC50ZXN0KGVsZW0udHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbS50eXBlICE9PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kKFwiZm9jdXNcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5tc0ZvY3VzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICBib3VuZChcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5tc0ZvY3VzID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbGVtLmF2YWxvblNldHRlciA9IHVwZGF0ZVZNb2RlbCAvLyM3NjVcbiAgICAgICAgICAgICAgICB3YXRjaFZhbHVlSW5UaW1lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb290LmNvbnRhaW5zKGVsZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVsZW0ubXNGb2N1cyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVWTW9kZWwoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFlbGVtLm1zUmV0YWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGF2YWxvbi5pbmplY3RCaW5kaW5nKGRhdGEpXG4gICAgICAgIGNhbGxiYWNrLmNhbGwoZWxlbSwgZWxlbS52YWx1ZSlcbiAgICB9XG4gICAgZHVwbGV4QmluZGluZy5URVhUQVJFQSA9IGR1cGxleEJpbmRpbmcuSU5QVVRcbiAgICBmdW5jdGlvbiBnZXRDYXJldChjdHJsKSB7XG4gICAgICAgIHZhciBzdGFydCA9IE5hTiwgZW5kID0gTmFOXG4gICAgICAgIC8vaHR0cHM6Ly9naXRodWIuY29tL1JvYmluSGVyYm90cy9qcXVlcnkuaW5wdXRtYXNrL2Jsb2IvMy54L2pzL2lucHV0bWFzay5qcyNMMTczNlxuICAgICAgICBpZiAoY3RybC5zZXRTZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICAgICAgc3RhcnQgPSBjdHJsLnNlbGVjdGlvblN0YXJ0XG4gICAgICAgICAgICBlbmQgPSBjdHJsLnNlbGVjdGlvbkVuZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKClcbiAgICAgICAgICAgIHN0YXJ0ID0gMCAtIHJhbmdlLmR1cGxpY2F0ZSgpLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLTEwMDAwMClcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0ICsgcmFuZ2UudGV4dC5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBlbmRcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRDYXJldChjdHJsLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIGlmICghY3RybC52YWx1ZSB8fCBjdHJsLnJlYWRPbmx5KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIGlmIChjdHJsLmNyZWF0ZVRleHRSYW5nZSkgey8vSUU2LThcbiAgICAgICAgICAgIHZhciByYW5nZSA9IGN0cmwuY3JlYXRlVGV4dFJhbmdlKClcbiAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpXG4gICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoXCJjaGFyYWN0ZXJcIiwgYmVnaW4pXG4gICAgICAgICAgICByYW5nZS5zZWxlY3QoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3RybC5zZWxlY3Rpb25TdGFydCA9IGJlZ2luXG4gICAgICAgICAgICBjdHJsLnNlbGVjdGlvbkVuZCA9IGVuZFxuICAgICAgICB9XG4gICAgfVxuICAgIGR1cGxleEJpbmRpbmcuU0VMRUNUID0gZnVuY3Rpb24oZWxlbWVudCwgZXZhbHVhdG9yLCBkYXRhKSB7XG4gICAgICAgIHZhciAkZWxlbSA9IGF2YWxvbihlbGVtZW50KVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVZNb2RlbCgpIHtcbiAgICAgICAgICAgIGlmICgkZWxlbS5kYXRhKFwiZHVwbGV4T2JzZXJ2ZVwiKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gJGVsZW0udmFsKCkgLy/lrZfnrKbkuLLmiJblrZfnrKbkuLLmlbDnu4RcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEucGlwZSh2LCBkYXRhLCBcImdldFwiKVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbCA9IGRhdGEucGlwZSh2YWwsIGRhdGEsIFwiZ2V0XCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWwgKyBcIlwiICE9PSBlbGVtZW50Lm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2YWx1YXRvcih2YWwpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRhdGEuY2hhbmdlZC5jYWxsKGVsZW1lbnQsIHZhbCwgZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhLmhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBldmFsdWF0b3IoKVxuICAgICAgICAgICAgdmFsID0gdmFsICYmIHZhbC4kbW9kZWwgfHwgdmFsXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50Lm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIm1zLWR1cGxleOWcqDxzZWxlY3QgbXVsdGlwbGU9dHJ1ZT7kuIropoHmsYLlr7nlupTkuIDkuKrmlbDnu4RcIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm11bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZyhcIm1zLWR1cGxleOWcqDxzZWxlY3QgbXVsdGlwbGU9ZmFsc2U+5LiN6IO95a+55bqU5LiA5Liq5pWw57uEXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy/lv4Xpobvlj5jmiJDlrZfnrKbkuLLlkI7miY3og73mr5TovoNcbiAgICAgICAgICAgIHZhbCA9IEFycmF5LmlzQXJyYXkodmFsKSA/IHZhbC5tYXAoU3RyaW5nKSA6IHZhbCArIFwiXCJcbiAgICAgICAgICAgIGlmICh2YWwgKyBcIlwiICE9PSBlbGVtZW50Lm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgJGVsZW0udmFsKHZhbClcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9sZFZhbHVlID0gdmFsICsgXCJcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRhdGEuYm91bmQoXCJjaGFuZ2VcIiwgdXBkYXRlVk1vZGVsKVxuICAgICAgICBlbGVtZW50Lm1zQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGF2YWxvbi5pbmplY3RCaW5kaW5nKGRhdGEpXG4gICAgICAgICAgICBkYXRhLmNoYW5nZWQuY2FsbChlbGVtZW50LCBldmFsdWF0b3IoKSwgZGF0YSlcbiAgICAgICAgfVxuICAgIH1cbi8vIGJpbmRpbmdIYW5kbGVycy5odG1sIOWumuS5ieWcqGlmLmpzXG4gICAgYmluZGluZ0V4ZWN1dG9ycy5odG1sID0gZnVuY3Rpb24gKHZhbCwgZWxlbSwgZGF0YSkge1xuICAgICAgICB2YXIgaXNIdG1sRmlsdGVyID0gZWxlbS5ub2RlVHlwZSAhPT0gMVxuICAgICAgICB2YXIgcGFyZW50ID0gaXNIdG1sRmlsdGVyID8gZWxlbS5wYXJlbnROb2RlIDogZWxlbVxuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB2YWwgPSB2YWwgPT0gbnVsbCA/IFwiXCIgOiB2YWxcbiAgICAgICAgaWYgKGRhdGEub2xkVGV4dCAhPT0gdmFsKSB7XG4gICAgICAgICAgICBkYXRhLm9sZFRleHQgPSB2YWxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gZ2VuZXJhdGVJRChcImh0bWxcIilcbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoRE9DLmNyZWF0ZUNvbW1lbnQoc2lnbmF0dXJlKSwgZWxlbSlcbiAgICAgICAgICAgIGRhdGEuZWxlbWVudCA9IERPQy5jcmVhdGVDb21tZW50KHNpZ25hdHVyZSArIFwiOmVuZFwiKVxuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChkYXRhLmVsZW1lbnQsIGVsZW0pXG4gICAgICAgICAgICBlbGVtID0gZGF0YS5lbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgIT09IFwib2JqZWN0XCIpIHsvL3N0cmluZywgbnVtYmVyLCBib29sZWFuXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBhdmFsb24ucGFyc2VIVE1MKFN0cmluZyh2YWwpKVxuICAgICAgICB9IGVsc2UgaWYgKHZhbC5ub2RlVHlwZSA9PT0gMTEpIHsgLy/lsIZ2YWzovazmjaLkuLrmlofmoaPnoo7niYdcbiAgICAgICAgICAgIGZyYWdtZW50ID0gdmFsXG4gICAgICAgIH0gZWxzZSBpZiAodmFsLm5vZGVUeXBlID09PSAxIHx8IHZhbC5pdGVtKSB7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB2YWwubm9kZVR5cGUgPT09IDEgPyB2YWwuY2hpbGROb2RlcyA6IHZhbC5pdGVtXG4gICAgICAgICAgICBmcmFnbWVudCA9IGF2YWxvbkZyYWdtZW50LmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgICAgd2hpbGUgKG5vZGVzWzBdKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZXNbMF0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBub2RlcyA9IGF2YWxvbi5zbGljZShmcmFnbWVudC5jaGlsZE5vZGVzKVxuICAgICAgICAvL+aPkuWFpeWNoOS9jeespiwg5aaC5p6c5piv6L+H5ruk5ZmoLOmcgOimgeacieiKguWItuWcsOenu+mZpOaMh+WumueahOaVsOmHjyzlpoLmnpzmmK9odG1s5oyH5LukLOebtOaOpea4heepulxuICAgICAgICBpZiAoaXNIdG1sRmlsdGVyKSB7XG4gICAgICAgICAgICB2YXIgZW5kVmFsdWUgPSBlbGVtLm5vZGVWYWx1ZS5zbGljZSgwLCAtNClcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBlbGVtLnByZXZpb3VzU2libGluZ1xuICAgICAgICAgICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09PSA4ICYmIG5vZGUubm9kZVZhbHVlID09PSBlbmRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChub2RlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIGVsZW0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdmFsb24uY2xlYXJIVE1MKGVsZW0pLmFwcGVuZENoaWxkKGZyYWdtZW50KVxuICAgICAgICB9XG4gICAgICAgIHNjYW5Ob2RlQXJyYXkobm9kZXMsIGRhdGEudm1vZGVscylcbiAgICB9XG4gICAgYmluZGluZ0hhbmRsZXJzW1wiaWZcIl0gPVxuICAgICAgICBiaW5kaW5nSGFuZGxlcnMuZGF0YSA9XG4gICAgICAgICAgICBiaW5kaW5nSGFuZGxlcnMudGV4dCA9XG4gICAgICAgICAgICAgICAgYmluZGluZ0hhbmRsZXJzLmh0bWwgPVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihkYXRhLCB2bW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUV4cHJQcm94eShkYXRhLnZhbHVlLCB2bW9kZWxzLCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICBiaW5kaW5nRXhlY3V0b3JzW1wiaWZcIl0gPSBmdW5jdGlvbih2YWwsIGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmKCFlbGVtLnBhcmVudE5vZGUpIHJldHVyblxuICAgICAgICB9IGNhdGNoKGUpIHtyZXR1cm59XG4gICAgICAgIGlmICh2YWwpIHsgLy/mj5Llm55ET03moJFcbiAgICAgICAgICAgIGlmIChlbGVtLm5vZGVUeXBlID09PSA4KSB7XG4gICAgICAgICAgICAgICAgZWxlbS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChkYXRhLnRlbXBsYXRlLCBlbGVtKVxuICAgICAgICAgICAgICAgIGVsZW0uaWZSZW1vdmUgPSBudWxsXG4gICAgICAgICAgICAgICAgLy8gICBhbmltYXRlLmVudGVyKGRhdGEudGVtcGxhdGUsIGVsZW0ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICBlbGVtID0gZGF0YS5lbGVtZW50ID0gZGF0YS50ZW1wbGF0ZSAvL+i/meaXtuWPr+iDveS4um51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbGVtLmdldEF0dHJpYnV0ZShkYXRhLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoZGF0YS5uYW1lKVxuICAgICAgICAgICAgICAgIHNjYW5BdHRyKGVsZW0sIGRhdGEudm1vZGVscylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucm9sbGJhY2sgPSBudWxsXG4gICAgICAgIH0gZWxzZSB7IC8v56e75Ye6RE9N5qCR77yM5bm255So5rOo6YeK6IqC54K55Y2g5o2u5Y6f5L2N572uXG4gICAgICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gZGF0YS5lbGVtZW50ID0gRE9DLmNyZWF0ZUNvbW1lbnQoXCJtcy1pZlwiKVxuICAgICAgICAgICAgICAgIGVsZW0ucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgZWxlbSlcbiAgICAgICAgICAgICAgICBlbGVtLmlmUmVtb3ZlID0gbm9kZVxuICAgICAgICAgICAgICAgIC8vICAgICBhbmltYXRlLmxlYXZlKGVsZW0sIG5vZGUucGFyZW50Tm9kZSwgbm9kZSlcbiAgICAgICAgICAgICAgICBkYXRhLnRlbXBsYXRlID0gZWxlbSAvL+WFg+e0oOiKgueCuVxuICAgICAgICAgICAgICAgIGlmR3JvdXAuYXBwZW5kQ2hpbGQoZWxlbSlcbiAgICAgICAgICAgICAgICBkYXRhLnJvbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtLnBhcmVudE5vZGUgPT09IGlmR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmR3JvdXAucmVtb3ZlQ2hpbGQoZWxlbSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbi8vbXMtaW1wb3J0YW5057uR5a6a5bey57uP5Zyoc2NhblRhZyDmlrnms5XkuK3lrp7njrBcbi8vbXMtaW5jbHVkZee7keWumuW3sueUsW1zLWF0dHLnu5Hlrprlrp7njrBcblxuICAgIHZhciByZGFzaCA9IC9cXCgoW14pXSopXFwpL1xuICAgIGJpbmRpbmdIYW5kbGVycy5vbiA9IGZ1bmN0aW9uKGRhdGEsIHZtb2RlbHMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZGF0YS52YWx1ZVxuICAgICAgICBkYXRhLnR5cGUgPSBcIm9uXCJcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGRhdGEucGFyYW0ucmVwbGFjZSgvLVxcZCskLywgXCJcIikgLy8gbXMtb24tbW91c2Vtb3ZlLTEwXG4gICAgICAgIGlmICh0eXBlb2YgYmluZGluZ0hhbmRsZXJzLm9uW2V2ZW50VHlwZSArIFwiSG9va1wiXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBiaW5kaW5nSGFuZGxlcnMub25bZXZlbnRUeXBlICsgXCJIb29rXCJdKGRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoXCIoXCIpID4gMCAmJiB2YWx1ZS5pbmRleE9mKFwiKVwiKSA+IC0xKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlZCA9ICh2YWx1ZS5tYXRjaChyZGFzaCkgfHwgW1wiXCIsIFwiXCJdKVsxXS50cmltKClcbiAgICAgICAgICAgIGlmIChtYXRjaGVkID09PSBcIlwiIHx8IG1hdGNoZWQgPT09IFwiJGV2ZW50XCIpIHsgLy8gYWFhKCkgYWFhKCRldmVudCnlvZPmiJBhYWHlpITnkIZcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmRhc2gsIFwiXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VFeHByUHJveHkodmFsdWUsIHZtb2RlbHMsIGRhdGEpXG4gICAgfVxuXG4gICAgYmluZGluZ0V4ZWN1dG9ycy5vbiA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtLCBkYXRhKSB7XG4gICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIGZuID0gZGF0YS5ldmFsdWF0b3IgfHwgbm9vcFxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGRhdGEuYXJncy5jb25jYXQoZSkpXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IGRhdGEucGFyYW0ucmVwbGFjZSgvLVxcZCskLywgXCJcIikgLy8gbXMtb24tbW91c2Vtb3ZlLTEwXG4gICAgICAgIGlmIChldmVudFR5cGUgPT09IFwic2NhblwiKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKGVsZW0sIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBldmVudFR5cGVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRhdGEuc3BlY2lhbEJpbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGF0YS5zcGVjaWFsQmluZChlbGVtLCBjYWxsYmFjaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZW1vdmVGbiA9IGF2YWxvbi5iaW5kKGVsZW0sIGV2ZW50VHlwZSwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5yb2xsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhLnNwZWNpYWxVbmJpbmQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGRhdGEuc3BlY2lhbFVuYmluZCgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF2YWxvbi51bmJpbmQoZWxlbSwgZXZlbnRUeXBlLCByZW1vdmVGbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kaW5nSGFuZGxlcnMucmVwZWF0ID0gZnVuY3Rpb24gKGRhdGEsIHZtb2RlbHMpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBkYXRhLnR5cGVcbiAgICAgICAgcGFyc2VFeHByUHJveHkoZGF0YS52YWx1ZSwgdm1vZGVscywgZGF0YSwgMSlcbiAgICAgICAgZGF0YS5wcm94aWVzID0gW11cbiAgICAgICAgdmFyIGZyZXR1cm4gPSBmYWxzZVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyICRyZXBlYXQgPSBkYXRhLiRyZXBlYXQgPSBkYXRhLmV2YWx1YXRvci5hcHBseSgwLCBkYXRhLmFyZ3MgfHwgW10pXG4gICAgICAgICAgICB2YXIgeHR5cGUgPSBhdmFsb24udHlwZSgkcmVwZWF0KVxuICAgICAgICAgICAgaWYgKHh0eXBlICE9PSBcIm9iamVjdFwiICYmIHh0eXBlICE9PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICBmcmV0dXJuID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGF2YWxvbi5sb2coXCJ3YXJuaW5nOlwiICsgZGF0YS52YWx1ZSArIFwi5Y+q6IO95piv5a+56LGh5oiW5pWw57uEXCIpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEueHR5cGUgPSB4dHlwZVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBmcmV0dXJuID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHZhciBhcnIgPSBkYXRhLnZhbHVlLnNwbGl0KFwiLlwiKSB8fCBbXVxuICAgICAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGFyci5wb3AoKVxuICAgICAgICAgICAgdmFyIG4gPSBhcnJbMF1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCB2OyB2ID0gdm1vZGVsc1tpKytdOyApIHtcbiAgICAgICAgICAgICAgICBpZiAodiAmJiB2Lmhhc093blByb3BlcnR5KG4pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB2W25dLiRldmVudHMgfHwge31cbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzW3N1YnNjcmliZXJzXSA9IGV2ZW50c1tzdWJzY3JpYmVyc10gfHwgW11cbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzW3N1YnNjcmliZXJzXS5wdXNoKGRhdGEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZEhhbmRsZXIgPSBkYXRhLmhhbmRsZXJcbiAgICAgICAgZGF0YS5oYW5kbGVyID0gbm9vcFxuICAgICAgICBhdmFsb24uaW5qZWN0QmluZGluZyhkYXRhKVxuICAgICAgICBkYXRhLmhhbmRsZXIgPSBvbGRIYW5kbGVyXG5cbiAgICAgICAgdmFyIGVsZW0gPSBkYXRhLmVsZW1lbnRcbiAgICAgICAgaWYgKGVsZW0ubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGRhdGEubmFtZSlcbiAgICAgICAgICAgIGRhdGEuc29ydGVkQ2FsbGJhY2sgPSBnZXRCaW5kaW5nQ2FsbGJhY2soZWxlbSwgXCJkYXRhLXdpdGgtc29ydGVkXCIsIHZtb2RlbHMpXG4gICAgICAgICAgICBkYXRhLnJlbmRlcmVkQ2FsbGJhY2sgPSBnZXRCaW5kaW5nQ2FsbGJhY2soZWxlbSwgXCJkYXRhLVwiICsgdHlwZSArIFwiLXJlbmRlcmVkXCIsIHZtb2RlbHMpXG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gZ2VuZXJhdGVJRCh0eXBlKVxuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gRE9DLmNyZWF0ZUNvbW1lbnQoc2lnbmF0dXJlKVxuICAgICAgICAgICAgdmFyIGVuZCA9IERPQy5jcmVhdGVDb21tZW50KHNpZ25hdHVyZSArIFwiOmVuZFwiKVxuICAgICAgICAgICAgZGF0YS5zaWduYXR1cmUgPSBzaWduYXR1cmVcbiAgICAgICAgICAgIGRhdGEudGVtcGxhdGUgPSBhdmFsb25GcmFnbWVudC5jbG9uZU5vZGUoZmFsc2UpXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJyZXBlYXRcIikge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGVcbiAgICAgICAgICAgICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKGVuZCwgZWxlbSlcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgICAgICAgZGF0YS50ZW1wbGF0ZS5hcHBlbmRDaGlsZChlbGVtKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWxlbS5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEudGVtcGxhdGUuYXBwZW5kQ2hpbGQoZWxlbS5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtLmFwcGVuZENoaWxkKHN0YXJ0KVxuICAgICAgICAgICAgICAgIGVsZW0uYXBwZW5kQ2hpbGQoZW5kKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YS5lbGVtZW50ID0gZW5kXG4gICAgICAgICAgICBkYXRhLmhhbmRsZXIgPSBiaW5kaW5nRXhlY3V0b3JzLnJlcGVhdFxuICAgICAgICAgICAgZGF0YS5yb2xsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbSA9IGRhdGEuZWxlbWVudFxuICAgICAgICAgICAgICAgIGlmICghZWxlbSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgZGF0YS5oYW5kbGVyKFwiY2xlYXJcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmV0dXJuKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEuJG91dGVyID0ge31cbiAgICAgICAgdmFyIGNoZWNrMCA9IFwiJGtleVwiXG4gICAgICAgIHZhciBjaGVjazEgPSBcIiR2YWxcIlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSgkcmVwZWF0KSkge1xuICAgICAgICAgICAgY2hlY2swID0gXCIkZmlyc3RcIlxuICAgICAgICAgICAgY2hlY2sxID0gXCIkbGFzdFwiXG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyB2ID0gdm1vZGVsc1tpKytdOyApIHtcbiAgICAgICAgICAgIGlmICh2Lmhhc093blByb3BlcnR5KGNoZWNrMCkgJiYgdi5oYXNPd25Qcm9wZXJ0eShjaGVjazEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS4kb3V0ZXIgPSB2XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgJGV2ZW50cyA9ICRyZXBlYXQuJGV2ZW50c1xuICAgICAgICB2YXIgJGxpc3QgPSAoJGV2ZW50cyB8fCB7fSlbc3Vic2NyaWJlcnNdXG4gICAgICAgIGluamVjdERlcGVuZGVuY3koJGxpc3QsIGRhdGEpXG4gICAgICAgIGlmICh4dHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgZGF0YS5oYW5kbGVyKFwiYXBwZW5kXCIpXG4gICAgICAgIH0gZWxzZSBpZiAoJHJlcGVhdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGEuaGFuZGxlcihcImFkZFwiLCAwLCAkcmVwZWF0Lmxlbmd0aClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJpbmRpbmdFeGVjdXRvcnMucmVwZWF0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcG9zLCBlbCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXNcbiAgICAgICAgaWYgKCFtZXRob2QgJiYgZGF0YS54dHlwZSkge1xuICAgICAgICAgICAgdmFyIG9sZCA9IGRhdGEuJHJlcGVhdFxuICAgICAgICAgICAgdmFyIG5lbyA9IGRhdGEuZXZhbHVhdG9yLmFwcGx5KDAsIGRhdGEuYXJncyB8fCBbXSlcblxuICAgICAgICAgICAgaWYgKGRhdGEueHR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgIGlmIChvbGQubGVuZ3RoID09PSBuZW8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvbGQgIT09IG5lbyAmJiBvbGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ0V4ZWN1dG9ycy5yZXBlYXQuY2FsbCh0aGlzLCAnY2xlYXInLCBwb3MsIGVsKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJhZGRcIlxuICAgICAgICAgICAgICAgIHBvcyA9IDBcbiAgICAgICAgICAgICAgICBkYXRhLiRyZXBlYXQgPSBuZW9cbiAgICAgICAgICAgICAgICBlbCA9IG5lby5sZW5ndGhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleXNWTShvbGQpLmpvaW4oXCI7O1wiKSA9PT0ga2V5c1ZNKG5lbykuam9pbihcIjs7XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSBcImFwcGVuZFwiXG4gICAgICAgICAgICAgICAgZGF0YS4kcmVwZWF0ID0gbmVvXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0LCBmcmFnbWVudFxuICAgICAgICAgICAgdmFyIGVuZCA9IGRhdGEuZWxlbWVudFxuICAgICAgICAgICAgdmFyIGNvbW1lbnRzID0gZ2V0Q29tbWVudHMoZGF0YSlcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBlbmQucGFyZW50Tm9kZVxuICAgICAgICAgICAgdmFyIHByb3hpZXMgPSBkYXRhLnByb3hpZXNcbiAgICAgICAgICAgIHZhciB0cmFuc2F0aW9uID0gYXZhbG9uRnJhZ21lbnQuY2xvbmVOb2RlKGZhbHNlKVxuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYWRkXCI6IC8v5ZyocG9z5L2N572u5ZCO5re75YqgZWzmlbDnu4TvvIhwb3PkuLrmj5LlhaXkvY3nva4sZWzkuLropoHmj5LlhaXnmoTkuKrmlbDvvIlcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBwb3MgKyBlbFxuICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnRzID0gW11cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3h5ID0gZWFjaFByb3h5QWdlbnQoaSwgZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3hpZXMuc3BsaWNlKGksIDAsIHByb3h5KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hpbUNvbnRyb2xsZXIoZGF0YSwgdHJhbnNhdGlvbiwgcHJveHksIGZyYWdtZW50cylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRyYW5zYXRpb24sIGNvbW1lbnRzW3Bvc10gfHwgZW5kKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBmcmFnbWVudCA9IGZyYWdtZW50c1tpKytdOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW5Ob2RlQXJyYXkoZnJhZ21lbnQubm9kZXMsIGZyYWdtZW50LnZtb2RlbHMpXG4gICAgICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5ub2RlcyA9IGZyYWdtZW50LnZtb2RlbHMgPSBudWxsXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkZWxcIjogLy/lsIZwb3PlkI7nmoRlbOS4quWFg+e0oOWIoOaOiShwb3MsIGVs6YO95piv5pWw5a2XKVxuICAgICAgICAgICAgICAgICAgICBzd2VlcE5vZGVzKGNvbW1lbnRzW3Bvc10sIGNvbW1lbnRzW3BvcyArIGVsXSB8fCBlbmQpXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVkID0gcHJveGllcy5zcGxpY2UocG9zLCBlbClcbiAgICAgICAgICAgICAgICAgICAgcmVjeWNsZVByb3hpZXMocmVtb3ZlZCwgXCJlYWNoXCIpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcImNsZWFyXCI6XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gY29tbWVudHNbMF1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2VlcE5vZGVzKHN0YXJ0LCBlbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS54dHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoc3RhcnQsIGVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3ljbGVQcm94aWVzKHByb3hpZXMsIFwiZWFjaFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1vdmVcIjpcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBjb21tZW50c1swXVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBzdGFydC5ub2RlVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb29tcyA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vbSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3ZWVwTm9kZXMoc3RhcnQsIGVuZCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb20udW5zaGlmdCh0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm5vZGVWYWx1ZSA9PT0gc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb21zLnVuc2hpZnQocm9vbSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vbSA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRCeUluZGV4KHJvb21zLCBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0QnlJbmRleChwcm94aWVzLCBwb3MpXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocm9vbSA9IHJvb21zLnNoaWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSA9IHJvb20uc2hpZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2F0aW9uLmFwcGVuZENoaWxkKG5vZGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0cmFuc2F0aW9uLCBlbmQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5kZXhcIjogLy/lsIZwcm94aWVz5Lit55qE56yscG9z5Liq6LW355qE5omA5pyJ5YWD57Sg6YeN5paw57Si5byVXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gcHJveGllcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBlbCA9IHByb3hpZXNbcG9zXTsgcG9zKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLiRpbmRleCA9IHBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwuJGZpcnN0ID0gcG9zID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBlbC4kbGFzdCA9IHBvcyA9PT0gbGFzdFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIGNhc2UgXCJzZXRcIjogLy/lsIZwcm94aWVz5Lit55qE56yscG9z5Liq5YWD57Sg55qEVk3orr7nva7kuLplbO+8iHBvc+S4uuaVsOWtl++8jGVs5Lu75oSP77yJXG4gICAgICAgICAgICAgICAgICAgIHByb3h5ID0gcHJveGllc1twb3NdXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm94eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyZURlcGVuZGVuY2llcyhwcm94eS4kZXZlbnRzW2RhdGEucGFyYW0gfHwgXCJlbFwiXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhcHBlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9iamVjdCA9IGRhdGEuJHJlcGVhdCAvL+WOn+adpeesrDLlj4LmlbDvvIwg6KKr5b6q546v5a+56LGhXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb29sID0gQXJyYXkuaXNBcnJheShwcm94aWVzKSB8fCFwcm94aWVzID8gIHt9OiBwcm94aWVzICAgLy/ku6PnkIblr7nosaHnu4TmiJDnmoRoYXNoXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJveGllcyA9IHBvb2xcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBbXVxuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHMgPSBbXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcG9vbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5UmVjeWNsZXIocG9vbFtrZXldLCB3aXRoUHJveHlQb29sKSAvL+WOu+aOieS5i+WJjeeahOS7o+eQhlZNXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlKHBvb2xba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGtleSBpbiBvYmplY3QpIHsgLy/lvpfliLDmiYDmnInplK7lkI1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09IFwiaGFzT3duUHJvcGVydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuc29ydGVkQ2FsbGJhY2spIHsgLy/lpoLmnpzmnInlm57osIPvvIzliJnorqnlroPku6zmjpLluo9cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzMiA9IGRhdGEuc29ydGVkQ2FsbGJhY2suY2FsbChwYXJlbnQsIGtleXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5czIgJiYgQXJyYXkuaXNBcnJheShrZXlzMikgJiYga2V5czIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5cyA9IGtleXMyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsga2V5ID0ga2V5c1tpKytdOyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IFwiaGFzT3duUHJvcGVydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvb2xba2V5XSA9IHdpdGhQcm94eUFnZW50KHBvb2xba2V5XSwga2V5LCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoaW1Db250cm9sbGVyKGRhdGEsIHRyYW5zYXRpb24sIHBvb2xba2V5XSwgZnJhZ21lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZSh0cmFuc2F0aW9uLCBlbmQpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGZyYWdtZW50ID0gZnJhZ21lbnRzW2krK107ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbk5vZGVBcnJheShmcmFnbWVudC5ub2RlcywgZnJhZ21lbnQudm1vZGVscylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50Lm5vZGVzID0gZnJhZ21lbnQudm1vZGVscyA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhLiRyZXBlYXQgfHwgZGF0YS4kcmVwZWF0Lmhhc093blByb3BlcnR5KFwiJGxvY2tcIikpIC8vSUU2LTggVkJTY3JpcHTlr7nosaHkvJrmiqXplJksIOacieaXtuWAmWRhdGEuJHJlcGVhdOS4jeWtmOWcqFxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjbGVhclwiKVxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IFwiZGVsXCJcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGRhdGEucmVuZGVyZWRDYWxsYmFjayB8fCBub29wLFxuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHNcbiAgICAgICAgICAgIGlmIChwYXJlbnQub2xkVmFsdWUgJiYgcGFyZW50LnRhZ05hbWUgPT09IFwiU0VMRUNUXCIpIHsgLy9maXggIzUwM1xuICAgICAgICAgICAgICAgIGF2YWxvbihwYXJlbnQpLnZhbChwYXJlbnQub2xkVmFsdWUuc3BsaXQoXCIsXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkocGFyZW50LCBhcmdzKVxuICAgICAgICB9XG4gICAgfVxuICAgIFwid2l0aCxlYWNoXCIucmVwbGFjZShyd29yZCwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgYmluZGluZ0hhbmRsZXJzW25hbWVdID0gYmluZGluZ0hhbmRsZXJzLnJlcGVhdFxuICAgIH0pXG5cbiAgICBmdW5jdGlvbiBzaGltQ29udHJvbGxlcihkYXRhLCB0cmFuc2F0aW9uLCBwcm94eSwgZnJhZ21lbnRzKSB7XG4gICAgICAgIHZhciBjb250ZW50ID0gZGF0YS50ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgdmFyIG5vZGVzID0gYXZhbG9uLnNsaWNlKGNvbnRlbnQuY2hpbGROb2RlcylcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUoRE9DLmNyZWF0ZUNvbW1lbnQoZGF0YS5zaWduYXR1cmUpLCBjb250ZW50LmZpcnN0Q2hpbGQpXG4gICAgICAgIHRyYW5zYXRpb24uYXBwZW5kQ2hpbGQoY29udGVudClcbiAgICAgICAgdmFyIG52ID0gW3Byb3h5XS5jb25jYXQoZGF0YS52bW9kZWxzKVxuICAgICAgICB2YXIgZnJhZ21lbnQgPSB7XG4gICAgICAgICAgICBub2Rlczogbm9kZXMsXG4gICAgICAgICAgICB2bW9kZWxzOiBudlxuICAgICAgICB9XG4gICAgICAgIGZyYWdtZW50cy5wdXNoKGZyYWdtZW50KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENvbW1lbnRzKGRhdGEpIHtcbiAgICAgICAgdmFyIHJldCA9IFtdXG4gICAgICAgIHZhciBub2RlcyA9IGRhdGEuZWxlbWVudC5wYXJlbnROb2RlLmNoaWxkTm9kZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5vZGU7IG5vZGUgPSBub2Rlc1tpKytdOyApIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVWYWx1ZSA9PT0gZGF0YS5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChub2RlKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLm5vZGVWYWx1ZSA9PT0gZGF0YS5zaWduYXR1cmUgKyBcIjplbmRcIikge1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldFxuICAgIH1cblxuXG4vL+enu+mZpOaOiXN0YXJ05LiOZW5k5LmL6Ze055qE6IqC54K5KOS/neeVmWVuZClcbiAgICBmdW5jdGlvbiBzd2VlcE5vZGVzKHN0YXJ0LCBlbmQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGVuZC5wcmV2aW91c1NpYmxpbmdcbiAgICAgICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpXG4gICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKG5vZGUpXG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4vLyDkuLptcy1lYWNoLG1zLXdpdGgsIG1zLXJlcGVhdOS8muWIm+W7uuS4gOS4quS7o+eQhlZN77yMXG4vLyDpgJrov4flroPku6zkv53mjIHkuIDkuKrkuIvkuIrmlofvvIzorqnnlKjmiLfog73osIPnlKgkaW5kZXgsJGZpcnN0LCRsYXN0LCRyZW1vdmUsJGtleSwkdmFsLCRvdXRlcuetieWxnuaAp+S4juaWueazlVxuLy8g5omA5pyJ5Luj55CGVk3nmoTkuqfnlJ8s5raI6LS5LOaUtumbhizlrZjmlL7pgJrov4d4eHhQcm94eUZhY3RvcnkseHh4UHJveHlBZ2VudCwgcmVjeWNsZVByb3hpZXMseHh4UHJveHlQb29s5a6e546wXG4gICAgdmFyIHdpdGhQcm94eVBvb2wgPSBbXVxuICAgIGZ1bmN0aW9uIHdpdGhQcm94eUZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBwcm94eSA9IG1vZGVsRmFjdG9yeSh7XG4gICAgICAgICAgICAka2V5OiBcIlwiLFxuICAgICAgICAgICAgJG91dGVyOiB7fSxcbiAgICAgICAgICAgICRob3N0OiB7fSxcbiAgICAgICAgICAgICR2YWw6IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGhvc3RbdGhpcy4ka2V5XVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGhvc3RbdGhpcy4ka2V5XSA9IHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgJHZhbDogMVxuICAgICAgICB9KVxuICAgICAgICBwcm94eS4kaWQgPSBnZW5lcmF0ZUlEKFwiJHByb3h5JHdpdGhcIilcbiAgICAgICAgcmV0dXJuIHByb3h5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2l0aFByb3h5QWdlbnQocHJveHksIGtleSwgZGF0YSkge1xuICAgICAgICBwcm94eSA9IHByb3h5IHx8IHdpdGhQcm94eVBvb2wucG9wKClcbiAgICAgICAgaWYgKCFwcm94eSkge1xuICAgICAgICAgICAgcHJveHkgPSB3aXRoUHJveHlGYWN0b3J5KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3h5LiRyZWluaXRpYWxpemUoKVxuICAgICAgICB9XG4gICAgICAgIHZhciBob3N0ID0gZGF0YS4kcmVwZWF0XG4gICAgICAgIHByb3h5LiRrZXkgPSBrZXlcblxuICAgICAgICBwcm94eS4kaG9zdCA9IGhvc3RcbiAgICAgICAgcHJveHkuJG91dGVyID0gZGF0YS4kb3V0ZXJcbiAgICAgICAgaWYgKGhvc3QuJGV2ZW50cykge1xuICAgICAgICAgICAgcHJveHkuJGV2ZW50cy4kdmFsID0gaG9zdC4kZXZlbnRzW2tleV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3h5LiRldmVudHMgPSB7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm94eVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gIHJlY3ljbGVQcm94aWVzKHByb3hpZXMpIHtcbiAgICAgICAgZWFjaFByb3h5UmVjeWNsZXIocHJveGllcylcbiAgICB9XG4gICAgZnVuY3Rpb24gZWFjaFByb3h5UmVjeWNsZXIocHJveGllcykge1xuICAgICAgICBwcm94aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgICAgICAgICBwcm94eVJlY3ljbGVyKHByb3h5LCBlYWNoUHJveHlQb29sKVxuICAgICAgICB9KVxuICAgICAgICBwcm94aWVzLmxlbmd0aCA9IDBcbiAgICB9XG5cblxuICAgIHZhciBlYWNoUHJveHlQb29sID0gW11cbiAgICBmdW5jdGlvbiBlYWNoUHJveHlGYWN0b3J5KG5hbWUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHtcbiAgICAgICAgICAgICRob3N0OiBbXSxcbiAgICAgICAgICAgICRvdXRlcjoge30sXG4gICAgICAgICAgICAkaW5kZXg6IDAsXG4gICAgICAgICAgICAkZmlyc3Q6IGZhbHNlLFxuICAgICAgICAgICAgJGxhc3Q6IGZhbHNlLFxuICAgICAgICAgICAgJHJlbW92ZTogYXZhbG9uLm5vb3BcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VbbmFtZV0gPSB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuJGV2ZW50c1xuICAgICAgICAgICAgICAgIHZhciBhcnJheSA9IGUuJGluZGV4XG4gICAgICAgICAgICAgICAgZS4kaW5kZXggPSBlW25hbWVdIC8vIzgxNyDpgJrov4ckaW5kZXjkuLplbOaUtumbhuS+nei1llxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiRob3N0W3RoaXMuJGluZGV4XVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGUuJGluZGV4ID0gYXJyYXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLiRldmVudHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gZS4kaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgZS4kaW5kZXggPSBbXVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRob3N0LnNldCh0aGlzLiRpbmRleCwgdmFsKVxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGUuJGluZGV4ID0gYXJyYXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlY29uZCA9IHtcbiAgICAgICAgICAgICRsYXN0OiAxLFxuICAgICAgICAgICAgJGZpcnN0OiAxLFxuICAgICAgICAgICAgJGluZGV4OiAxXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3h5ID0gbW9kZWxGYWN0b3J5KHNvdXJjZSwgc2Vjb25kKVxuICAgICAgICBwcm94eS4kaWQgPSBnZW5lcmF0ZUlEKFwiJHByb3h5JGVhY2hcIilcbiAgICAgICAgcmV0dXJuIHByb3h5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWFjaFByb3h5QWdlbnQoaW5kZXgsIGRhdGEpIHtcbiAgICAgICAgdmFyIHBhcmFtID0gZGF0YS5wYXJhbSB8fCBcImVsXCIsXG4gICAgICAgICAgICBwcm94eVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbiA9IGVhY2hQcm94eVBvb2wubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlID0gZWFjaFByb3h5UG9vbFtpXVxuICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSAmJiBjYW5kaWRhdGUuaGFzT3duUHJvcGVydHkocGFyYW0pKSB7XG4gICAgICAgICAgICAgICAgcHJveHkgPSBjYW5kaWRhdGVcbiAgICAgICAgICAgICAgICBlYWNoUHJveHlQb29sLnNwbGljZShpLCAxKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcHJveHkpIHtcbiAgICAgICAgICAgIHByb3h5ID0gZWFjaFByb3h5RmFjdG9yeShwYXJhbSlcbiAgICAgICAgfVxuICAgICAgICB2YXIgaG9zdCA9IGRhdGEuJHJlcGVhdFxuICAgICAgICB2YXIgbGFzdCA9IGhvc3QubGVuZ3RoIC0gMVxuICAgICAgICBwcm94eS4kaW5kZXggPSBpbmRleFxuICAgICAgICBwcm94eS4kZmlyc3QgPSBpbmRleCA9PT0gMFxuICAgICAgICBwcm94eS4kbGFzdCA9IGluZGV4ID09PSBsYXN0XG4gICAgICAgIHByb3h5LiRob3N0ID0gaG9zdFxuICAgICAgICBwcm94eS4kb3V0ZXIgPSBkYXRhLiRvdXRlclxuICAgICAgICBwcm94eS4kcmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvc3QucmVtb3ZlQXQocHJveHkuJGluZGV4KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm94eVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcHJveHlSZWN5Y2xlcihwcm94eSwgcHJveHlQb29sKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gcHJveHkuJGV2ZW50cykge1xuICAgICAgICAgICAgdmFyIGFyciA9IHByb3h5LiRldmVudHNbaV1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgICAgICAgICBhcnIuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwb3NlRGF0YShkYXRhKVxuICAgICAgICAgICAgICAgIH0pLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gICAgICAgICAgICAgICAgYXJyLmxlbmd0aCA9IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcm94eS4kaG9zdCA9IHByb3h5LiRvdXRlciA9IHt9XG4gICAgICAgIGlmIChwcm94eVBvb2wudW5zaGlmdChwcm94eSkgPiBrZXJuZWwubWF4UmVwZWF0U2l6ZSkge1xuICAgICAgICAgICAgcHJveHlQb29sLnBvcCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAg5ZCE56eN5oyH5LukICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8vbXMtc2tpcOe7keWumuW3sue7j+WcqHNjYW5UYWcg5pa55rOV5Lit5a6e546wXG4vLyBiaW5kaW5nSGFuZGxlcnMudGV4dCDlrprkuYnlnKhpZi5qc1xuICAgIGJpbmRpbmdFeGVjdXRvcnMudGV4dCA9IGZ1bmN0aW9uKHZhbCwgZWxlbSkge1xuICAgICAgICB2YWwgPSB2YWwgPT0gbnVsbCA/IFwiXCIgOiB2YWwgLy/kuI3lnKjpobXpnaLkuIrmmL7npLp1bmRlZmluZWQgbnVsbFxuICAgICAgICBpZiAoZWxlbS5ub2RlVHlwZSA9PT0gMykgeyAvL+e7keWumuWcqOaWh+acrOiKgueCueS4ilxuICAgICAgICAgICAgdHJ5IHsgLy9JReWvuea4uOemu+S6jkRPTeagkeWklueahOiKgueCuei1i+WAvOS8muaKpemUmVxuICAgICAgICAgICAgICAgIGVsZW0uZGF0YSA9IHZhbFxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfSBlbHNlIHsgLy/nu5HlrprlnKjnibnmgKfoioLngrnkuIpcbiAgICAgICAgICAgIGlmIChcInRleHRDb250ZW50XCIgaW4gZWxlbSkge1xuICAgICAgICAgICAgICAgIGVsZW0udGV4dENvbnRlbnQgPSB2YWxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbS5pbm5lclRleHQgPSB2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZURpc3BsYXkobm9kZU5hbWUsIHZhbCkge1xuICAgICAgICAvL+eUqOS6juWPluW+l+atpOexu+agh+etvueahOm7mOiupGRpc3BsYXnlgLxcbiAgICAgICAgdmFyIGtleSA9IFwiX1wiICsgbm9kZU5hbWVcbiAgICAgICAgaWYgKCFwYXJzZURpc3BsYXlba2V5XSkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBET0MuY3JlYXRlRWxlbWVudChub2RlTmFtZSlcbiAgICAgICAgICAgIHJvb3QuYXBwZW5kQ2hpbGQobm9kZSlcbiAgICAgICAgICAgIGlmIChXM0MpIHtcbiAgICAgICAgICAgICAgICB2YWwgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmRpc3BsYXlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsID0gbm9kZS5jdXJyZW50U3R5bGUuZGlzcGxheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChub2RlKVxuICAgICAgICAgICAgcGFyc2VEaXNwbGF5W2tleV0gPSB2YWxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VEaXNwbGF5W2tleV1cbiAgICB9XG5cbiAgICBhdmFsb24ucGFyc2VEaXNwbGF5ID0gcGFyc2VEaXNwbGF5XG5cbiAgICBiaW5kaW5nSGFuZGxlcnMudmlzaWJsZSA9IGZ1bmN0aW9uIChkYXRhLCB2bW9kZWxzKSB7XG4gICAgICAgIHBhcnNlRXhwclByb3h5KGRhdGEudmFsdWUsIHZtb2RlbHMsIGRhdGEpXG4gICAgfVxuXG4gICAgYmluZGluZ0V4ZWN1dG9ycy52aXNpYmxlID0gZnVuY3Rpb24gKHZhbCwgZWxlbSwgYmluZGluZykge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSBiaW5kaW5nLmRpc3BsYXkgfHwgXCJcIlxuICAgICAgICAgICAgaWYgKGF2YWxvbihlbGVtKS5jc3MoXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIikge1xuICAgICAgICAgICAgICAgIGVsZW0uc3R5bGUuZGlzcGxheSA9IGJpbmRpbmcuZGlzcGxheSA9IHBhcnNlRGlzcGxheShlbGVtLm5vZGVOYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCJcbiAgICAgICAgfVxuICAgIH1cbiAgICBiaW5kaW5nSGFuZGxlcnMud2lkZ2V0ID0gZnVuY3Rpb24oZGF0YSwgdm1vZGVscykge1xuICAgICAgICB2YXIgYXJncyA9IGRhdGEudmFsdWUubWF0Y2gocndvcmQpXG4gICAgICAgIHZhciBlbGVtID0gZGF0YS5lbGVtZW50XG4gICAgICAgIHZhciB3aWRnZXQgPSBhcmdzWzBdXG4gICAgICAgIHZhciBpZCA9IGFyZ3NbMV1cbiAgICAgICAgaWYgKCFpZCB8fCBpZCA9PT0gXCIkXCIpIHsgLy/msqHmnInlrprkuYnmiJbkuLok5pe277yM5Y+W57uE5Lu25ZCNK+maj+acuuaVsFxuICAgICAgICAgICAgaWQgPSBnZW5lcmF0ZUlEKHdpZGdldClcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3B0TmFtZSA9IGFyZ3NbMl0gfHwgd2lkZ2V0IC8v5rKh5pyJ5a6a5LmJ77yM5Y+W57uE5Lu25ZCNXG4gICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IGF2YWxvbi51aVt3aWRnZXRdXG4gICAgICAgIGlmICh0eXBlb2YgY29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikgeyAvL21zLXdpZGdldD1cInRhYnMsdGFic0FBQSxvcHRuYW1lXCJcbiAgICAgICAgICAgIHZtb2RlbHMgPSBlbGVtLnZtb2RlbHMgfHwgdm1vZGVsc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHY7IHYgPSB2bW9kZWxzW2krK107KSB7XG4gICAgICAgICAgICAgICAgaWYgKHYuaGFzT3duUHJvcGVydHkob3B0TmFtZSkgJiYgdHlwZW9mIHZbb3B0TmFtZV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZtT3B0aW9ucyA9IHZbb3B0TmFtZV1cbiAgICAgICAgICAgICAgICAgICAgdm1PcHRpb25zID0gdm1PcHRpb25zLiRtb2RlbCB8fCB2bU9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodm1PcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdpZCA9IHZtT3B0aW9uc1t3aWRnZXQgKyBcIklkXCJdXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3aWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nKFwid2FybmluZyHkuI3lho3mlK/mjIFcIiArIHdpZGdldCArIFwiSWRcIilcbiAgICAgICAgICAgICAgICAgICAgaWQgPSB3aWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL+aKveWPlmRhdGEtdG9vbHRpcC10ZXh044CBZGF0YS10b29sdGlwLWF0dHLlsZ7mgKfvvIznu4TmiJDkuIDkuKrphY3nva7lr7nosaFcbiAgICAgICAgICAgIHZhciB3aWRnZXREYXRhID0gYXZhbG9uLmdldFdpZGdldERhdGEoZWxlbSwgd2lkZ2V0KVxuICAgICAgICAgICAgZGF0YS52YWx1ZSA9IFt3aWRnZXQsIGlkLCBvcHROYW1lXS5qb2luKFwiLFwiKVxuICAgICAgICAgICAgZGF0YVt3aWRnZXQgKyBcIklkXCJdID0gaWRcbiAgICAgICAgICAgIGRhdGEuZXZhbHVhdG9yID0gbm9vcFxuICAgICAgICAgICAgZWxlbS5tc0RhdGFbXCJtcy13aWRnZXQtaWRcIl0gPSBpZFxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBkYXRhW3dpZGdldCArIFwiT3B0aW9uc1wiXSA9IGF2YWxvbi5taXgoe30sIGNvbnN0cnVjdG9yLmRlZmF1bHRzLCB2bU9wdGlvbnMgfHwge30sIHdpZGdldERhdGEpXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZShcIm1zLXdpZGdldFwiKVxuICAgICAgICAgICAgdmFyIHZtb2RlbCA9IGNvbnN0cnVjdG9yKGVsZW0sIGRhdGEsIHZtb2RlbHMpIHx8IHt9IC8v6Ziy5q2i57uE5Lu25LiN6L+U5ZueVk1cbiAgICAgICAgICAgIGlmICh2bW9kZWwuJGlkKSB7XG4gICAgICAgICAgICAgICAgYXZhbG9uLnZtb2RlbHNbaWRdID0gdm1vZGVsXG4gICAgICAgICAgICAgICAgY3JlYXRlU2lnbmFsVG93ZXIoZWxlbSwgdm1vZGVsKVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZtb2RlbC4kaW5pdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2YWxvbi5zY2FuKGVsZW0sIFt2bW9kZWxdLmNvbmNhdCh2bW9kZWxzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vbkluaXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25Jbml0LmNhbGwoZWxlbSwgdm1vZGVsLCBvcHRpb25zLCB2bW9kZWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtsb2coZSl9XG4gICAgICAgICAgICAgICAgZGF0YS5yb2xsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdm1vZGVsLiRyZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgdm1vZGVsLndpZGdldEVsZW1lbnQgPSBudWxsIC8vIOaUvuWIsCRyZW1vdmXlkI7ovrlcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgZWxlbS5tc0RhdGEgPSB7fVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXZhbG9uLnZtb2RlbHNbdm1vZGVsLiRpZF1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5qZWN0RGlzcG9zZVF1ZXVlKGRhdGEsIHdpZGdldExpc3QpXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jaHJvbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHJlamVjdERpc3Bvc2VRdWV1ZSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF2YWxvbi5zY2FuKGVsZW0sIHZtb2RlbHMpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodm1vZGVscy5sZW5ndGgpIHsgLy/lpoLmnpzor6Xnu4Tku7bov5jmsqHmnInliqDovb3vvIzpgqPkuYjkv53lrZjlvZPliY3nmoR2bW9kZWxzXG4gICAgICAgICAgICBlbGVtLnZtb2RlbHMgPSB2bW9kZWxzXG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHdpZGdldExpc3QgPSBbXVxuLy/kuI3lrZjlnKggYmluZGluZ0V4ZWN1dG9ycy53aWRnZXRcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIOiHquW4pui/h+a7pOWZqCAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgdmFyIHJzY3JpcHRzID0gLzxzY3JpcHRbXj5dKj4oW1xcU1xcc10qPyk8XFwvc2NyaXB0XFxzKj4vZ2ltXG4gICAgdmFyIHJvbiA9IC9cXHMrKG9uW149XFxzXSspKD86PShcIlteXCJdKlwifCdbXiddKid8W15cXHM+XSspKT8vZ1xuICAgIHZhciByb3BlbiA9IC88XFx3K1xcYig/OihbXCInXSlbXlwiXSo/KFxcMSl8W14+XSkqPi9pZ1xuICAgIHZhciByc2FuaXRpemUgPSB7XG4gICAgICAgIGE6IC9cXGIoaHJlZilcXD0oXCJqYXZhc2NyaXB0W15cIl0qXCJ8J2phdmFzY3JpcHRbXiddKicpL2lnLFxuICAgICAgICBpbWc6IC9cXGIoc3JjKVxcPShcImphdmFzY3JpcHRbXlwiXSpcInwnamF2YXNjcmlwdFteJ10qJykvaWcsXG4gICAgICAgIGZvcm06IC9cXGIoYWN0aW9uKVxcPShcImphdmFzY3JpcHRbXlwiXSpcInwnamF2YXNjcmlwdFteJ10qJykvaWdcbiAgICB9XG4gICAgdmFyIHJzdXJyb2dhdGUgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nXG4gICAgdmFyIHJub2FscGhhbnVtZXJpYyA9IC8oW15cXCMtfnwgfCFdKS9nO1xuXG4gICAgZnVuY3Rpb24gbnVtYmVyRm9ybWF0KG51bWJlciwgZGVjaW1hbHMsIHBvaW50LCB0aG91c2FuZHMpIHtcbiAgICAgICAgLy9mb3JtIGh0dHA6Ly9waHBqcy5vcmcvZnVuY3Rpb25zL251bWJlcl9mb3JtYXQvXG4gICAgICAgIC8vbnVtYmVyXHTlv4XpnIDvvIzopoHmoLzlvI/ljJbnmoTmlbDlrZdcbiAgICAgICAgLy9kZWNpbWFsc1x05Y+v6YCJ77yM6KeE5a6a5aSa5bCR5Liq5bCP5pWw5L2N44CCXG4gICAgICAgIC8vcG9pbnRcdOWPr+mAie+8jOinhOWumueUqOS9nOWwj+aVsOeCueeahOWtl+espuS4su+8iOm7mOiupOS4uiAuIO+8ieOAglxuICAgICAgICAvL3Rob3VzYW5kc1x05Y+v6YCJ77yM6KeE5a6a55So5L2c5Y2D5L2N5YiG6ZqU56ym55qE5a2X56ym5Liy77yI6buY6K6k5Li6ICwg77yJ77yM5aaC5p6c6K6+572u5LqG6K+l5Y+C5pWw77yM6YKj5LmI5omA5pyJ5YW25LuW5Y+C5pWw6YO95piv5b+F6ZyA55qE44CCXG4gICAgICAgIG51bWJlciA9IChudW1iZXIgKyAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXjAtOStcXC1FZS5dL2csICcnKVxuICAgICAgICB2YXIgbiA9ICFpc0Zpbml0ZSgrbnVtYmVyKSA/IDAgOiArbnVtYmVyLFxuICAgICAgICAgICAgcHJlYyA9ICFpc0Zpbml0ZSgrZGVjaW1hbHMpID8gMyA6IE1hdGguYWJzKGRlY2ltYWxzKSxcbiAgICAgICAgICAgIHNlcCA9IHRob3VzYW5kcyB8fCBcIixcIixcbiAgICAgICAgICAgIGRlYyA9IHBvaW50IHx8IFwiLlwiLFxuICAgICAgICAgICAgcyA9ICcnLFxuICAgICAgICAgICAgdG9GaXhlZEZpeCA9IGZ1bmN0aW9uKG4sIHByZWMpIHtcbiAgICAgICAgICAgICAgICB2YXIgayA9IE1hdGgucG93KDEwLCBwcmVjKVxuICAgICAgICAgICAgICAgIHJldHVybiAnJyArIChNYXRoLnJvdW5kKG4gKiBrKSAvIGspXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9GaXhlZChwcmVjKVxuICAgICAgICAgICAgfVxuICAgICAgICAvLyBGaXggZm9yIElFIHBhcnNlRmxvYXQoMC41NSkudG9GaXhlZCgwKSA9IDA7XG4gICAgICAgIHMgPSAocHJlYyA/IHRvRml4ZWRGaXgobiwgcHJlYykgOiAnJyArIE1hdGgucm91bmQobikpXG4gICAgICAgICAgICAuc3BsaXQoJy4nKVxuICAgICAgICBpZiAoc1swXS5sZW5ndGggPiAzKSB7XG4gICAgICAgICAgICBzWzBdID0gc1swXS5yZXBsYWNlKC9cXEIoPz0oPzpcXGR7M30pKyg/IVxcZCkpL2csIHNlcClcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHNbMV0gfHwgJycpXG4gICAgICAgICAgICAgICAgLmxlbmd0aCA8IHByZWMpIHtcbiAgICAgICAgICAgIHNbMV0gPSBzWzFdIHx8ICcnXG4gICAgICAgICAgICBzWzFdICs9IG5ldyBBcnJheShwcmVjIC0gc1sxXS5sZW5ndGggKyAxKVxuICAgICAgICAgICAgICAgIC5qb2luKCcwJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcy5qb2luKGRlYylcbiAgICB9XG5cblxuICAgIHZhciBmaWx0ZXJzID0gYXZhbG9uLmZpbHRlcnMgPSB7XG4gICAgICAgIHVwcGVyY2FzZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKClcbiAgICAgICAgfSxcbiAgICAgICAgbG93ZXJjYXNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHIudG9Mb3dlckNhc2UoKVxuICAgICAgICB9LFxuICAgICAgICB0cnVuY2F0ZTogZnVuY3Rpb24oc3RyLCBsZW5ndGgsIHRydW5jYXRpb24pIHtcbiAgICAgICAgICAgIC8vbGVuZ3Ro77yM5paw5a2X56ym5Liy6ZW/5bqm77yMdHJ1bmNhdGlvbu+8jOaWsOWtl+espuS4sueahOe7k+WwvueahOWtl+autSzov5Tlm57mlrDlrZfnrKbkuLJcbiAgICAgICAgICAgIGxlbmd0aCA9IGxlbmd0aCB8fCAzMFxuICAgICAgICAgICAgdHJ1bmNhdGlvbiA9IHR5cGVvZiB0cnVuY2F0aW9uID09PSBcInN0cmluZ1wiID8gIHRydW5jYXRpb24gOiBcIi4uLlwiXG4gICAgICAgICAgICByZXR1cm4gc3RyLmxlbmd0aCA+IGxlbmd0aCA/IHN0ci5zbGljZSgwLCBsZW5ndGggLSB0cnVuY2F0aW9uLmxlbmd0aCkgKyB0cnVuY2F0aW9uIDogU3RyaW5nKHN0cilcbiAgICAgICAgfSxcbiAgICAgICAgJGZpbHRlcjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJyYXkgPSBhcmd1bWVudHNbaV1cbiAgICAgICAgICAgICAgICB2YXIgZm4gPSBhdmFsb24uZmlsdGVyc1thcnJheVswXV1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyciA9IFt2YWxdLmNvbmNhdChhcnJheS5zbGljZSgxKSlcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gZm4uYXBwbHkobnVsbCwgYXJyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgfSxcbiAgICAgICAgY2FtZWxpemU6IGNhbWVsaXplLFxuICAgICAgICAvL2h0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gICAgICAgIC8vICAgIDxhIGhyZWY9XCJqYXZhc2MmTmV3TGluZTtyaXB0JmNvbG9uO2FsZXJ0KCdYU1MnKVwiPmNocm9tZTwvYT5cbiAgICAgICAgLy8gICAgPGEgaHJlZj1cImRhdGE6dGV4dC9odG1sO2Jhc2U2NCwgUEdsdFp5QnpjbU05ZUNCdmJtVnljbTl5UFdGc1pYSjBLREVwUGc9PVwiPmNocm9tZTwvYT5cbiAgICAgICAgLy8gICAgPGEgaHJlZj1cImphdlx0YXNjcmlwdDphbGVydCgnWFNTJyk7XCI+SUU2N2Nocm9tZTwvYT5cbiAgICAgICAgLy8gICAgPGEgaHJlZj1cImphdiYjeDA5O2FzY3JpcHQ6YWxlcnQoJ1hTUycpO1wiPklFNjdjaHJvbWU8L2E+XG4gICAgICAgIC8vICAgIDxhIGhyZWY9XCJqYXYmI3gwQTthc2NyaXB0OmFsZXJ0KCdYU1MnKTtcIj5JRTY3Y2hyb21lPC9hPlxuICAgICAgICBzYW5pdGl6ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocnNjcmlwdHMsIFwiXCIpLnJlcGxhY2Uocm9wZW4sIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBhLnRvTG93ZXJDYXNlKCkubWF0Y2goLzwoXFx3KylcXHMvKVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkgeyAvL+WkhOeQhmHmoIfnrb7nmoRocmVm5bGe5oCn77yMaW1n5qCH562+55qEc3Jj5bGe5oCn77yMZm9ybeagh+etvueahGFjdGlvbuWxnuaAp1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVnID0gcnNhbml0aXplW21hdGNoWzFdXVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhID0gYS5yZXBsYWNlKHJlZywgZnVuY3Rpb24ocywgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVvdGUgPSB2YWx1ZS5jaGFyQXQoMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZSArIFwiPVwiICsgcXVvdGUgKyBcImphdmFzY3JpcHQ6dm9pZCgwKVwiICsgcXVvdGUvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucmVwbGFjZShyb24sIFwiIFwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKSAvL+enu+mZpG9uWFhY5LqL5Lu2XG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBlc2NhcGU6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgLy/lsIblrZfnrKbkuLLnu4/ov4cgc3RyIOi9rOS5ieW+l+WIsOmAguWQiOWcqOmhtemdouS4reaYvuekuueahOWGheWuuSwg5L6L5aaC5pu/5o2iIDwg5Li6ICZsdFxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLlxuICAgICAgICAgICAgICAgIHJlcGxhY2UoLyYvZywgJyZhbXA7JykuXG4gICAgICAgICAgICAgICAgcmVwbGFjZShyc3Vycm9nYXRlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGkgPSB2YWx1ZS5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb3cgPSB2YWx1ZS5jaGFyQ29kZUF0KDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnJiMnICsgKCgoaGkgLSAweEQ4MDApICogMHg0MDApICsgKGxvdyAtIDB4REMwMCkgKyAweDEwMDAwKSArICc7J1xuICAgICAgICAgICAgICAgIH0pLlxuICAgICAgICAgICAgICAgIHJlcGxhY2Uocm5vYWxwaGFudW1lcmljLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyYjJyArIHZhbHVlLmNoYXJDb2RlQXQoMCkgKyAnOydcbiAgICAgICAgICAgICAgICB9KS5cbiAgICAgICAgICAgICAgICByZXBsYWNlKC88L2csICcmbHQ7JykuXG4gICAgICAgICAgICAgICAgcmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgIH0sXG4gICAgICAgIGN1cnJlbmN5OiBmdW5jdGlvbihhbW91bnQsIHN5bWJvbCwgZnJhY3Rpb25TaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gKHN5bWJvbCB8fCBcIlxcdUZGRTVcIikgKyBudW1iZXJGb3JtYXQoYW1vdW50LCBpc0Zpbml0ZShmcmFjdGlvblNpemUpID8gZnJhY3Rpb25TaXplIDogMilcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBudW1iZXJGb3JtYXRcbiAgICB9XG4gICAgLypcbiAgICAgJ3l5eXknOiA0IGRpZ2l0IHJlcHJlc2VudGF0aW9uIG9mIHllYXIgKGUuZy4gQUQgMSA9PiAwMDAxLCBBRCAyMDEwID0+IDIwMTApXG4gICAgICd5eSc6IDIgZGlnaXQgcmVwcmVzZW50YXRpb24gb2YgeWVhciwgcGFkZGVkICgwMC05OSkuIChlLmcuIEFEIDIwMDEgPT4gMDEsIEFEIDIwMTAgPT4gMTApXG4gICAgICd5JzogMSBkaWdpdCByZXByZXNlbnRhdGlvbiBvZiB5ZWFyLCBlLmcuIChBRCAxID0+IDEsIEFEIDE5OSA9PiAxOTkpXG4gICAgICdNTU1NJzogTW9udGggaW4geWVhciAoSmFudWFyeS1EZWNlbWJlcilcbiAgICAgJ01NTSc6IE1vbnRoIGluIHllYXIgKEphbi1EZWMpXG4gICAgICdNTSc6IE1vbnRoIGluIHllYXIsIHBhZGRlZCAoMDEtMTIpXG4gICAgICdNJzogTW9udGggaW4geWVhciAoMS0xMilcbiAgICAgJ2RkJzogRGF5IGluIG1vbnRoLCBwYWRkZWQgKDAxLTMxKVxuICAgICAnZCc6IERheSBpbiBtb250aCAoMS0zMSlcbiAgICAgJ0VFRUUnOiBEYXkgaW4gV2VlaywoU3VuZGF5LVNhdHVyZGF5KVxuICAgICAnRUVFJzogRGF5IGluIFdlZWssIChTdW4tU2F0KVxuICAgICAnSEgnOiBIb3VyIGluIGRheSwgcGFkZGVkICgwMC0yMylcbiAgICAgJ0gnOiBIb3VyIGluIGRheSAoMC0yMylcbiAgICAgJ2hoJzogSG91ciBpbiBhbS9wbSwgcGFkZGVkICgwMS0xMilcbiAgICAgJ2gnOiBIb3VyIGluIGFtL3BtLCAoMS0xMilcbiAgICAgJ21tJzogTWludXRlIGluIGhvdXIsIHBhZGRlZCAoMDAtNTkpXG4gICAgICdtJzogTWludXRlIGluIGhvdXIgKDAtNTkpXG4gICAgICdzcyc6IFNlY29uZCBpbiBtaW51dGUsIHBhZGRlZCAoMDAtNTkpXG4gICAgICdzJzogU2Vjb25kIGluIG1pbnV0ZSAoMC01OSlcbiAgICAgJ2EnOiBhbS9wbSBtYXJrZXJcbiAgICAgJ1onOiA0IGRpZ2l0ICgrc2lnbikgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRpbWV6b25lIG9mZnNldCAoLTEyMDAtKzEyMDApXG4gICAgIGZvcm1hdCBzdHJpbmcgY2FuIGFsc28gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgcHJlZGVmaW5lZCBsb2NhbGl6YWJsZSBmb3JtYXRzOlxuXG4gICAgICdtZWRpdW0nOiBlcXVpdmFsZW50IHRvICdNTU0gZCwgeSBoOm1tOnNzIGEnIGZvciBlbl9VUyBsb2NhbGUgKGUuZy4gU2VwIDMsIDIwMTAgMTI6MDU6MDggcG0pXG4gICAgICdzaG9ydCc6IGVxdWl2YWxlbnQgdG8gJ00vZC95eSBoOm1tIGEnIGZvciBlbl9VUyBsb2NhbGUgKGUuZy4gOS8zLzEwIDEyOjA1IHBtKVxuICAgICAnZnVsbERhdGUnOiBlcXVpdmFsZW50IHRvICdFRUVFLCBNTU1NIGQseScgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiBGcmlkYXksIFNlcHRlbWJlciAzLCAyMDEwKVxuICAgICAnbG9uZ0RhdGUnOiBlcXVpdmFsZW50IHRvICdNTU1NIGQsIHknIGZvciBlbl9VUyBsb2NhbGUgKGUuZy4gU2VwdGVtYmVyIDMsIDIwMTBcbiAgICAgJ21lZGl1bURhdGUnOiBlcXVpdmFsZW50IHRvICdNTU0gZCwgeScgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiBTZXAgMywgMjAxMClcbiAgICAgJ3Nob3J0RGF0ZSc6IGVxdWl2YWxlbnQgdG8gJ00vZC95eScgZm9yIGVuX1VTIGxvY2FsZSAoZS5nLiA5LzMvMTApXG4gICAgICdtZWRpdW1UaW1lJzogZXF1aXZhbGVudCB0byAnaDptbTpzcyBhJyBmb3IgZW5fVVMgbG9jYWxlIChlLmcuIDEyOjA1OjA4IHBtKVxuICAgICAnc2hvcnRUaW1lJzogZXF1aXZhbGVudCB0byAnaDptbSBhJyBmb3IgZW5fVVMgbG9jYWxlIChlLmcuIDEyOjA1IHBtKVxuICAgICAqL1xuICAgIG5ldyBmdW5jdGlvbigpIHsvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgICAgZnVuY3Rpb24gdG9JbnQoc3RyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyLCAxMCkgfHwgMFxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFkTnVtYmVyKG51bSwgZGlnaXRzLCB0cmltKSB7XG4gICAgICAgICAgICB2YXIgbmVnID0gXCJcIlxuICAgICAgICAgICAgaWYgKG51bSA8IDApIHtcbiAgICAgICAgICAgICAgICBuZWcgPSAnLSdcbiAgICAgICAgICAgICAgICBudW0gPSAtbnVtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW0gPSBcIlwiICsgbnVtXG4gICAgICAgICAgICB3aGlsZSAobnVtLmxlbmd0aCA8IGRpZ2l0cylcbiAgICAgICAgICAgICAgICBudW0gPSBcIjBcIiArIG51bVxuICAgICAgICAgICAgaWYgKHRyaW0pXG4gICAgICAgICAgICAgICAgbnVtID0gbnVtLnN1YnN0cihudW0ubGVuZ3RoIC0gZGlnaXRzKVxuICAgICAgICAgICAgcmV0dXJuIG5lZyArIG51bVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZGF0ZUdldHRlcihuYW1lLCBzaXplLCBvZmZzZXQsIHRyaW0pIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZGF0ZVtcImdldFwiICsgbmFtZV0oKVxuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPiAwIHx8IHZhbHVlID4gLW9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gb2Zmc2V0XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwICYmIG9mZnNldCA9PT0gLTEyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gMTJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhZE51bWJlcih2YWx1ZSwgc2l6ZSwgdHJpbSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRhdGVTdHJHZXR0ZXIobmFtZSwgc2hvcnRGb3JtKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGF0ZSwgZm9ybWF0cykge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGVbXCJnZXRcIiArIG5hbWVdKClcbiAgICAgICAgICAgICAgICB2YXIgZ2V0ID0gKHNob3J0Rm9ybSA/IChcIlNIT1JUXCIgKyBuYW1lKSA6IG5hbWUpLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0c1tnZXRdW3ZhbHVlXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdGltZVpvbmVHZXR0ZXIoZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHpvbmUgPSAtMSAqIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKVxuICAgICAgICAgICAgdmFyIHBhZGRlZFpvbmUgPSAoem9uZSA+PSAwKSA/IFwiK1wiIDogXCJcIlxuICAgICAgICAgICAgcGFkZGVkWm9uZSArPSBwYWROdW1iZXIoTWF0aFt6b25lID4gMCA/IFwiZmxvb3JcIiA6IFwiY2VpbFwiXSh6b25lIC8gNjApLCAyKSArIHBhZE51bWJlcihNYXRoLmFicyh6b25lICUgNjApLCAyKVxuICAgICAgICAgICAgcmV0dXJuIHBhZGRlZFpvbmVcbiAgICAgICAgfVxuICAgICAgICAvL+WPluW+l+S4iuWNiOS4i+WNiFxuXG4gICAgICAgIGZ1bmN0aW9uIGFtcG1HZXR0ZXIoZGF0ZSwgZm9ybWF0cykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGUuZ2V0SG91cnMoKSA8IDEyID8gZm9ybWF0cy5BTVBNU1swXSA6IGZvcm1hdHMuQU1QTVNbMV1cbiAgICAgICAgfVxuICAgICAgICB2YXIgREFURV9GT1JNQVRTID0ge1xuICAgICAgICAgICAgeXl5eTogZGF0ZUdldHRlcihcIkZ1bGxZZWFyXCIsIDQpLFxuICAgICAgICAgICAgeXk6IGRhdGVHZXR0ZXIoXCJGdWxsWWVhclwiLCAyLCAwLCB0cnVlKSxcbiAgICAgICAgICAgIHk6IGRhdGVHZXR0ZXIoXCJGdWxsWWVhclwiLCAxKSxcbiAgICAgICAgICAgIE1NTU06IGRhdGVTdHJHZXR0ZXIoXCJNb250aFwiKSxcbiAgICAgICAgICAgIE1NTTogZGF0ZVN0ckdldHRlcihcIk1vbnRoXCIsIHRydWUpLFxuICAgICAgICAgICAgTU06IGRhdGVHZXR0ZXIoXCJNb250aFwiLCAyLCAxKSxcbiAgICAgICAgICAgIE06IGRhdGVHZXR0ZXIoXCJNb250aFwiLCAxLCAxKSxcbiAgICAgICAgICAgIGRkOiBkYXRlR2V0dGVyKFwiRGF0ZVwiLCAyKSxcbiAgICAgICAgICAgIGQ6IGRhdGVHZXR0ZXIoXCJEYXRlXCIsIDEpLFxuICAgICAgICAgICAgSEg6IGRhdGVHZXR0ZXIoXCJIb3Vyc1wiLCAyKSxcbiAgICAgICAgICAgIEg6IGRhdGVHZXR0ZXIoXCJIb3Vyc1wiLCAxKSxcbiAgICAgICAgICAgIGhoOiBkYXRlR2V0dGVyKFwiSG91cnNcIiwgMiwgLTEyKSxcbiAgICAgICAgICAgIGg6IGRhdGVHZXR0ZXIoXCJIb3Vyc1wiLCAxLCAtMTIpLFxuICAgICAgICAgICAgbW06IGRhdGVHZXR0ZXIoXCJNaW51dGVzXCIsIDIpLFxuICAgICAgICAgICAgbTogZGF0ZUdldHRlcihcIk1pbnV0ZXNcIiwgMSksXG4gICAgICAgICAgICBzczogZGF0ZUdldHRlcihcIlNlY29uZHNcIiwgMiksXG4gICAgICAgICAgICBzOiBkYXRlR2V0dGVyKFwiU2Vjb25kc1wiLCAxKSxcbiAgICAgICAgICAgIHNzczogZGF0ZUdldHRlcihcIk1pbGxpc2Vjb25kc1wiLCAzKSxcbiAgICAgICAgICAgIEVFRUU6IGRhdGVTdHJHZXR0ZXIoXCJEYXlcIiksXG4gICAgICAgICAgICBFRUU6IGRhdGVTdHJHZXR0ZXIoXCJEYXlcIiwgdHJ1ZSksXG4gICAgICAgICAgICBhOiBhbXBtR2V0dGVyLFxuICAgICAgICAgICAgWjogdGltZVpvbmVHZXR0ZXJcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmRhdGVGb3JtYXQgPSAvKCg/OlteeU1kSGhtc2FaRSddKyl8KD86Jyg/OlteJ118JycpKicpfCg/OkUrfHkrfE0rfGQrfEgrfGgrfG0rfHMrfGF8WikpKC4qKS9cbiAgICAgICAgdmFyIHJhc3BuZXRqc29uID0gL15cXC9EYXRlXFwoKFxcZCspXFwpXFwvJC9cbiAgICAgICAgZmlsdGVycy5kYXRlID0gZnVuY3Rpb24oZGF0ZSwgZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgbG9jYXRlID0gZmlsdGVycy5kYXRlLmxvY2F0ZSxcbiAgICAgICAgICAgICAgICB0ZXh0ID0gXCJcIixcbiAgICAgICAgICAgICAgICBwYXJ0cyA9IFtdLFxuICAgICAgICAgICAgICAgIGZuLCBtYXRjaFxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8IFwibWVkaXVtRGF0ZVwiXG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhdGVbZm9ybWF0XSB8fCBmb3JtYXRcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSB0b0ludChkYXRlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmFzcG5ldGpzb24udGVzdChkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlID0gK1JlZ0V4cC4kMVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmltRGF0ZSA9IGRhdGUudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRlQXJyYXkgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMF1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9EYXRlID0gbmV3IERhdGUoMClcbiAgICAgICAgICAgICAgICAgICAgLy/lj5blvpflubTmnIjml6VcbiAgICAgICAgICAgICAgICAgICAgdHJpbURhdGUgPSB0cmltRGF0ZS5yZXBsYWNlKC9eKFxcZCspXFxEKFxcZCspXFxEKFxcZCspLywgZnVuY3Rpb24oXywgYSwgYiwgYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFycmF5ID0gYy5sZW5ndGggPT09IDQgPyBbYywgYSwgYl0gOiBbYSwgYiwgY11cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVBcnJheVswXSA9IHRvSW50KGFycmF5WzBdKSAgICAgLy/lubRcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVBcnJheVsxXSA9IHRvSW50KGFycmF5WzFdKSAtIDEgLy/mnIhcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVBcnJheVsyXSA9IHRvSW50KGFycmF5WzJdKSAgICAgLy/ml6VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRlU2V0dGVyID0gb0RhdGUuc2V0RnVsbFllYXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVTZXR0ZXIgPSBvRGF0ZS5zZXRIb3Vyc1xuICAgICAgICAgICAgICAgICAgICB0cmltRGF0ZSA9IHRyaW1EYXRlLnJlcGxhY2UoL1tUXFxzXShcXGQrKTooXFxkKyk6PyhcXGQrKT9cXC4/KFxcZCk/LywgZnVuY3Rpb24oXywgYSwgYiwgYywgZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUFycmF5WzNdID0gdG9JbnQoYSkgLy/lsI/ml7ZcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVBcnJheVs0XSA9IHRvSW50KGIpIC8v5YiG6ZKfXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXlbNV0gPSB0b0ludChjKSAvL+enklxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQpIHsgICAgICAgICAgICAgICAgLy/mr6vnp5JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXlbNl0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoXCIwLlwiICsgZCkgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR6SG91ciA9IDBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR6TWluID0gMFxuICAgICAgICAgICAgICAgICAgICB0cmltRGF0ZSA9IHRyaW1EYXRlLnJlcGxhY2UoL1p8KFsrLV0pKFxcZFxcZCk6PyhcXGRcXGQpLywgZnVuY3Rpb24oeiwgc3ltYm9sLCBjLCBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlU2V0dGVyID0gb0RhdGUuc2V0VVRDRnVsbFllYXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVTZXR0ZXIgPSBvRGF0ZS5zZXRVVENIb3Vyc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR6SG91ciA9IHRvSW50KHN5bWJvbCArIGMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHpNaW4gPSB0b0ludChzeW1ib2wgKyBkKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBkYXRlQXJyYXlbM10gLT0gdHpIb3VyXG4gICAgICAgICAgICAgICAgICAgIGRhdGVBcnJheVs0XSAtPSB0ek1pblxuICAgICAgICAgICAgICAgICAgICBkYXRlU2V0dGVyLmFwcGx5KG9EYXRlLCBkYXRlQXJyYXkuc2xpY2UoMCwgMykpXG4gICAgICAgICAgICAgICAgICAgIHRpbWVTZXR0ZXIuYXBwbHkob0RhdGUsIGRhdGVBcnJheS5zbGljZSgzKSlcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG9EYXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXZhbG9uLnR5cGUoZGF0ZSkgIT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSByZGF0ZUZvcm1hdC5leGVjKGZvcm1hdClcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMgPSBwYXJ0cy5jb25jYXQobWF0Y2guc2xpY2UoMSkpXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IHBhcnRzLnBvcCgpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHMucHVzaChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdCA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZm4gPSBEQVRFX0ZPUk1BVFNbdmFsdWVdXG4gICAgICAgICAgICAgICAgdGV4dCArPSBmbiA/IGZuKGRhdGUsIGxvY2F0ZSkgOiB2YWx1ZS5yZXBsYWNlKC8oXid8JyQpL2csIFwiXCIpLnJlcGxhY2UoLycnL2csIFwiJ1wiKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2F0ZSA9IHtcbiAgICAgICAgICAgIEFNUE1TOiB7XG4gICAgICAgICAgICAgICAgMDogXCLkuIrljYhcIixcbiAgICAgICAgICAgICAgICAxOiBcIuS4i+WNiFwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgREFZOiB7XG4gICAgICAgICAgICAgICAgMDogXCLmmJ/mnJ/ml6VcIixcbiAgICAgICAgICAgICAgICAxOiBcIuaYn+acn+S4gFwiLFxuICAgICAgICAgICAgICAgIDI6IFwi5pif5pyf5LqMXCIsXG4gICAgICAgICAgICAgICAgMzogXCLmmJ/mnJ/kuIlcIixcbiAgICAgICAgICAgICAgICA0OiBcIuaYn+acn+Wbm1wiLFxuICAgICAgICAgICAgICAgIDU6IFwi5pif5pyf5LqUXCIsXG4gICAgICAgICAgICAgICAgNjogXCLmmJ/mnJ/lha1cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIE1PTlRIOiB7XG4gICAgICAgICAgICAgICAgMDogXCIx5pyIXCIsXG4gICAgICAgICAgICAgICAgMTogXCIy5pyIXCIsXG4gICAgICAgICAgICAgICAgMjogXCIz5pyIXCIsXG4gICAgICAgICAgICAgICAgMzogXCI05pyIXCIsXG4gICAgICAgICAgICAgICAgNDogXCI15pyIXCIsXG4gICAgICAgICAgICAgICAgNTogXCI25pyIXCIsXG4gICAgICAgICAgICAgICAgNjogXCI35pyIXCIsXG4gICAgICAgICAgICAgICAgNzogXCI45pyIXCIsXG4gICAgICAgICAgICAgICAgODogXCI55pyIXCIsXG4gICAgICAgICAgICAgICAgOTogXCIxMOaciFwiLFxuICAgICAgICAgICAgICAgIDEwOiBcIjEx5pyIXCIsXG4gICAgICAgICAgICAgICAgMTE6IFwiMTLmnIhcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFNIT1JUREFZOiB7XG4gICAgICAgICAgICAgICAgXCIwXCI6IFwi5ZGo5pelXCIsXG4gICAgICAgICAgICAgICAgXCIxXCI6IFwi5ZGo5LiAXCIsXG4gICAgICAgICAgICAgICAgXCIyXCI6IFwi5ZGo5LqMXCIsXG4gICAgICAgICAgICAgICAgXCIzXCI6IFwi5ZGo5LiJXCIsXG4gICAgICAgICAgICAgICAgXCI0XCI6IFwi5ZGo5ZubXCIsXG4gICAgICAgICAgICAgICAgXCI1XCI6IFwi5ZGo5LqUXCIsXG4gICAgICAgICAgICAgICAgXCI2XCI6IFwi5ZGo5YWtXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdWxsRGF0ZTogXCJ55bm0TeaciGTml6VFRUVFXCIsXG4gICAgICAgICAgICBsb25nRGF0ZTogXCJ55bm0TeaciGTml6VcIixcbiAgICAgICAgICAgIG1lZGl1bTogXCJ5eXl5LU0tZCBIOm1tOnNzXCIsXG4gICAgICAgICAgICBtZWRpdW1EYXRlOiBcInl5eXktTS1kXCIsXG4gICAgICAgICAgICBtZWRpdW1UaW1lOiBcIkg6bW06c3NcIixcbiAgICAgICAgICAgIFwic2hvcnRcIjogXCJ5eS1NLWQgYWg6bW1cIixcbiAgICAgICAgICAgIHNob3J0RGF0ZTogXCJ5eS1NLWRcIixcbiAgICAgICAgICAgIHNob3J0VGltZTogXCJhaDptbVwiXG4gICAgICAgIH1cbiAgICAgICAgbG9jYXRlLlNIT1JUTU9OVEggPSBsb2NhdGUuTU9OVEhcbiAgICAgICAgZmlsdGVycy5kYXRlLmxvY2F0ZSA9IGxvY2F0ZVxuICAgIH0vLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogICAgICAgICAgICAgICAgICAgICBFTkQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgIG5ldyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGF2YWxvbi5jb25maWcoe1xuICAgICAgICAgICAgbG9hZGVyOiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgICB2YXIgZm5zID0gW10sIGxvYWRlZCA9IERPQy5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIsIGZuXG4gICAgICAgIGZ1bmN0aW9uIGZsdXNoKGYpIHtcbiAgICAgICAgICAgIGxvYWRlZCA9IDFcbiAgICAgICAgICAgIHdoaWxlIChmID0gZm5zLnNoaWZ0KCkpXG4gICAgICAgICAgICAgICAgZigpXG4gICAgICAgIH1cblxuICAgICAgICBhdmFsb24uYmluZChET0MsIFwiRE9NQ29udGVudExvYWRlZFwiLCBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGF2YWxvbi51bmJpbmQoRE9DLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgZm4pXG4gICAgICAgICAgICBmbHVzaCgpXG4gICAgICAgIH0pXG5cbiAgICAgICAgdmFyIGlkID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpZClcbiAgICAgICAgICAgICAgICBmbHVzaCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDUwKVxuXG4gICAgICAgIGF2YWxvbi5yZWFkeSA9IGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgbG9hZGVkID8gZm4oYXZhbG9uKSA6IGZucy5wdXNoKGZuKVxuICAgICAgICB9XG4gICAgICAgIGF2YWxvbi5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBhdmFsb24uc2NhbihET0MuYm9keSlcbiAgICAgICAgfSlcbiAgICB9XG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBhdmFsb24gY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGF2YWxvbiBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgQXZhbG9uIGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgYXZhbG9uLCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBhdmFsb24gc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGF2YWxvbiBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoXCJhdmFsb25cIiwgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF2YWxvblxuICAgICAgICB9KVxuICAgIH1cbi8vIE1hcCBvdmVyIGF2YWxvbiBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuICAgIHZhciBfYXZhbG9uID0gd2luZG93LmF2YWxvblxuICAgIGF2YWxvbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oZGVlcCkge1xuICAgICAgICBpZiAoZGVlcCAmJiB3aW5kb3cuYXZhbG9uID09PSBhdmFsb24pIHtcbiAgICAgICAgICAgIHdpbmRvdy5hdmFsb24gPSBfYXZhbG9uXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF2YWxvblxuICAgIH1cbi8vIEV4cG9zZSBhdmFsb24gaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzXG4gICAgaWYgKG5vR2xvYmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgd2luZG93LmF2YWxvbiA9IGF2YWxvblxuICAgIH1cblxuICAgIHJldHVybiBhdmFsb25cblxufSkpO1xuXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2F2YWxvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ }
/******/ ]);